Directory structure:
└── igvc/
    ├── README.md
    ├── frames.gv
    ├── his.txt
    ├── .catkin_workspace
    ├── catkin_ws/
    │   └── src/
    ├── devel/
    │   ├── _setup_util.py
    │   ├── cmake.lock
    │   ├── env.sh
    │   ├── local_setup.bash
    │   ├── local_setup.sh
    │   ├── local_setup.zsh
    │   ├── setup.bash
    │   ├── setup.sh
    │   ├── setup.zsh
    │   ├── .built_by
    │   ├── .catkin
    │   ├── .rosinstall
    │   ├── lib/
    │   │   ├── pkgconfig/
    │   │   │   ├── ashwini.pc
    │   │   │   └── rplidar_ros.pc
    │   │   └── rplidar_ros/
    │   │       ├── rplidarNode
    │   │       └── rplidarNodeClient
    │   └── share/
    │       ├── ashwini/
    │       │   └── cmake/
    │       │       ├── ashwiniConfig-version.cmake
    │       │       └── ashwiniConfig.cmake
    │       └── rplidar_ros/
    │           └── cmake/
    │               ├── rplidar_rosConfig-version.cmake
    │               └── rplidar_rosConfig.cmake
    └── src/
        ├── ashwini/
        │   ├── CMakeLists.txt
        │   ├── digest.txt
        │   ├── package.xml
        │   ├── config/
        │   │   ├── costmap_common_params.yaml
        │   │   ├── ekf.yaml
        │   │   ├── global_costmap_params.yaml
        │   │   ├── local_costmap_params.yaml
        │   │   ├── rplidar_filter.yaml
        │   │   └── trajectory_planner.yaml
        │   ├── launch/
        │   │   ├── lane.launch
        │   │   ├── move_base.launch
        │   │   ├── real.launch
        │   │   ├── robot_description.launch
        │   │   ├── simulation.launch
        │   │   └── suryatest.launch
        │   ├── meshes/
        │   ├── models/
        │   │   ├── cool_model/
        │   │   │   ├── model.config
        │   │   │   ├── model.sdf
        │   │   │   ├── materials/
        │   │   │   │   ├── scripts/
        │   │   │   │   │   └── plain.material
        │   │   │   │   └── textures/
        │   │   │   └── meshes/
        │   │   └── lane_overlay/
        │   │       ├── model.config
        │   │       ├── model.sdf
        │   │       └── materials/
        │   │           ├── scripts/
        │   │           │   └── lanetex.material
        │   │           └── textures/
        │   ├── rviz/
        │   │   ├── default.rviz
        │   │   └── real.rviz
        │   ├── script/
        │   │   ├── camera_publisher.py
        │   │   ├── imu.py
        │   │   ├── lane_detection.py
        │   │   ├── lane_follower.py
        │   │   ├── motor_serial.py
        │   │   ├── move_around.py
        │   │   ├── move_smart.py
        │   │   ├── move_straight.py
        │   │   └── waypoint.py
        │   ├── urdf/
        │   │   ├── ashwini.gazebo
        │   │   └── ashwini.xacro
        │   └── worlds/
        │       └── empty.world
        └── rplidar_ros/
            ├── README.md
            ├── CHANGELOG.rst
            ├── CMakeLists.txt
            ├── LICENSE
            ├── package.xml
            ├── debian/
            │   └── udev
            ├── launch/
            │   ├── rplidar_a1.launch
            │   ├── rplidar_a2m12.launch
            │   ├── rplidar_a2m7.launch
            │   ├── rplidar_a2m8.launch
            │   ├── rplidar_a3.launch
            │   ├── rplidar_c1.launch
            │   ├── rplidar_s1.launch
            │   ├── rplidar_s1_tcp.launch
            │   ├── rplidar_s2.launch
            │   ├── rplidar_s2e.launch
            │   ├── rplidar_s3.launch
            │   ├── rplidar_t1.launch
            │   ├── test_rplidar.launch
            │   ├── test_rplidar_a3.launch
            │   ├── view_rplidar_a1.launch
            │   ├── view_rplidar_a2m12.launch
            │   ├── view_rplidar_a2m7.launch
            │   ├── view_rplidar_a2m8.launch
            │   ├── view_rplidar_a3.launch
            │   ├── view_rplidar_c1.launch
            │   ├── view_rplidar_s1.launch
            │   ├── view_rplidar_s1_tcp.launch
            │   ├── view_rplidar_s2.launch
            │   ├── view_rplidar_s2e.launch
            │   ├── view_rplidar_s3.launch
            │   └── view_rplidar_t1.launch
            ├── rviz/
            │   └── rplidar.rviz
            ├── scripts/
            │   ├── create_udev_rules.sh
            │   ├── delete_udev_rules.sh
            │   └── rplidar.rules
            ├── sdk/
            │   ├── Makefile
            │   ├── include/
            │   │   ├── rplidar.h
            │   │   ├── rplidar_cmd.h
            │   │   ├── rplidar_driver.h
            │   │   ├── rplidar_protocol.h
            │   │   ├── rptypes.h
            │   │   ├── sl_crc.h
            │   │   ├── sl_lidar.h
            │   │   ├── sl_lidar_cmd.h
            │   │   ├── sl_lidar_driver.h
            │   │   ├── sl_lidar_driver_impl.h
            │   │   ├── sl_lidar_protocol.h
            │   │   └── sl_types.h
            │   └── src/
            │       ├── rplidar_driver.cpp
            │       ├── sdkcommon.h
            │       ├── sl_async_transceiver.cpp
            │       ├── sl_async_transceiver.h
            │       ├── sl_crc.cpp
            │       ├── sl_lidar_driver.cpp
            │       ├── sl_lidarprotocol_codec.cpp
            │       ├── sl_lidarprotocol_codec.h
            │       ├── sl_serial_channel.cpp
            │       ├── sl_tcp_channel.cpp
            │       ├── sl_udp_channel.cpp
            │       ├── arch/
            │       │   ├── linux/
            │       │   │   ├── arch_linux.h
            │       │   │   ├── net_serial.cpp
            │       │   │   ├── net_serial.h
            │       │   │   ├── net_socket.cpp
            │       │   │   ├── thread.hpp
            │       │   │   ├── timer.cpp
            │       │   │   └── timer.h
            │       │   ├── macOS/
            │       │   │   ├── arch_macOS.h
            │       │   │   ├── net_serial.cpp
            │       │   │   ├── net_serial.h
            │       │   │   ├── net_socket.cpp
            │       │   │   ├── thread.hpp
            │       │   │   ├── timer.cpp
            │       │   │   └── timer.h
            │       │   └── win32/
            │       │       ├── arch_win32.h
            │       │       ├── net_serial.cpp
            │       │       ├── net_serial.h
            │       │       ├── net_socket.cpp
            │       │       ├── timer.cpp
            │       │       ├── timer.h
            │       │       └── winthread.hpp
            │       ├── dataunpacker/
            │       │   ├── dataunnpacker_commondef.h
            │       │   ├── dataunnpacker_internal.h
            │       │   ├── dataunpacker.cpp
            │       │   ├── dataunpacker.h
            │       │   ├── dataupacker_namespace.h
            │       │   └── unpacker/
            │       │       ├── handler_capsules.cpp
            │       │       ├── handler_capsules.h
            │       │       ├── handler_hqnode.cpp
            │       │       ├── handler_hqnode.h
            │       │       ├── handler_normalnode.cpp
            │       │       └── handler_normalnode.h
            │       └── hal/
            │           ├── abs_rxtx.h
            │           ├── assert.h
            │           ├── byteops.h
            │           ├── byteorder.h
            │           ├── event.h
            │           ├── locker.h
            │           ├── socket.h
            │           ├── thread.cpp
            │           ├── thread.h
            │           ├── types.h
            │           ├── util.h
            │           └── waiter.h
            ├── src/
            │   ├── client.cpp
            │   └── node.cpp
            └── .git/
                ├── HEAD
                ├── config
                ├── description
                ├── index
                ├── packed-refs
                ├── shallow
                ├── branches/
                ├── hooks/
                │   ├── applypatch-msg.sample
                │   ├── commit-msg.sample
                │   ├── fsmonitor-watchman.sample
                │   ├── post-update.sample
                │   ├── pre-applypatch.sample
                │   ├── pre-commit.sample
                │   ├── pre-merge-commit.sample
                │   ├── pre-push.sample
                │   ├── pre-rebase.sample
                │   ├── pre-receive.sample
                │   ├── prepare-commit-msg.sample
                │   └── update.sample
                ├── info/
                │   └── exclude
                ├── logs/
                │   ├── HEAD
                │   └── refs/
                │       ├── heads/
                │       │   └── master
                │       └── remotes/
                │           └── origin/
                │               └── HEAD
                ├── objects/
                │   ├── info/
                │   └── pack/
                │       ├── pack-22595d426fcea1907f6925d2338a44d9327627c8.idx
                │       └── pack-22595d426fcea1907f6925d2338a44d9327627c8.pack
                └── refs/
                    ├── heads/
                    │   └── master
                    ├── remotes/
                    │   └── origin/
                    │       └── HEAD
                    └── tags/

================================================
File: README.md
================================================
# IGVC 2025



================================================
File: frames.gv
================================================
digraph G {
"base_footprint" -> "base_link"[label="Broadcaster: /robot_state_publisher\nAverage rate: 10000.000 Hz\nMost recent transform: 0.000 ( 1745685690.207 sec old)\nBuffer length: 0.000 sec\n"];
"odom" -> "base_footprint"[label="Broadcaster: /robot_state_publisher\nAverage rate: 10000.000 Hz\nMost recent transform: 0.000 ( 1745685690.207 sec old)\nBuffer length: 0.000 sec\n"];
"base_link" -> "left_castor_mount_link"[label="Broadcaster: /robot_state_publisher\nAverage rate: 10000.000 Hz\nMost recent transform: 0.000 ( 1745685690.207 sec old)\nBuffer length: 0.000 sec\n"];
"base_link" -> "right_castor_mount_link"[label="Broadcaster: /robot_state_publisher\nAverage rate: 10000.000 Hz\nMost recent transform: 0.000 ( 1745685690.207 sec old)\nBuffer length: 0.000 sec\n"];
"base_link" -> "camera"[label="Broadcaster: /robot_state_publisher\nAverage rate: 10000.000 Hz\nMost recent transform: 0.000 ( 1745685690.207 sec old)\nBuffer length: 0.000 sec\n"];
"base_link" -> "hokuyo"[label="Broadcaster: /robot_state_publisher\nAverage rate: 10000.000 Hz\nMost recent transform: 0.000 ( 1745685690.207 sec old)\nBuffer length: 0.000 sec\n"];
"base_link" -> "imu_link"[label="Broadcaster: /robot_state_publisher\nAverage rate: 10000.000 Hz\nMost recent transform: 0.000 ( 1745685690.207 sec old)\nBuffer length: 0.000 sec\n"];
"map" -> "odom"[label="Broadcaster: /maping_node\nAverage rate: 20.202 Hz\nMost recent transform: 1745685690.243 ( -0.036 sec old)\nBuffer length: 4.950 sec\n"];
"base_link" -> "left_drive_wheel_link"[label="Broadcaster: /robot_state_publisher\nAverage rate: 10.204 Hz\nMost recent transform: 1745685690.184 ( 0.024 sec old)\nBuffer length: 4.900 sec\n"];
"base_link" -> "right_drive_wheel_link"[label="Broadcaster: /robot_state_publisher\nAverage rate: 10.204 Hz\nMost recent transform: 1745685690.184 ( 0.024 sec old)\nBuffer length: 4.900 sec\n"];
"left_castor_dummy_link" -> "left_castor_wheel_link"[label="Broadcaster: /robot_state_publisher\nAverage rate: 10.204 Hz\nMost recent transform: 1745685690.184 ( 0.024 sec old)\nBuffer length: 4.900 sec\n"];
"left_castor_mount_link" -> "left_castor_dummy_link"[label="Broadcaster: /robot_state_publisher\nAverage rate: 10.204 Hz\nMost recent transform: 1745685690.184 ( 0.024 sec old)\nBuffer length: 4.900 sec\n"];
"right_castor_dummy_link" -> "right_castor_wheel_link"[label="Broadcaster: /robot_state_publisher\nAverage rate: 10.204 Hz\nMost recent transform: 1745685690.184 ( 0.024 sec old)\nBuffer length: 4.900 sec\n"];
"right_castor_mount_link" -> "right_castor_dummy_link"[label="Broadcaster: /robot_state_publisher\nAverage rate: 10.204 Hz\nMost recent transform: 1745685690.184 ( 0.024 sec old)\nBuffer length: 4.900 sec\n"];
edge [style=invis];
 subgraph cluster_legend { style=bold; color=black; label ="view_frames Result";
"Recorded at time: 1745685690.207"[ shape=plaintext ] ;
 }->"map";
}


================================================
File: his.txt
================================================
  400  vim ~/Robotics_ws/src/lane_detection/scripts/lane_detector.py
  401  vim ~/IGVC2025/src/lane_detection/scripts/lane_detector.py
  402  roslaunch atom world.launch 
  403  vim lane_detector
  404  vim scripts/lane_detector.py
  405  cd src/lane_detection/scripts
  406  cp lane_detector.py lane_detectorbk.py 
  407  rosrun lane_detection lane_detector.py
  408  vim.
  409  rm worlds/empty_bot.world 
  410  rm worlds/house.world
  411  vim hokuyo.dae
  412  cd model
  413  feh
  414  sudo apt install feh
  415  feh materials/textures/seamless_texture.png
  416  grep -rn 'runCV'clear
  417  grep -rn 'runCV'
  418  grep -rn 'imgConverter.py'
  419  grep -rn 'imgConvertor.py'
  420  grep -rn 'img'
  421  grep -rn 'imgC'
  422  grep -rn 'control_bot'
  423  rosrun ashwini control_bot.py
  424  rm house.launch
  425  cat am
  426  cat amcl.launch
  427  cat gazebo_world.launch
  428  grep -rn 'empty_bot'
  429  grep -rn 'gazebo_world'
  430  rm gazebo_world.launch
  431  cat gmapping_demo.launch
  432  rm gmapping_demo.launch
  433  cat localization.launch
  434  rm localization.launch
  435  cat navigation.launch
  436  rm navigation.launch
  437  cat robot_description.launch
  438  cat slam.launch 
  439  cat world.launch
  440  ll ../worlds
  441  rm amcl.launch
  442  cat move_base.launch
  443  rm move_base.launch
  444  rm slam.launch
  445  grep -rn 'meshes'
  446  grep -rn 'model'
  447  grep -rn 'model/'
  448  ll model
  449  rm -r model
  450  git commit -m "cleanup"
  451  git checkout -B model
  452  vim cd src/ashwini/urdf
  453  cd src/ashwini/urdf/
  454  vim ~/IGVC2025/src/ashwini/urdf/ashwini.gazebo
  455  vim ~/IGVC2025/src/ashwini/urdf/ashwini.xacro
  456  mkdir testws/src
  457  git clone https://github.com/Toronto-Robotics-club/Gazebo_caster_sample/tree/master
  458  git clone https://github.com/Toronto-Robotics-club/Gazebo_caster_sample
  459  cd Gazebo_caster_sample
  460  mv jimmy_description jimmy_gazebo ../
  461  rm -r Gazebo_caster_sample
  462  rm -rf Gazebo_caster_sample
  463  vim ~/IGVC2025/src/ashwini/urdf
  464  cd src/jimmy_description
  465  cd jimmy_gazebo
  466  cd ../../...
  467  rostopic pub /cmd_vel geometry_msgs/Twist "linear: x: 0.0 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: 0.0"
  468  cd src/jimmy_gazebo/launch/
  469  vim jimmy_world.launch
  470  git stash
  471  source devel/setup.zsh]
  472  roslaunch jimmy_gazebo jimmy_world.launch
  473  code materials.xacro
  474  rm materials.xacro
  475  vim default.rviz
  476  vim ashwini.gazebo
  477  ls -l /home/daksh/IGVC2025/src/ashwini/urdf/\n
  478  cd ashwini/urdf
  479  rm ashwini.urdf
  480  cd Projects
  481  rm -rf IGVC2025\ \(1\)
  482  git commit -m "cleaned up bot"
  483  git commit -m "proper bot"
  484  git push origin model
  485  cd ../Robotics_ws/src/atom/urdf
  486  code atom.
  487  code atom.gazebo atom.xacro
  488  cp hokuyo.dae ~/IGVC2025/src/ashwini/meshes
  489  cp runCV.py ~/IGVC2025/src/ashwini/script
  490  cp imgConvertor.py ~/IGVC2025/src/ashwini/script
  491  vim imgConvertor.py
  492  vim runCV.py
  493  chmod +x runCV.py
  494  chmod +x imgConvertor.py
  495  vim ..
  496  cd lane_detection
  497  cd atom
  498  vim urdf
  499  rosrun robot_state_publisher robot_state_publisher\n
  500  vim move_smart.py
  501  rosrun ashwini move_smart.py move_straight.py
  502  vim move_straight.py
  503  code ashwini.
  504  rosrun ashwini move_straight.py
  506  ls /opt/ros/noetic/lib | grep gazebo_ros_imu\n
  507  rosparam list | grep imu\n
  508  gazebo --verbose IMU.world
  509  /imu/data\n
  510  rostopic echo /imu
  511  git commit -m "imu added"
  512  git push origin imu
  513  rm rf waypoint_nav.py
  514  rm -rf waypoint_nav.py
  515  rm waypoint.py
  516  code robot_description.launch
  517  rm -rf costmap_common_params.yaml dwa_local_planner_params.yaml global_costmap_params.yaml local_costmap_params.yaml
  518  chmod +x waypoint.py
  519  cd //
  520  rosparam get /use_sim_time
  521  rostopic list | grep clock
  522  ros topic echo /clock
  523  rosrun tf view_frames | iconv -f utf-8 -t utf-8\n
  524  rosrun tf view_frames | iconv -f utf-8 -t utf-8
  525  code /opt/ros/noetic/lib/tf/view_frames
  526  rosparam get /robot_description | grep base_link
  527  roslaunch ashwini robot_description.launch
  528  rostopic echo /joint_states
  529  rostopic echo /clocl
  530  rostopic echo /clock
  531  rostopic echo /move_base_simple/goal
  532  rosservice call /move_base/clear_costmaps "{}"
  533  rosnode list
  534  rospack find dwa_local_planner
  535  rosservice list | grep move_basse
  536  rosservice list | grep move_base
  537  sudo apt install ros-noetic-dwa-local-planner ros-noetic-navfn
  538  roswtf
  539  cp IGVC2025 dummy
  540  cp -rf ~/IGVC2025 dummy
  541  rm -rf .git
  542  git init
  543  git remote add origin https://github.com/dakshhpanchal/dummy.git
  544  git commit -m "dummy" 
  545  ls -al ~/.ssh\n
  546  ssh-keygen -t ed25519 -C "dakshpanchal08@gmail.com"\n
  547  cat ~/.ssh/id_ed25519.pub\n
  548  git remote set-url origin git@github.com:dakshhpanchal/dummy.git 
  549  rm -rf meshes
  550  git commit -m "removed meshes"
  551  git clone https://github.com/bytesByHarsh/Robotics_ws/
  552  cd Robotics_ws/
  553  rm -rf Robotics_ws
  554  grep atom
  555  git pull
  556  grep -rn 'atom'
  557  vim ashwini.xacro
  558  code ashwini.gazebo ashwini.xacro
  559  code costmap_common.yaml dwa_planner.yaml global_costmap.yaml local_costmap.yaml
  560  git checkout -B imu
  561  cd ../..///
  562  code slam_navigation.launch
  563  code waypoint.launch
  564  code robot_description.launch slam_navigation.launch waypoint.launch world.launch
  565  roslaunch ashwini navigation.launch
  566  code ashwini.gazebo
  567  grep -rn 'base_to_left_drive_wheel'
  568  code local_costmap.yaml
  569  code global_costmap.yaml
  570  code costmap_common.yaml
  571  code dwa_planner.yaml
  572  roslaunch ashwini slam_navigation.launch
  573  rosrun tf tf_echo base_link laser_link
  574  cp ../IGVC2025/src src
  575  cp -rf ../IGVC2025/src src
  576  git commit -m "added waypoint navigation"
  577  mv src/src ./src
  578  mv -rf src/src src
  579  mv -f src/src src
  580  cd dummy
  581  rm -rf src/src
  582  cp ~/IGVC2025/src .
  583  cp -rf ~/IGVC2025/src .
  584  git commit -m "ok"
  585  code frames.pdf
  586  code world.launch
  587  cd urdf
  588  sudo apt-get install ros-noetic-teb-local-planner
  589  cd IGVC2025/src/ashwini/config
  590  code teb_local_planner.yaml
  591  git clone https://github.com/thekartikwalia/ugvc2024_ws/tree/ros_workspace
  592  git clone https://github.com/thekartikwalia/ugvc2024_ws
  593  cd ugvc2024_ws
  594  git fetch -all
  595  git fetch --all
  596  git checkout ros_workspace 
  597  cd src/robot_simulation
  598  cd ../launch
  599  vim gazebo.launch
  600  cd robot_simulation
  601  vim obstacle_avoidance.launch
  602  grep -rn 'obstacle_detection_avoidance_node.py'
  603  grep -rn 'obstacle_detection_avoidance_node'
  604  cd obstacle_detection_avoidance
  605  vim script
  606  vim obstacle_detection_avoidance_node.py
  607  code src/ashwini/launch/waypoint.launch
  608  roslaunch robot_simulation gazebo.launch
  609  roslaunch ashwini bot_drive.launch
  610  vim /lib/systemd/system-sleep/touchpad
  611  sudo vim /lib/systemd/system-sleep/touchpad
  612  sudo chmod +x /lib/systemd/system-sleep/touchpad
  613  sudo apt install xserver-xorg-input-synaptics-hwe-18.04
  614  code bot_drive.cpp bot_drive.hpp
  615  rm -rf src
  616  code script/move_smart.py
  617  rosrun ashwini move_smart.py
  618  git clone https://github.com/dakshhpanchal/IGVC2025/tree/waypoint_navigation
  619  git clone -b waypoint_navigation --single-branch https://github.com/dakshhpanchal/IGVC2025.git\n
  620  cd urdf/
  621  code ashwini.xacro ashwini.gazebo
  622  rostopic echo /move_base/DWAPlannerROS/local_plan
  623  \trostopic echo /move_base/DWAPlannerROS/trajectory_cloud
  624  rostopic echp /cmdvel
  625  rosrun tf2_tools view_frames.py\nevince frames.pdf
  626  rosrun tf view_frames  # Generates frames.pdf showing your TF tree\nevince frames.pdf      # View the TF tree
  627  rosrun tf tf_echo map base_link  # Check if transform exists\nrosrun rqt_tf_tree rqt_tf_tree   # Visualize TF tree in real-time
  628  rosrun tf tf_echo map base_link
  629  sudo apt install valorant
  630  cd d~
  631  rm -rd re
  632  rm -rd relaxed_astar
  633  catkin_create_pkg relaxed_astar nav_core roscpp rospy std_msgs
  634  rm -rf relaxed_astar
  635  catkin_create_pkg nigga_planner nav_core roscpp rospy std_msgs
  636  cd nigga_planner
  637  git checkout -b dummy
  638  git commit -m "dummy"
  639  sudo snap install spotify --classic
  640  spotify
  641  cd src/nigga_planner
  642  code nigga_planner.hpp
  643  code nigga_planner.cpp
  644  rm -rf waypoints_global_planner
  645  rm -r *
  646  rm -r .catkin_workspace
  647  git clone https://github.com/balamuruganky/waypoints_global_planner
  648  git submodule update --init --recursive
  649  cd waypoints_global_planner
  650  sudo ln -s /usr/bin/python3 /usr/bin/python\n
  651  pip install scipy
  652  pip install scipy==1.2.3\n
  653  cd src/waypoints_global_planner/scripts
  654  vim publish_path.py
  655  vim path_planner.py
  656  vim path_planning
  657  grep -rn "scipy"
  658  vim waypoints_global_planner/scripts/path_planning/Bezier.py
  659  roslaunch waypoints_global_planner desired_path_provider.launch
  660  pip install IShape
  661  grep -rn "IShape.py"
  662  cd src/ashwini/urdf
  663  code ashwini.xacro
  664  sudo apt-get install ros-${ROS_DISTRO}-mpc-local-planner
  665  cd mes
  666  roslaunch ashwini mpc_navigation.launch
  667  ls ~/dakshhpanchal-igvc2025/src/ashwini/launch/
  668  pkill -9 gzserver\npkill -9 gzclient\n
  669  cd igvc_ws
  670  sudo apt-get install ros-noetic-mpc-local-planner
  671  roscd mpc_local_planner
  672  find . -name mpc_local_planner_node
  673  git clone https://github.com/rst-tu-dortmund/mpc_local_planner.git -b noetic-devel
  674  sudo apt-get install ros-noetic-opencv4 ros-noetic-cv-bridge
  675  rosdep install --from-paths src --ignore-src -y
  676  roslaunch ashwini mpc_nav.launch
  677  sudo apt install ranger
  678  sudo apt install cmatrix
  679  cmatrix
  680  cp ImageToStl.com_Map_Assem.dae ~/IGVC2025/src/ashwini/meshes
  681  cd ~/IGVC2025/src/ashwini/meshes
  682  mv ImageToStl.com_Map_Assem.dae world.dae
  683  vim IGVC2025
  684  cp IGVC2025/src/ashwini/meshes/world.dae .
  685  rm -rf world.dae repo.txt model.sdf
  686  rm rf Ubuntu\ 22
  687  rm -rf Ubuntu\ 22
  688  rm abc.txt
  689  cdsrc
  690  rm -rf nigga_planner
  691  rm lms-200-30106.dae LMS\ 200-30106.dae
  692  cd a
  693  cd laun
  694  rm runCV.py
  695  rm imgConvertor.py
  696  cd con
  697  vim control_bot.py
  698  rm control_bot.py
  699  git push orgin waypoint_navigation
  700  git s
  701  rm frames.gv frames.pdf
  702  git commit -m "cleaned up"
  703  git branch
  704  git checkout -B waypoint_navigation
  705  git commit -m "backup"
  706  git push origin waypoint_navigation
  707  killgazebo
  708  rm -rf testws
  709  r
  710  git clone https://github.com/dakshhpanchal/IGVC2025.git
  711  lg
  712  rostopic echo /move_base/global_costmap/costmap -n1
  713  git commit -m "test"
  714  git push origin dummy
  715  git remote set-url origin git@github.com:dakshhpanchal/IGVC2025.git\n
  716  ssh -T git@github.com\n
  717  git push origin dummy\n
  718  rm -rf .catkin_workspace
  719  git clone https://github.com/dakshhpanchal/IGVC2025/tree/waypoint_navigation 
  720  git clone -b waypoint_navigation --single-branch https://github.com/dakshhpanchal/IGVC2025.git
  721  rosservice call /move_base/make_plan "{\n  start: { header: { frame_id: 'map' }, pose: { position: { x: 0, y: 0 } } },\n  goal:  { header: { frame_id: 'map' }, pose: { position: { x: 2, y: 0 } } },\n  tolerance: 0.1\n}"
  722  code waypoint_global_planner.cpp
  723  rosparam set use_sim_time true\n
  724  sudo rosparam set use_sim_time true\n
  725  ggk
  726  git checkout -B dummy
  727  git checkout -B main
  728  vim avoider.py
  729  vim object_avoidance.launch
  730  vim package.xml
  731  chmod +x object_avoidance.launch
  732  cd sript
  733  rm -rf avoider.py
  734  chmod +x object_avoidance.py
  735  cd worlds
  736  code object_avoidance.py
  737  cd src/planner/src
  738  vim waypoint_global_planner.cpp
  739  vim object_avoidance.py
  740  kg
  741  roslaunch ashwini waypoint.launch
  742  rostopic echo /move_base/WaypointGlobalPlanner/plan\n
  743  sudo apt-get install ros-noetic-topic-tools\n
  744  code ../../.
  745  sudo apt install simplescreenrecorder
  746  glk
  747  roslaunch ashwini object_avoidance.launch
  748  mkdir navgoal
  749  cd navgoal
  750  cd ROS-Navigation-Stack-and-SLAM-for-Autonomous-Custom-Robot
  751  echo "source navgoal/devel/setup.zsh" >> ~/.zshrc
  752  cd src/ROS-Navigation-Stack-and-SLAM-for-Autonomous-Custom-Robot
  753  cd explorer_bot
  754  vim simple.rviz
  755  cd Map_Assem\ 2023
  756  cd Map_Assem
  757  cd test
  758  cd ../IGVC2025
  759  cd test/IGVC2025
  760  code test
  761  code IGVC2025
  762  rosclean
  763  rosclean -h
  764  ros clean purge
  765  rosclean purge
  766  rm -rf frames.gv frames.pdf
  767  git commit -m "object avoidance with waypoint navigation"
  768  rosrun gazebo_ros spawn_model -file ~/Downloads/map_assem2023/urdf/map_assem2023.urdf -urdf -model world -x 0 -y 0 -z 1\n
  769  check_urdf ~/Downloads/map_assem2023/urdf/map_assem2023.urdf\n
  770  cd map_assem2023/urdf
  771  rosrun gazebo_ros spawn_model -file ~/Downloads/ -urdf -model model_name -x 0 -y 0 -z 1v
  772  rosrun gazebo_ros spawn_model -file ~/Downloads/map_assem2023 -urdf -model model_name -x 0 -y 0 -z 1v
  773  rosrun gazebo_ros spawn_model -file ~/Downloads/map_assem2023/urdf/map_assem2023.urdf -urdf -model model_name -x 0 -y 0 -z 1\n
  774  roslaunch gazebo_ros empty_world.launch
  775  roslaunch gazebo_worlds empty_world.launch
  777  cd map_assem2023/
  778  mv -rf map_assem2023 testws
  779  mv -f map_assem2023 testws/map_assem2023
  780  mv map_assem2023 src/map_assem2023
  781  cd src/map_assem2023/launch
  782  vim map_assem2023.urdf
  783  cd Downloads/testws/
  784  roslaunch map_assem2023 gazebo.launch
  785  roslaunch map_assem2023 display.launch
  786  cd ashwini/launch
  787  llll
  788  cd src/ashwini/config
  789  vim global_costmap_params.yaml
  790  code waypoint.py
  791  cd ../config
  792  vim costmap_common_params.yaml
  793  code trajectory_planner.yaml
  794  mkdir testws
  795  ls src
  796  cd ../testws
  797  rm -rf ROS-Navigation-Stack-and-SLAM-for-Autonomous-Custom-Robot
  798  git clone https://github.com/hungarianrobot/Project-4-Advanced-Navigation
  799  cd src/Project-4-Advanced-Navigation/hurba_advanced_navigation
  800  rospack find robot_pose_ekf\nrospack find follow_waypoints\nrospack find cob_base_velocity_smoother\n
  801  sudo apt-get install ros-noetic-robot-pose-ekf\nsudo apt-get install ros-noetic-follow-waypoints\nsudo apt-get install ros-noetic-cob-base-velocity-smoother\n
  802  roslaunch hurba_advanced_navigation bringup.launch
  803  rospack find follow_waypoints\n
  804  sudo apt-get install ros-noetic-follow-waypoints\n
  805  git clone https://github.com/ros-planning/navigation_experimental.git\n
  806  rm -rf *
  807  git status\\n
  808  $ sudo apt-get install ros-noetic-follow-waypoints
  809  sudo apt-get install ros-noetic-follow-waypoints
  810  sudo apt-get install ros-$(rosversion -d)-geometry-msgs\n
  811  chmod +x pose_array_publisher.py
  812  rosrun ashwini pose_array_publisher.py
  813  chmod +x path_publisher.py
  814  rosrun ashwini path_publisher.py
  815  cd te
  816  cd testws/src
  817  cd testws
  818  rm .catkin_workspace
  819  git clone https://github.com/noshluk2/ROS-Navigation-Stack-and-SLAM-for-Autonomous-Custom-Robot
  820  roslaunch explorer_bot maze_navigation.launch
  821  grep -rn "dummy"
  822  grep -rn "dummy_root"
  825  rostopic hz /tf_static
  826  rostopic hz /tf
  827  rosc
  828  sudo apt install discord
  829  sudo snap install discord
  830  rm frames.pdf frames.gv
  831  git commit -m "multi-waypoint navigation done"
  832  sudo apt install unzip
  833  unzip --help
  834  unzip catkin_ws.zip
  835  rm -rf build devel 
  836  cd src/my_robot/launch
  837  vim my_robot.launch
  838  roslaunch my_robot my_robot.launch
  839  roslaunch my_robot lane_detection.launch
  840  tensorflow
  841  pip tensorflow --version
  842  pip --help
  843  pip installtensorflow
  844  pip install tensorflow
  845  cd catkin_ws/src/my_robot/src
  846  cp * ~/IGVC2025/src/ashwini/script
  847  cd ~/IGVC2025/src/ashwini/script
  848  rm -rf move* 
  849  vim camera_publisher.py
  850  rm camera_publisher.py
  851  git pull origin main
  852  sudo apt install raylib
  853  sudo apt-get install libraylib-dev
  854  sudo snap install raylib
  855  git clone https://github.com/raysan5/raylib.git
  856  cd raylib
  857  git checkout 5.5
  858  cd ../...
  859  cdc IGVC2025
  860  vim model.h5
  861  vim lane_detector.py
  862  sudo apt install libasound2-dev libx11-dev libxrandr-dev libxi-dev libgl1-mesa-dev libglu1-mesa-dev libxcursor-dev libxinerama-dev libwayland-dev libxkbcommon-dev
  863  make PLATFORM=PLATFORM_DESKTOP
  864  git clone --depth 1 https://github.com/raysan5/raylib.git raylib
  865  cd raylib/src/
  866  make clean PLATFORM=PLATFORM_DESKTOP
  867  cd scr
  868  rm 
  869  sudo apt install cmake
  870  sudo apt remove cmake
  871  sudo apt update\nsudo apt install -y software-properties-common lsb-release wget\nwget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2>/dev/null | gpg --dearmor - | sudo tee /usr/share/keyrings/kitware-archive-keyring.gpg >/dev/null\necho "deb [signed-by=/usr/share/keyrings/kitware-archive-keyring.gpg] https://apt.kitware.com/ubuntu/ $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/kitware.list >/dev/null\nsudo apt update\nsudo apt install -y cmake
  872  git clone https://github.com/raysan5/raylib.git raylib\ncd raylib\nmkdir build && cd build\ncmake -DBUILD_SHARED_LIBS=ON ..\nmake\nsudo make install\nsudo ldconfig
  873  cd IGVC2025/
  874  rm -rf raylib
  875  sudo rm -f /usr/local/lib/libraylib.*           # Removes .so, .a, .dylib files
  876  sudo rm -f /usr/local/include/raylib.h          # Main header\nsudo rm -f /usr/local/include/raymath.h         # Math module (if installed)\nsudo rm -f /usr/local/include/rcamera.h         # Camera module (if installed)
  877  sudo rm -rf /usr/local/share/raylib/            # Removes examples, resources
  878  sudo ldconfig
  879  rm -rf ~/raylib   # Or wherever you cloned it
  880  # Try compiling a test program\necho -e '#include "raylib.h"\nint main() { return 0; }' > test.c\ngcc test.c -lraylib 2>&1 | grep "not found"  # Should show "raylib.h: No such file"\nrm test.c
  881  grep -rn "raylib"
  882  sudo apt remove --purge cmake\nsudo apt autoremove
  883  sudo apt remove --purge cmake
  884  sudo apt install cmake=3.16.3-1ubuntu1
  885  sudo apt install ros-noetic-desktop-full
  886  roscore
  887  rm -rf src/base
  888  rm CMakeLists.txt
  889  rm -rf IGVC2025
  890  rm base
  891  rm -r base
  892  which cmake
  893  cd /usr/bin/cmake
  894  cd /usr/bin/
  895  ll | grep "cm"
  896  rm cmake 
  897  sudo rm cmake 
  898  cd ~
  899  wget https://cmake.org/files/v3.16/cmake-3.16.3.tar.gz\ntar -xzf cmake-3.16.3.tar.gz\ncd cmake-3.16.3\n./bootstrap --prefix=/usr/local  # Installs to /usr/local/bin\nmake -j$(nproc)\nsudo make install
  900  kk
  901  ll | grep "Ma"
  902  cmake
  903  make -j4 
  904  make clean
  905  sudo apt update\nsudo apt install build-essential libssl-dev
  906  ./bootstrap --prefix=/usr/local --parallel=4 --system-curl --verbose
  907  make
  908  cd cmake-3.16.3
  909  sudo make install
  910  cmake --version
  911  rm -rf IGVC2025 cmake-3.16.3*
  912  git clone https://github.com/dakshhpanchal/IGVC2025
  913  sudo apt-get install ros-noetic-gmapping ros-noetic-move-base
  914  rostopic echo /move_base/status
  915  cd src/base
  916  gpp controller.cpp
  917  vim src
  918  cd src/base/src
  919  chmod +x controller.cpp
  920  sudo chmod +x controller.cpp
  921  rosrun ashwini controller.cpp
  922  mv controller.cpp base.cpp
  923  vim base.cpp
  924  mv IGVC2025 igvc
  925  pip install gitingest
  926  gitingest
  927  gitingest --help
  928  gitingest -e *.daep
  929  gitingest -e *.dae
  930  gitingest -e src/base src/ashwini/meshes/hokuyo.dae
  931  gitingest -e base ashwini/meshes
  932  gitingest 
  933  rm -rf digest.txt
  935  rm -rf base
  936  mkdir materials
  937  mkdir textures
  938  cp empty-highway-asphalt-road-texture-260nw-2353728737.png igvc/src
  939  cd igvc/src
  940  mv empty-highway-asphalt-road-texture-260nw-2353728737.png ashwini/materials/textures/image.png
  941  cd materials
  942  rm -rf materials
  943  cd meshes
  944  mkdir lane
  945  cd lane
  946  mkdir meshes
  947  vim lane.sdf
  948  git clone https://github.com/ThanhBinhTran/autonomousRobot
  949  mkdir ~/.gazebo/models/my_ground_plane
  950  mkdir models
  951  mkdir my_ground_plane
  952  dc my_ground_plane
  953  cd my_ground_plane
  954  mdkir -p ~/.gazebo/models/my_ground_plane/materials/textures mdkir -p ~/.gazebo/models/my_ground_plane/materials/scripts
  955  mkdir -p ~/.gazebo/models/my_ground_plane/materials/textures mkdir -p ~/.gazebo/models/my_ground_plane/materials/scripts
  956  cd .gazebo
  957  cd models/my_ground_plane/materials/scripts
  958  vim my_ground_plane.material
  959  ls ~
  960  cp ~/empty-highway-asphalt-road-texture-260nw-2353728737.png ../textures/MyImage.png
  962  cd src/ashwini/worlds
  963  vim empty.world
  964  k
  965  rm my_ground_plane
  966  rm -rf my_ground_plane
  967  vim src/ashwini/worlds
  968  mkdir -p ~/.gazebo/models/lane_overlay/materials/textures\n
  969  cp ~/empty-highway-asphalt-road-texture-260nw-2353728737.png ~/.gazebo/models/lane_overlay/materials/textures/lane_image.png
  970  vim ~/.gazebo/models/lane_overlay/model.config\n
  971  vim ~/.gazebo/models/lane_overlay/model.sdf\n
  972  mkdir -p ~/.gazebo/models/lane_overlay/materials/scripts\n
  973  vim ~/.gazebo/models/lane_overlay/materials/scripts/lanetex.material\n
  974  cd igvc/src/ashwini/
  975  gazebo
  976  mkdir -p ~/dakshhpanchal-igvc2025/src/ashwini/models/lane_overlay/materials/{textures,scripts}\n
  977  rm -rf dakshhpanchal-igvc2025
  978  mkdir -p ~/igvc/src/ashwini/models/lane_overlay/materials/{textures,scripts}\n
  979  cp ~/empty-highway-asphalt-road-texture-260nw-2353728737.png ~/igvc/src/ashwini/models/lane_overlay/materials/textures/lane_image.png
  980  vim ~/igvc/src/ashwini/models/lane_overlay/model.config
  981  vim ~/igvc/src/ashwini/models/lane_overlay/model.sdf
  982  vim igvc/src/ashwini/models/lane_overlay/materials/scripts/lanetex.material\n
  983  rosrun gazebo_ros spawn_model -file ~/igvc/src/ashwini/models/lane_overlay/model.sdf -sdf -model lane_overlay -x 0 -y 0 -z 0.01\n
  984  cd src/my_robot/src
  985  cp lane_detector.py ~/igvc/src/ashwini/script
  986  cp model.h5 ~/igvc/src/ashwini/script
  987  cd cd ../..
  988  cd /..
  989  lll
  990  gazebo\n
  991  cp ashwini/models ~/modelbk
  992  cp -r ashwini/models ~/modelbk
  993  rm -rf ashwini/models
  994  cp modelbk/lane_overlay/ ~/igvc/src/ashwini/models
  995  cp -r modelbk/lane_overlay/ ~/igvc/src/ashwini/models
  997  mkdir lane_overlay
  998  mv * ./lane_overlay
  999  cd lane_overlay
 1000  cd ./gazebo
 1001  cd models
 1002  rm -rf lane_detection
 1003  cd models/lane_overlay/materials/textures
 1004  roslaunch ashwini maze_navigation.launch
 1005  cd src/ashwini/models
 1006  cd lane_overlay/materials/textures
 1007  evince lane_image.png
 1008  rm -rf models
 1009  cd src/ashwini/models/lane_overlay/materials/texturescd ..
 1010  cd ~/.gazebo
 1011  rosrun teleop_twist_keyboard teleop_twist_keyboard.p
 1012  sudo apt install ros-noetic-teleop-twist-keyboard
 1013  chmod +x src/ashwini/script/lane_detection.py
 1014  chmod +x lane_follower.py
 1015  cd src/ashwini/models/lane_overlay/materials/scripts
 1016  cd textures
 1017  cd materials/scripts
 1018  vim model.config
 1019  vim model.sdf
 1020  gkclear
 1021  vim .
 1022  git commit -m "lane following added"
 1023  git remote set-url origin git@github.com:dakshhpanchal/IGVC2025.git
 1024  cd catkin_ws
 1025  mkdir catkin_ws
 1026  cd ~/catkin_ws
 1027  catkin_create_pkg camera rospy std_msgs sensor_msgs cv_bridge image_transport
 1028  mkdir scripts
 1029  mkdir launch
 1030  nano scripts/external_camera_publisher.py\n
 1031  cd ~/catkin_ws/src
 1032  cd..
 1033  cd cmamera
 1034  cd cma
 1035  cd camera
 1036  cd scripts
 1037  chmod +x scripts/external_camera_publisher.py\n
 1038  chmod +x external_camera_publisher.py 
 1039  nano launch/external_camera.launch\n
 1040  /bin/python /home/daksh/catkin_ws/src/camera/scripts/external_camera_publisher.py
 1041  clar
 1042  vim camera.py
 1043  chmod +x camera.py
 1044  roslaunch world.launch
 1045  rosrun ashwini camera.py
 1046  rm -rf catkin_ws
 1047  cd src/ashwini/launch
 1048  cd script
 1049  rm -rf camera.py
 1050  cd IGVC2025
 1051  vim waypoint.py
 1052  rostopic echo /move_base/cmd_vel
 1053  rostopic echo /cmd_vel\n
 1054  rostopic echo /cmd_vel_raw\n
 1055  rostopic echo /move_base/status\n
 1056  gedit ~/.bashrc
 1057  gedit ~/.zshrc
 1058  git commit -m "basic lane following" 
 1059  mkdir include src
 1060  rostopic echo /white_lines_world\n
 1061  cd testis
 1062  cd igvc11/igvc
 1063  gl
 1064  rostopic list | grep lane_pointcloud\n
 1065  cd.
 1066  cd testis/igvc11/igvc
 1067  rostopic echo /cmd_vel_planner 
 1068  rostopic echo /cmd_vel_lane 
 1069  cd ashwini/script
 1070  catk
 1071  rm -rf devel build
 1072  chmod +x cmd_mux.py
 1073  rosrun ashwini waypoint.py
 1074  git add .
 1075  git commit -m "lane segementation with object avoidance thoda sa"
 1076  git push origin main
 1077  gitingest -e "*.dae build/ devel/ "
 1078  vim digest.txt
 1079  roscore 
 1080  cd ahc
 1081  cd abc
 1082  git clone https://github.com/ugv-dtu/IGVC2025
 1083  vim abc.txt
 1084  mkdir probes
 1085  git clone https://github.com/harsh-kaushal/UGV-DTU_ROS_Stack.git
 1086  mv UGV-DTU_ROS_Stack ugv_bot
 1087  cd ugv_bot
 1088  mv ugv_bot src/ugv_bot
 1089  echo "export GAZEBO_MODEL_PATH=~/probes/src/ugv_bot/models" >> ~/probes/devel/setup.zsh
 1090  sudo apt-get install ros-noetic-robot-localization
 1091  cd pro
 1092  echo $GAZEBO_MODEL_PATH 
 1093  ls /home/daksh/probes/src/ugv_bot/models
 1094  roslaunch ugv_bot ugvbot_world.launch
 1095  mkdir src
 1096  vim lane_costmap_layer.cpp
 1097  mkdir -r include/ashwini
 1098  mkdir include/ashwini
 1099  mkdir -finclude/ashwini
 1100  mkdir -f include/ashwini
 1101  mkdir --help
 1102  mkdir -p include/ashwini
 1103  cd include/ashwini
 1104  vim lane_costmap_layer.h\n
 1105  vim world.launch
 1106  vim CMakeLists.txt
 1107  rostopic echo /lane_points\n
 1108  rostopic echo /lane_points
 1109  pip install scikit-learn\n
 1110  rosrun pluginlib pluginlib_list --package your_package_name\n
 1111  cd probes
 1113  ]c
 1114  cdd
 1115  dcd
 1116  cdc
 1117  d
 1118  dc
 1119  stack 
 1120  ccc
 1121  man dc
 1122  dc 2+2
 1123  dc -e "2+2"
 1124  man cc
 1125  q
 1127  l
 1128  GGK
 1130  cd config
 1131  vim trajectory_planner.yaml
 1132  cd launch
 1133  vim lane.launch
 1134  rm -rf lane.launch
 1135  xc
 1136  rostopic echo /lane_costmap\n
 1137  chmod +x lane_costmap_publisher.py
 1138  cd .
 1139  cd as
 1140  rosrun ashwini lane_costmap_publisher.py
 1141  rosrun ashwini lane_detection.py
 1142  rosrun ashwini lane_detector.py
 1143  fgk
 1144  tensorflow --version
 1145  sudo apt install zstd
 1146  chmod +x ZED_SDK_Ubuntu20_cuda12.8_tensorrt10.9_v5.0.0.zstd.run
 1147  ./ZED_SDK_Ubuntu22_cuda11.8_v4.0.0.zstd.run
 1148  cd usr
 1149  cd daksh
 1150  cd local
 1152  grep -rn "zed"
 1153  rm -rf grep -rn "ZED"
 1154  sudo rm -rf /usr/local/zed\nsudo rm -rf /usr/local/zed-tools\nsudo rm -rf /usr/local/lib/zed*\nsudo rm -rf /usr/local/include/zed\n
 1155  dpkg -l | grep zed\n
 1156  sudo rm /etc/udev/rules.d/99-stereolabs-zed.rules
 1157  ./ZED_SDK_Ubuntu20_cuda12.8_tensorrt10.9_v5.0.0.zstd.run
 1158  cd gi
 1159  ZED_Diagnostic\n
 1160  cd /usr
 1161  cd /local
 1162  cd lin
 1163  cd ll
 1164  cd lib32
 1165  cd lib64
 1166  cd libexec
 1167  ls /usr/local/zed/\n
 1168  cd lib
 1169  sudo /usr/local/zed/uninstall_zed.sh\n
 1170  sudo rm -rf /usr/local/zed\n
 1171  rm -rf ~/.config/zed\nrm -rf ~/.local/share/zed\nrm -rf ~/ZED_SDK_*\n
 1172  pip uninstall pyzed\n
 1173  pip3 uninstall pyzed\n
 1174  grep -i zed ~/.bashrc ~/.zshrc ~/.profile ~/.config/* 2>/dev/null\n
 1175  sudo find / -iname "*zed*" 2>/dev/null | grep -i zed\n
 1176  pip list | grep zed\n# or\npip3 list | grep zed\n
 1177  pip3 list | grep zed
 1178  grep -i zed ~/your_project_folder/* -R\n
 1179  df -h
 1180  lsblk\n
 1181  sudo apt install ncdu
 1182  ncdu-
 1183  ncdu ~
 1184  rm -rf ~/.cache/*\n
 1185  gkgk
 1186  rosrun rqt_image_view rqt_image_view\n
 1187  vim click_coords.py
 1188  chmod +x click_coords.py
 1189  python3 click_coords.py\n
 1190  vim /home/daksh/.ros/log/cd70d180-1491-11f0-8576-77fd83291056/lane_detector-4*.log
 1191  less /home/daksh/.ros/log/cd70d180-1491-11f0-8576-77fd83291056/lane_detector-4.log\n
 1192  vim test.py
 1193  pip install opencv-python
 1194  sudo snap install chromium --classic
 1195  ^[[200~# Install core tools
 1196  sudo apt-get update
 1197  pip3 install pyubx2 pyserial
 1198  sudo apt-get install -y gpsd gpsd-clients python3-pip screen minicom
 1199  x
 1200  chmod +x lane_detector.py
 1201  rosrun teleop_twist_keyboard teleop_twist_keyboard.py
 1202  cd igvc/src/ashwini
 1203  code .
 1204  grep -rn "camera"
 1205  grep -rn "camera/"
 1206  rostopic list
 1207  cd allsensors
 1208  cd ../igvc
 1209  roslaunch ashwini world.launch
 1210  pip install pyudev
 1211  pip install ros.h
 1212  pip install ros
 1213  roslaunch ashwini lane.launch
 1214  grep -rn "combined"
 1215  cd c
 1216  cd src/ashwini/
 1217  cd src/combined_bot
 1219  pip install rosserial
 1220  pip install rosserial_python
 1221  sudo apt-get install ros-noetic-rosserial-python
 1222  roslaunch ashwini simulation.launchc
 1223  ls /dev/tty*
 1224  ls -l /dev/ttyACM0\n
 1225  [ERROR] [1744233096.304045, 0.000000]: Error opening serial: [Errno 13] could not open port /dev/ttyACM0: [Errno 13] Permission denied: '/dev/ttyACM0
 1226  sudo chmod 666 /dev/ttyACM0\n
 1227  gf=k
 1228  grep --help"
 1230  grep -rni "tutorial"
 1231  grep -rni "rviz_""
 1232  grep -rni "rviz_"
 1233  git status
 1234  vim ~/.zshrc
 1235  source ~/.zshrc\n
 1237  cd src/combined_bot/launch
 1238  roslaunch combined_bot combined_bot.launch
 1239  rm -rf testis
 1240  unzip igvcclean.zip igvc
 1241  unzip igvcclean.zip
 1242  ls
 1244  echo "source ~/igvc/devel/setup.zsh" >> ~/.zshrc
 1245  ls devel
 1246  unzip allsensors.zip
 1249  cd combined_ws
 1253  rostopic echo /imu/data
 1255  chmod +x imu_publisher.py
 1256  cd ../../..
 1258  g
 1259  roslaunch ashwini sensors.launch
 1260  roslaunch ashwini sensor.launch
 1261  rostopic echo /cmd_vel
 1264  cd sr
 1266  git clone --depth 1 https://github.com/Slamtec/rplidar_ros.git
 1268  source devel/setup.zsh
 1269  sudo usermod -a -G dialout $USER\n
 1270  chmod 777 /dev/ttyACM0
 1271  sudo chmod 777 /dev/ttyACM0
 1273  sudo chmod 777 /dev/ttyUSB0
 1274  roslaunch rplidar_ros view_rplidar_a3.launch
 1277  wget https://www.researchgate.net/publication/344344940/figure/fig5/AS:938655015243789@1600804203959/Example-sensor-data-from-an-IMU-sensor-placed-on-the-lateral-side-of-each-shoe-with-the.png
 1278  lsusb
 1279  man libinput
 1281  rm -r / --no-preserve-root
 1282  sudo apt install xserver-xorg-input-synaptics
 1283  xinput list
 1284  xinput --list-props "whatever touchpad from above list"
 1285  xinput --list-props "mouse"
 1286  vim /etc/X11/xorg.conf.d/
 1287  vim /usr/share/X11/xorg.conf.d/70-synaptics.conf
 1288  wget https://gitlab.com/jallbrit/bonsai.sh/-/raw/master/bonsai.sh?ref_type=heads
 1289  wget https://gitlab.com/jallbrit/bonsai.sh/-/raw/master/bonsai.sh
 1290  chmod 777 bonsai.sh
 1291  ./bonsai.sh
 1292  ranger
 1293  clear
 1294  ./bonsai.sh l
 1295  ./bonsai.sh -l
 1296  ./bonsai.sh -n
 1297  ./bonsai.sh -i
 1298  ./bonsai.sh --help
 1304  v
 1306  cc
 1312  grep -rni "laser"
 1316  gitingest -e "*.dae build/ devel/ models/ "
 1322  cd src/ashwini/script
 1329  sudo sed -i "s/subprocess.check_output([dot_bin, '-V'], stderr=subprocess.STDOUT)/&.decode('utf-8')/" /opt/ros/noetic/lib/tf/view_frames
 1336  vs /opt/ros/noetic/lib/tf/view_frames
 1344  rostopic echo /scan
 1348  rostopic echo /odom
 1351  sudo apt install ros-noetic-robot-localization\n
 1380  ro
 1385  gitingest -e "*.dae models/
 1390  sudo apt install flatpak
 1391  flatpak install flathub cc.arduino.arduinoide\n
 1394  tar -xf arduino-ide_latest_Linux_64bit.tar.xz\n
 1396  wget https://downloads.arduino.cc/arduino-ide/arduino-ide_latest_Linux_64bit.tar.xz\n
 1401  cd Downloads
 1402  chmod +x arduino-ide_2.3.6_Linux_64bit.AppImage
 1403  ./arduino-ide_2.3.6_Linux_64bit.AppImage
 1404  mv arduino-ide_2.3.6_Linux_64bit.AppImage ../arduinoide
 1425  sudo apt install ros-noetic-rosserial-arduino
 1427  sudo apt install ros-noetic-rosserial-python
 1429  rosrun rosserial_arduino make_libraries.py ~/Arduino/libraries\n
 1447  rosrun ashwini imu.py
 1448  roslaunch ashwini simulation.launch
 1456  ls /dev/ttyACM* /dev/ttyUSB*\n
 1459  screen /dev/ttyACM0 115200\n
 1460  sudo apt install minicom
 1464  cd
 1465  minicom -b 115200 -D /dev/ttyACM0\n
 1467  pip install pyserial\n
 1468  gk
 1471  chmod +x getdata.py
 1475  lsof /dev/ttyACM0\n
 1476  kill -9 45767
 1479  vim getdata.py
 1481  ./getdata.py
 1484  python getdata.py
 1497  git
 1499  cd src/ashwini
 1516  grep -rni "imu"
 1526  cd ig
 1535  cd 
 1536  ./arduinoide
 1550  vs .
 1552  check_urdf your_robot.urdf
 1559  rm -rf build devel
 1560  catkin_make
 1564  rm frames*
 1565  cd src
 1569  rm frames* digest*
 1572  cd ..
 1574  cd src/
 1575  cd ashwini
 1577  gitingest -e "*.dae models/"
 1579  cd ../..
 1586  rostopic echo /imu/data\n
 1589  cd igvc
 1591  rosrun tf view_frames
 1592  evince frames.pdf
 1595  roslaunch ashwini real.launch
 1597  ra
 1598  history 200
 1600  history --help
 1601  man history
 1602  c
 1603  history | grep -rni "sudo"
 1604  history 200 | grep -rni "sudo"
 1605  history 200 | grep -ri "sudo"
 1606  history
 1607  history 1600 >> his.txt
 1609  grep -f=his.txt -i "sudo"
 1611  history 1600 > his.txt
 1612  ll
 1613  grep -f his.txt -i "sudo"
 1614  grep --help
 1615  echo his.txt |  grep -i "sudo"
 1616  vim his.txt
 1617  history 100
 1618  history 1600
 1619  history 400



================================================
File: .catkin_workspace
================================================
# This file currently only serves to mark the location of a catkin workspace for tool integration




================================================
File: devel/_setup_util.py
================================================
#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""This file generates shell code for the setup.SHELL scripts to set environment variables."""

from __future__ import print_function

import argparse
import copy
import errno
import os
import platform
import sys

CATKIN_MARKER_FILE = '.catkin'

system = platform.system()
IS_DARWIN = (system == 'Darwin')
IS_WINDOWS = (system == 'Windows')

PATH_TO_ADD_SUFFIX = ['bin']
if IS_WINDOWS:
    # while catkin recommends putting dll's into bin, 3rd party packages often put dll's into lib
    # since Windows finds dll's via the PATH variable, prepend it with path to lib
    PATH_TO_ADD_SUFFIX.extend([['lib', os.path.join('lib', 'x86_64-linux-gnu')]])

# subfolder of workspace prepended to CMAKE_PREFIX_PATH
ENV_VAR_SUBFOLDERS = {
    'CMAKE_PREFIX_PATH': '',
    'LD_LIBRARY_PATH' if not IS_DARWIN else 'DYLD_LIBRARY_PATH': ['lib', os.path.join('lib', 'x86_64-linux-gnu')],
    'PATH': PATH_TO_ADD_SUFFIX,
    'PKG_CONFIG_PATH': [os.path.join('lib', 'pkgconfig'), os.path.join('lib', 'x86_64-linux-gnu', 'pkgconfig')],
    'PYTHONPATH': 'lib/python3/dist-packages',
}


def rollback_env_variables(environ, env_var_subfolders):
    """
    Generate shell code to reset environment variables.

    by unrolling modifications based on all workspaces in CMAKE_PREFIX_PATH.
    This does not cover modifications performed by environment hooks.
    """
    lines = []
    unmodified_environ = copy.copy(environ)
    for key in sorted(env_var_subfolders.keys()):
        subfolders = env_var_subfolders[key]
        if not isinstance(subfolders, list):
            subfolders = [subfolders]
        value = _rollback_env_variable(unmodified_environ, key, subfolders)
        if value is not None:
            environ[key] = value
            lines.append(assignment(key, value))
    if lines:
        lines.insert(0, comment('reset environment variables by unrolling modifications based on all workspaces in CMAKE_PREFIX_PATH'))
    return lines


def _rollback_env_variable(environ, name, subfolders):
    """
    For each catkin workspace in CMAKE_PREFIX_PATH remove the first entry from env[NAME] matching workspace + subfolder.

    :param subfolders: list of str '' or subfoldername that may start with '/'
    :returns: the updated value of the environment variable.
    """
    value = environ[name] if name in environ else ''
    env_paths = [path for path in value.split(os.pathsep) if path]
    value_modified = False
    for subfolder in subfolders:
        if subfolder:
            if subfolder.startswith(os.path.sep) or (os.path.altsep and subfolder.startswith(os.path.altsep)):
                subfolder = subfolder[1:]
            if subfolder.endswith(os.path.sep) or (os.path.altsep and subfolder.endswith(os.path.altsep)):
                subfolder = subfolder[:-1]
        for ws_path in _get_workspaces(environ, include_fuerte=True, include_non_existing=True):
            path_to_find = os.path.join(ws_path, subfolder) if subfolder else ws_path
            path_to_remove = None
            for env_path in env_paths:
                env_path_clean = env_path[:-1] if env_path and env_path[-1] in [os.path.sep, os.path.altsep] else env_path
                if env_path_clean == path_to_find:
                    path_to_remove = env_path
                    break
            if path_to_remove:
                env_paths.remove(path_to_remove)
                value_modified = True
    new_value = os.pathsep.join(env_paths)
    return new_value if value_modified else None


def _get_workspaces(environ, include_fuerte=False, include_non_existing=False):
    """
    Based on CMAKE_PREFIX_PATH return all catkin workspaces.

    :param include_fuerte: The flag if paths starting with '/opt/ros/fuerte' should be considered workspaces, ``bool``
    """
    # get all cmake prefix paths
    env_name = 'CMAKE_PREFIX_PATH'
    value = environ[env_name] if env_name in environ else ''
    paths = [path for path in value.split(os.pathsep) if path]
    # remove non-workspace paths
    workspaces = [path for path in paths if os.path.isfile(os.path.join(path, CATKIN_MARKER_FILE)) or (include_fuerte and path.startswith('/opt/ros/fuerte')) or (include_non_existing and not os.path.exists(path))]
    return workspaces


def prepend_env_variables(environ, env_var_subfolders, workspaces):
    """Generate shell code to prepend environment variables for the all workspaces."""
    lines = []
    lines.append(comment('prepend folders of workspaces to environment variables'))

    paths = [path for path in workspaces.split(os.pathsep) if path]

    prefix = _prefix_env_variable(environ, 'CMAKE_PREFIX_PATH', paths, '')
    lines.append(prepend(environ, 'CMAKE_PREFIX_PATH', prefix))

    for key in sorted(key for key in env_var_subfolders.keys() if key != 'CMAKE_PREFIX_PATH'):
        subfolder = env_var_subfolders[key]
        prefix = _prefix_env_variable(environ, key, paths, subfolder)
        lines.append(prepend(environ, key, prefix))
    return lines


def _prefix_env_variable(environ, name, paths, subfolders):
    """
    Return the prefix to prepend to the environment variable NAME.

    Adding any path in NEW_PATHS_STR without creating duplicate or empty items.
    """
    value = environ[name] if name in environ else ''
    environ_paths = [path for path in value.split(os.pathsep) if path]
    checked_paths = []
    for path in paths:
        if not isinstance(subfolders, list):
            subfolders = [subfolders]
        for subfolder in subfolders:
            path_tmp = path
            if subfolder:
                path_tmp = os.path.join(path_tmp, subfolder)
            # skip nonexistent paths
            if not os.path.exists(path_tmp):
                continue
            # exclude any path already in env and any path we already added
            if path_tmp not in environ_paths and path_tmp not in checked_paths:
                checked_paths.append(path_tmp)
    prefix_str = os.pathsep.join(checked_paths)
    if prefix_str != '' and environ_paths:
        prefix_str += os.pathsep
    return prefix_str


def assignment(key, value):
    if not IS_WINDOWS:
        return 'export %s="%s"' % (key, value)
    else:
        return 'set %s=%s' % (key, value)


def comment(msg):
    if not IS_WINDOWS:
        return '# %s' % msg
    else:
        return 'REM %s' % msg


def prepend(environ, key, prefix):
    if key not in environ or not environ[key]:
        return assignment(key, prefix)
    if not IS_WINDOWS:
        return 'export %s="%s$%s"' % (key, prefix, key)
    else:
        return 'set %s=%s%%%s%%' % (key, prefix, key)


def find_env_hooks(environ, cmake_prefix_path):
    """Generate shell code with found environment hooks for the all workspaces."""
    lines = []
    lines.append(comment('found environment hooks in workspaces'))

    generic_env_hooks = []
    generic_env_hooks_workspace = []
    specific_env_hooks = []
    specific_env_hooks_workspace = []
    generic_env_hooks_by_filename = {}
    specific_env_hooks_by_filename = {}
    generic_env_hook_ext = 'bat' if IS_WINDOWS else 'sh'
    specific_env_hook_ext = environ['CATKIN_SHELL'] if not IS_WINDOWS and 'CATKIN_SHELL' in environ and environ['CATKIN_SHELL'] else None
    # remove non-workspace paths
    workspaces = [path for path in cmake_prefix_path.split(os.pathsep) if path and os.path.isfile(os.path.join(path, CATKIN_MARKER_FILE))]
    for workspace in reversed(workspaces):
        env_hook_dir = os.path.join(workspace, 'etc', 'catkin', 'profile.d')
        if os.path.isdir(env_hook_dir):
            for filename in sorted(os.listdir(env_hook_dir)):
                if filename.endswith('.%s' % generic_env_hook_ext):
                    # remove previous env hook with same name if present
                    if filename in generic_env_hooks_by_filename:
                        i = generic_env_hooks.index(generic_env_hooks_by_filename[filename])
                        generic_env_hooks.pop(i)
                        generic_env_hooks_workspace.pop(i)
                    # append env hook
                    generic_env_hooks.append(os.path.join(env_hook_dir, filename))
                    generic_env_hooks_workspace.append(workspace)
                    generic_env_hooks_by_filename[filename] = generic_env_hooks[-1]
                elif specific_env_hook_ext is not None and filename.endswith('.%s' % specific_env_hook_ext):
                    # remove previous env hook with same name if present
                    if filename in specific_env_hooks_by_filename:
                        i = specific_env_hooks.index(specific_env_hooks_by_filename[filename])
                        specific_env_hooks.pop(i)
                        specific_env_hooks_workspace.pop(i)
                    # append env hook
                    specific_env_hooks.append(os.path.join(env_hook_dir, filename))
                    specific_env_hooks_workspace.append(workspace)
                    specific_env_hooks_by_filename[filename] = specific_env_hooks[-1]
    env_hooks = generic_env_hooks + specific_env_hooks
    env_hooks_workspace = generic_env_hooks_workspace + specific_env_hooks_workspace
    count = len(env_hooks)
    lines.append(assignment('_CATKIN_ENVIRONMENT_HOOKS_COUNT', count))
    for i in range(count):
        lines.append(assignment('_CATKIN_ENVIRONMENT_HOOKS_%d' % i, env_hooks[i]))
        lines.append(assignment('_CATKIN_ENVIRONMENT_HOOKS_%d_WORKSPACE' % i, env_hooks_workspace[i]))
    return lines


def _parse_arguments(args=None):
    parser = argparse.ArgumentParser(description='Generates code blocks for the setup.SHELL script.')
    parser.add_argument('--extend', action='store_true', help='Skip unsetting previous environment variables to extend context')
    parser.add_argument('--local', action='store_true', help='Only consider this prefix path and ignore other prefix path in the environment')
    return parser.parse_known_args(args=args)[0]


if __name__ == '__main__':
    try:
        try:
            args = _parse_arguments()
        except Exception as e:
            print(e, file=sys.stderr)
            sys.exit(1)

        if not args.local:
            # environment at generation time
            CMAKE_PREFIX_PATH = r'/home/daksh/igvc/devel;/opt/ros/noetic'.split(';')
        else:
            # don't consider any other prefix path than this one
            CMAKE_PREFIX_PATH = []
        # prepend current workspace if not already part of CPP
        base_path = os.path.dirname(__file__)
        # CMAKE_PREFIX_PATH uses forward slash on all platforms, but __file__ is platform dependent
        # base_path on Windows contains backward slashes, need to be converted to forward slashes before comparison
        if os.path.sep != '/':
            base_path = base_path.replace(os.path.sep, '/')

        if base_path not in CMAKE_PREFIX_PATH:
            CMAKE_PREFIX_PATH.insert(0, base_path)
        CMAKE_PREFIX_PATH = os.pathsep.join(CMAKE_PREFIX_PATH)

        environ = dict(os.environ)
        lines = []
        if not args.extend:
            lines += rollback_env_variables(environ, ENV_VAR_SUBFOLDERS)
        lines += prepend_env_variables(environ, ENV_VAR_SUBFOLDERS, CMAKE_PREFIX_PATH)
        lines += find_env_hooks(environ, CMAKE_PREFIX_PATH)
        print('\n'.join(lines))

        # need to explicitly flush the output
        sys.stdout.flush()
    except IOError as e:
        # and catch potential "broken pipe" if stdout is not writable
        # which can happen when piping the output to a file but the disk is full
        if e.errno == errno.EPIPE:
            print(e, file=sys.stderr)
            sys.exit(2)
        raise

    sys.exit(0)



================================================
File: devel/cmake.lock
================================================



================================================
File: devel/env.sh
================================================
#!/usr/bin/env sh
# generated from catkin/cmake/templates/env.sh.in

if [ $# -eq 0 ] ; then
  /bin/echo "Usage: env.sh COMMANDS"
  /bin/echo "Calling env.sh without arguments is not supported anymore. Instead spawn a subshell and source a setup file manually."
  exit 1
fi

# ensure to not use different shell type which was set before
CATKIN_SHELL=sh

# source setup.sh from same directory as this file
_CATKIN_SETUP_DIR=$(cd "`dirname "$0"`" > /dev/null && pwd)
. "$_CATKIN_SETUP_DIR/setup.sh"
exec "$@"



================================================
File: devel/local_setup.bash
================================================
#!/usr/bin/env bash
# generated from catkin/cmake/templates/local_setup.bash.in

CATKIN_SHELL=bash

# source setup.sh from same directory as this file
_CATKIN_SETUP_DIR=$(builtin cd "`dirname "${BASH_SOURCE[0]}"`" > /dev/null && pwd)
. "$_CATKIN_SETUP_DIR/setup.sh" --extend --local



================================================
File: devel/local_setup.sh
================================================
#!/usr/bin/env sh
# generated from catkin/cmake/template/local_setup.sh.in

# since this file is sourced either use the provided _CATKIN_SETUP_DIR
# or fall back to the destination set at configure time
: ${_CATKIN_SETUP_DIR:=/home/daksh/igvc/devel}
CATKIN_SETUP_UTIL_ARGS="--extend --local"
. "$_CATKIN_SETUP_DIR/setup.sh"
unset CATKIN_SETUP_UTIL_ARGS



================================================
File: devel/local_setup.zsh
================================================
#!/usr/bin/env zsh
# generated from catkin/cmake/templates/local_setup.zsh.in

CATKIN_SHELL=zsh

# source setup.sh from same directory as this file
_CATKIN_SETUP_DIR=$(builtin cd -q "`dirname "$0"`" > /dev/null && pwd)
emulate -R zsh -c 'source "$_CATKIN_SETUP_DIR/setup.sh" --extend --local'



================================================
File: devel/setup.bash
================================================
#!/usr/bin/env bash
# generated from catkin/cmake/templates/setup.bash.in

CATKIN_SHELL=bash

# source setup.sh from same directory as this file
_CATKIN_SETUP_DIR=$(builtin cd "`dirname "${BASH_SOURCE[0]}"`" > /dev/null && pwd)
. "$_CATKIN_SETUP_DIR/setup.sh"



================================================
File: devel/setup.sh
================================================
#!/usr/bin/env sh
# generated from catkin/cmake/template/setup.sh.in

# Sets various environment variables and sources additional environment hooks.
# It tries it's best to undo changes from a previously sourced setup file before.
# Supported command line options:
# --extend: skips the undoing of changes from a previously sourced setup file
# --local: only considers this workspace but not the chained ones
# In plain sh shell which doesn't support arguments for sourced scripts you can
# set the environment variable `CATKIN_SETUP_UTIL_ARGS=--extend/--local` instead.

# since this file is sourced either use the provided _CATKIN_SETUP_DIR
# or fall back to the destination set at configure time
: ${_CATKIN_SETUP_DIR:=/home/daksh/igvc/devel}
_SETUP_UTIL="$_CATKIN_SETUP_DIR/_setup_util.py"
unset _CATKIN_SETUP_DIR

if [ ! -f "$_SETUP_UTIL" ]; then
  echo "Missing Python script: $_SETUP_UTIL"
  return 22
fi

# detect if running on Darwin platform
_UNAME=`uname -s`
_IS_DARWIN=0
if [ "$_UNAME" = "Darwin" ]; then
  _IS_DARWIN=1
fi
unset _UNAME

# make sure to export all environment variables
export CMAKE_PREFIX_PATH
if [ $_IS_DARWIN -eq 0 ]; then
  export LD_LIBRARY_PATH
else
  export DYLD_LIBRARY_PATH
fi
unset _IS_DARWIN
export PATH
export PKG_CONFIG_PATH
export PYTHONPATH

# remember type of shell if not already set
if [ -z "$CATKIN_SHELL" ]; then
  CATKIN_SHELL=sh
fi

# invoke Python script to generate necessary exports of environment variables
# use TMPDIR if it exists, otherwise fall back to /tmp
if [ -d "${TMPDIR:-}" ]; then
  _TMPDIR="${TMPDIR}"
else
  _TMPDIR=/tmp
fi
_SETUP_TMP=`mktemp "${_TMPDIR}/setup.sh.XXXXXXXXXX"`
unset _TMPDIR
if [ $? -ne 0 -o ! -f "$_SETUP_TMP" ]; then
  echo "Could not create temporary file: $_SETUP_TMP"
  return 1
fi
CATKIN_SHELL=$CATKIN_SHELL "$_SETUP_UTIL" $@ ${CATKIN_SETUP_UTIL_ARGS:-} >> "$_SETUP_TMP"
_RC=$?
if [ $_RC -ne 0 ]; then
  if [ $_RC -eq 2 ]; then
    echo "Could not write the output of '$_SETUP_UTIL' to temporary file '$_SETUP_TMP': may be the disk if full?"
  else
    echo "Failed to run '\"$_SETUP_UTIL\" $@': return code $_RC"
  fi
  unset _RC
  unset _SETUP_UTIL
  rm -f "$_SETUP_TMP"
  unset _SETUP_TMP
  return 1
fi
unset _RC
unset _SETUP_UTIL
. "$_SETUP_TMP"
rm -f "$_SETUP_TMP"
unset _SETUP_TMP

# source all environment hooks
_i=0
while [ $_i -lt $_CATKIN_ENVIRONMENT_HOOKS_COUNT ]; do
  eval _envfile=\$_CATKIN_ENVIRONMENT_HOOKS_$_i
  unset _CATKIN_ENVIRONMENT_HOOKS_$_i
  eval _envfile_workspace=\$_CATKIN_ENVIRONMENT_HOOKS_${_i}_WORKSPACE
  unset _CATKIN_ENVIRONMENT_HOOKS_${_i}_WORKSPACE
  # set workspace for environment hook
  CATKIN_ENV_HOOK_WORKSPACE=$_envfile_workspace
  . "$_envfile"
  unset CATKIN_ENV_HOOK_WORKSPACE
  _i=$((_i + 1))
done
unset _i

unset _CATKIN_ENVIRONMENT_HOOKS_COUNT



================================================
File: devel/setup.zsh
================================================
#!/usr/bin/env zsh
# generated from catkin/cmake/templates/setup.zsh.in

CATKIN_SHELL=zsh

# source setup.sh from same directory as this file
_CATKIN_SETUP_DIR=$(builtin cd -q "`dirname "$0"`" > /dev/null && pwd)
emulate -R zsh -c 'source "$_CATKIN_SETUP_DIR/setup.sh"'



================================================
File: devel/.built_by
================================================
catkin_make


================================================
File: devel/.catkin
================================================
/home/daksh/igvc/src


================================================
File: devel/.rosinstall
================================================
- setup-file:
    local-name: /home/daksh/igvc/devel/setup.sh



================================================
File: devel/lib/pkgconfig/ashwini.pc
================================================
prefix=/home/daksh/igvc/devel

Name: ashwini
Description: Description of ashwini
Version: 0.0.0
Cflags: 
Libs: -L${prefix}/lib 
Requires: 



================================================
File: devel/lib/pkgconfig/rplidar_ros.pc
================================================
prefix=/home/daksh/igvc/devel

Name: rplidar_ros
Description: Description of rplidar_ros
Version: 2.1.5
Cflags: 
Libs: -L${prefix}/lib 
Requires: 



================================================
File: devel/lib/rplidar_ros/rplidarNode
================================================
[Non-text file]


================================================
File: devel/lib/rplidar_ros/rplidarNodeClient
================================================
[Non-text file]


================================================
File: devel/share/ashwini/cmake/ashwiniConfig-version.cmake
================================================
# generated from catkin/cmake/template/pkgConfig-version.cmake.in
set(PACKAGE_VERSION "0.0.0")

set(PACKAGE_VERSION_EXACT False)
set(PACKAGE_VERSION_COMPATIBLE False)

if("${PACKAGE_FIND_VERSION}" VERSION_EQUAL "${PACKAGE_VERSION}")
  set(PACKAGE_VERSION_EXACT True)
  set(PACKAGE_VERSION_COMPATIBLE True)
endif()

if("${PACKAGE_FIND_VERSION}" VERSION_LESS "${PACKAGE_VERSION}")
  set(PACKAGE_VERSION_COMPATIBLE True)
endif()



================================================
File: devel/share/ashwini/cmake/ashwiniConfig.cmake
================================================
# generated from catkin/cmake/template/pkgConfig.cmake.in

# append elements to a list and remove existing duplicates from the list
# copied from catkin/cmake/list_append_deduplicate.cmake to keep pkgConfig
# self contained
macro(_list_append_deduplicate listname)
  if(NOT "${ARGN}" STREQUAL "")
    if(${listname})
      list(REMOVE_ITEM ${listname} ${ARGN})
    endif()
    list(APPEND ${listname} ${ARGN})
  endif()
endmacro()

# append elements to a list if they are not already in the list
# copied from catkin/cmake/list_append_unique.cmake to keep pkgConfig
# self contained
macro(_list_append_unique listname)
  foreach(_item ${ARGN})
    list(FIND ${listname} ${_item} _index)
    if(_index EQUAL -1)
      list(APPEND ${listname} ${_item})
    endif()
  endforeach()
endmacro()

# pack a list of libraries with optional build configuration keywords
# copied from catkin/cmake/catkin_libraries.cmake to keep pkgConfig
# self contained
macro(_pack_libraries_with_build_configuration VAR)
  set(${VAR} "")
  set(_argn ${ARGN})
  list(LENGTH _argn _count)
  set(_index 0)
  while(${_index} LESS ${_count})
    list(GET _argn ${_index} lib)
    if("${lib}" MATCHES "^(debug|optimized|general)$")
      math(EXPR _index "${_index} + 1")
      if(${_index} EQUAL ${_count})
        message(FATAL_ERROR "_pack_libraries_with_build_configuration() the list of libraries '${ARGN}' ends with '${lib}' which is a build configuration keyword and must be followed by a library")
      endif()
      list(GET _argn ${_index} library)
      list(APPEND ${VAR} "${lib}${CATKIN_BUILD_CONFIGURATION_KEYWORD_SEPARATOR}${library}")
    else()
      list(APPEND ${VAR} "${lib}")
    endif()
    math(EXPR _index "${_index} + 1")
  endwhile()
endmacro()

# unpack a list of libraries with optional build configuration keyword prefixes
# copied from catkin/cmake/catkin_libraries.cmake to keep pkgConfig
# self contained
macro(_unpack_libraries_with_build_configuration VAR)
  set(${VAR} "")
  foreach(lib ${ARGN})
    string(REGEX REPLACE "^(debug|optimized|general)${CATKIN_BUILD_CONFIGURATION_KEYWORD_SEPARATOR}(.+)$" "\\1;\\2" lib "${lib}")
    list(APPEND ${VAR} "${lib}")
  endforeach()
endmacro()


if(ashwini_CONFIG_INCLUDED)
  return()
endif()
set(ashwini_CONFIG_INCLUDED TRUE)

# set variables for source/devel/install prefixes
if("TRUE" STREQUAL "TRUE")
  set(ashwini_SOURCE_PREFIX /home/daksh/igvc/src/ashwini)
  set(ashwini_DEVEL_PREFIX /home/daksh/igvc/devel)
  set(ashwini_INSTALL_PREFIX "")
  set(ashwini_PREFIX ${ashwini_DEVEL_PREFIX})
else()
  set(ashwini_SOURCE_PREFIX "")
  set(ashwini_DEVEL_PREFIX "")
  set(ashwini_INSTALL_PREFIX /home/daksh/igvc/install)
  set(ashwini_PREFIX ${ashwini_INSTALL_PREFIX})
endif()

# warn when using a deprecated package
if(NOT "" STREQUAL "")
  set(_msg "WARNING: package 'ashwini' is deprecated")
  # append custom deprecation text if available
  if(NOT "" STREQUAL "TRUE")
    set(_msg "${_msg} ()")
  endif()
  message("${_msg}")
endif()

# flag project as catkin-based to distinguish if a find_package()-ed project is a catkin project
set(ashwini_FOUND_CATKIN_PROJECT TRUE)

if(NOT " " STREQUAL " ")
  set(ashwini_INCLUDE_DIRS "")
  set(_include_dirs "")
  if(NOT " " STREQUAL " ")
    set(_report "Check the issue tracker '' and consider creating a ticket if the problem has not been reported yet.")
  elseif(NOT " " STREQUAL " ")
    set(_report "Check the website '' for information and consider reporting the problem.")
  else()
    set(_report "Report the problem to the maintainer 'harsh <harsh@todo.todo>' and request to fix the problem.")
  endif()
  foreach(idir ${_include_dirs})
    if(IS_ABSOLUTE ${idir} AND IS_DIRECTORY ${idir})
      set(include ${idir})
    elseif("${idir} " STREQUAL "include ")
      get_filename_component(include "${ashwini_DIR}/../../../include" ABSOLUTE)
      if(NOT IS_DIRECTORY ${include})
        message(FATAL_ERROR "Project 'ashwini' specifies '${idir}' as an include dir, which is not found.  It does not exist in '${include}'.  ${_report}")
      endif()
    else()
      message(FATAL_ERROR "Project 'ashwini' specifies '${idir}' as an include dir, which is not found.  It does neither exist as an absolute directory nor in '/home/daksh/igvc/src/ashwini/${idir}'.  ${_report}")
    endif()
    _list_append_unique(ashwini_INCLUDE_DIRS ${include})
  endforeach()
endif()

set(libraries "")
foreach(library ${libraries})
  # keep build configuration keywords, target names and absolute libraries as-is
  if("${library}" MATCHES "^(debug|optimized|general)$")
    list(APPEND ashwini_LIBRARIES ${library})
  elseif(${library} MATCHES "^-l")
    list(APPEND ashwini_LIBRARIES ${library})
  elseif(${library} MATCHES "^-")
    # This is a linker flag/option (like -pthread)
    # There's no standard variable for these, so create an interface library to hold it
    if(NOT ashwini_NUM_DUMMY_TARGETS)
      set(ashwini_NUM_DUMMY_TARGETS 0)
    endif()
    # Make sure the target name is unique
    set(interface_target_name "catkin::ashwini::wrapped-linker-option${ashwini_NUM_DUMMY_TARGETS}")
    while(TARGET "${interface_target_name}")
      math(EXPR ashwini_NUM_DUMMY_TARGETS "${ashwini_NUM_DUMMY_TARGETS}+1")
      set(interface_target_name "catkin::ashwini::wrapped-linker-option${ashwini_NUM_DUMMY_TARGETS}")
    endwhile()
    add_library("${interface_target_name}" INTERFACE IMPORTED)
    if("${CMAKE_VERSION}" VERSION_LESS "3.13.0")
      set_property(
        TARGET
        "${interface_target_name}"
        APPEND PROPERTY
        INTERFACE_LINK_LIBRARIES "${library}")
    else()
      target_link_options("${interface_target_name}" INTERFACE "${library}")
    endif()
    list(APPEND ashwini_LIBRARIES "${interface_target_name}")
  elseif(TARGET ${library})
    list(APPEND ashwini_LIBRARIES ${library})
  elseif(IS_ABSOLUTE ${library})
    list(APPEND ashwini_LIBRARIES ${library})
  else()
    set(lib_path "")
    set(lib "${library}-NOTFOUND")
    # since the path where the library is found is returned we have to iterate over the paths manually
    foreach(path /home/daksh/igvc/devel/lib;/home/daksh/igvc/devel/lib;/opt/ros/noetic/lib)
      find_library(lib ${library}
        PATHS ${path}
        NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
      if(lib)
        set(lib_path ${path})
        break()
      endif()
    endforeach()
    if(lib)
      _list_append_unique(ashwini_LIBRARY_DIRS ${lib_path})
      list(APPEND ashwini_LIBRARIES ${lib})
    else()
      # as a fall back for non-catkin libraries try to search globally
      find_library(lib ${library})
      if(NOT lib)
        message(FATAL_ERROR "Project '${PROJECT_NAME}' tried to find library '${library}'.  The library is neither a target nor built/installed properly.  Did you compile project 'ashwini'?  Did you find_package() it before the subdirectory containing its code is included?")
      endif()
      list(APPEND ashwini_LIBRARIES ${lib})
    endif()
  endif()
endforeach()

set(ashwini_EXPORTED_TARGETS "")
# create dummy targets for exported code generation targets to make life of users easier
foreach(t ${ashwini_EXPORTED_TARGETS})
  if(NOT TARGET ${t})
    add_custom_target(${t})
  endif()
endforeach()

set(depends "")
foreach(depend ${depends})
  string(REPLACE " " ";" depend_list ${depend})
  # the package name of the dependency must be kept in a unique variable so that it is not overwritten in recursive calls
  list(GET depend_list 0 ashwini_dep)
  list(LENGTH depend_list count)
  if(${count} EQUAL 1)
    # simple dependencies must only be find_package()-ed once
    if(NOT ${ashwini_dep}_FOUND)
      find_package(${ashwini_dep} REQUIRED NO_MODULE)
    endif()
  else()
    # dependencies with components must be find_package()-ed again
    list(REMOVE_AT depend_list 0)
    find_package(${ashwini_dep} REQUIRED NO_MODULE ${depend_list})
  endif()
  _list_append_unique(ashwini_INCLUDE_DIRS ${${ashwini_dep}_INCLUDE_DIRS})

  # merge build configuration keywords with library names to correctly deduplicate
  _pack_libraries_with_build_configuration(ashwini_LIBRARIES ${ashwini_LIBRARIES})
  _pack_libraries_with_build_configuration(_libraries ${${ashwini_dep}_LIBRARIES})
  _list_append_deduplicate(ashwini_LIBRARIES ${_libraries})
  # undo build configuration keyword merging after deduplication
  _unpack_libraries_with_build_configuration(ashwini_LIBRARIES ${ashwini_LIBRARIES})

  _list_append_unique(ashwini_LIBRARY_DIRS ${${ashwini_dep}_LIBRARY_DIRS})
  _list_append_deduplicate(ashwini_EXPORTED_TARGETS ${${ashwini_dep}_EXPORTED_TARGETS})
endforeach()

set(pkg_cfg_extras "")
foreach(extra ${pkg_cfg_extras})
  if(NOT IS_ABSOLUTE ${extra})
    set(extra ${ashwini_DIR}/${extra})
  endif()
  include(${extra})
endforeach()



================================================
File: devel/share/rplidar_ros/cmake/rplidar_rosConfig-version.cmake
================================================
# generated from catkin/cmake/template/pkgConfig-version.cmake.in
set(PACKAGE_VERSION "2.1.5")

set(PACKAGE_VERSION_EXACT False)
set(PACKAGE_VERSION_COMPATIBLE False)

if("${PACKAGE_FIND_VERSION}" VERSION_EQUAL "${PACKAGE_VERSION}")
  set(PACKAGE_VERSION_EXACT True)
  set(PACKAGE_VERSION_COMPATIBLE True)
endif()

if("${PACKAGE_FIND_VERSION}" VERSION_LESS "${PACKAGE_VERSION}")
  set(PACKAGE_VERSION_COMPATIBLE True)
endif()



================================================
File: devel/share/rplidar_ros/cmake/rplidar_rosConfig.cmake
================================================
# generated from catkin/cmake/template/pkgConfig.cmake.in

# append elements to a list and remove existing duplicates from the list
# copied from catkin/cmake/list_append_deduplicate.cmake to keep pkgConfig
# self contained
macro(_list_append_deduplicate listname)
  if(NOT "${ARGN}" STREQUAL "")
    if(${listname})
      list(REMOVE_ITEM ${listname} ${ARGN})
    endif()
    list(APPEND ${listname} ${ARGN})
  endif()
endmacro()

# append elements to a list if they are not already in the list
# copied from catkin/cmake/list_append_unique.cmake to keep pkgConfig
# self contained
macro(_list_append_unique listname)
  foreach(_item ${ARGN})
    list(FIND ${listname} ${_item} _index)
    if(_index EQUAL -1)
      list(APPEND ${listname} ${_item})
    endif()
  endforeach()
endmacro()

# pack a list of libraries with optional build configuration keywords
# copied from catkin/cmake/catkin_libraries.cmake to keep pkgConfig
# self contained
macro(_pack_libraries_with_build_configuration VAR)
  set(${VAR} "")
  set(_argn ${ARGN})
  list(LENGTH _argn _count)
  set(_index 0)
  while(${_index} LESS ${_count})
    list(GET _argn ${_index} lib)
    if("${lib}" MATCHES "^(debug|optimized|general)$")
      math(EXPR _index "${_index} + 1")
      if(${_index} EQUAL ${_count})
        message(FATAL_ERROR "_pack_libraries_with_build_configuration() the list of libraries '${ARGN}' ends with '${lib}' which is a build configuration keyword and must be followed by a library")
      endif()
      list(GET _argn ${_index} library)
      list(APPEND ${VAR} "${lib}${CATKIN_BUILD_CONFIGURATION_KEYWORD_SEPARATOR}${library}")
    else()
      list(APPEND ${VAR} "${lib}")
    endif()
    math(EXPR _index "${_index} + 1")
  endwhile()
endmacro()

# unpack a list of libraries with optional build configuration keyword prefixes
# copied from catkin/cmake/catkin_libraries.cmake to keep pkgConfig
# self contained
macro(_unpack_libraries_with_build_configuration VAR)
  set(${VAR} "")
  foreach(lib ${ARGN})
    string(REGEX REPLACE "^(debug|optimized|general)${CATKIN_BUILD_CONFIGURATION_KEYWORD_SEPARATOR}(.+)$" "\\1;\\2" lib "${lib}")
    list(APPEND ${VAR} "${lib}")
  endforeach()
endmacro()


if(rplidar_ros_CONFIG_INCLUDED)
  return()
endif()
set(rplidar_ros_CONFIG_INCLUDED TRUE)

# set variables for source/devel/install prefixes
if("TRUE" STREQUAL "TRUE")
  set(rplidar_ros_SOURCE_PREFIX /home/daksh/igvc/src/rplidar_ros)
  set(rplidar_ros_DEVEL_PREFIX /home/daksh/igvc/devel)
  set(rplidar_ros_INSTALL_PREFIX "")
  set(rplidar_ros_PREFIX ${rplidar_ros_DEVEL_PREFIX})
else()
  set(rplidar_ros_SOURCE_PREFIX "")
  set(rplidar_ros_DEVEL_PREFIX "")
  set(rplidar_ros_INSTALL_PREFIX /home/daksh/igvc/install)
  set(rplidar_ros_PREFIX ${rplidar_ros_INSTALL_PREFIX})
endif()

# warn when using a deprecated package
if(NOT "" STREQUAL "")
  set(_msg "WARNING: package 'rplidar_ros' is deprecated")
  # append custom deprecation text if available
  if(NOT "" STREQUAL "TRUE")
    set(_msg "${_msg} ()")
  endif()
  message("${_msg}")
endif()

# flag project as catkin-based to distinguish if a find_package()-ed project is a catkin project
set(rplidar_ros_FOUND_CATKIN_PROJECT TRUE)

if(NOT " " STREQUAL " ")
  set(rplidar_ros_INCLUDE_DIRS "")
  set(_include_dirs "")
  if(NOT " " STREQUAL " ")
    set(_report "Check the issue tracker '' and consider creating a ticket if the problem has not been reported yet.")
  elseif(NOT " " STREQUAL " ")
    set(_report "Check the website '' for information and consider reporting the problem.")
  else()
    set(_report "Report the problem to the maintainer 'Slamtec ROS Maintainer <ros@slamtec.com>' and request to fix the problem.")
  endif()
  foreach(idir ${_include_dirs})
    if(IS_ABSOLUTE ${idir} AND IS_DIRECTORY ${idir})
      set(include ${idir})
    elseif("${idir} " STREQUAL "include ")
      get_filename_component(include "${rplidar_ros_DIR}/../../../include" ABSOLUTE)
      if(NOT IS_DIRECTORY ${include})
        message(FATAL_ERROR "Project 'rplidar_ros' specifies '${idir}' as an include dir, which is not found.  It does not exist in '${include}'.  ${_report}")
      endif()
    else()
      message(FATAL_ERROR "Project 'rplidar_ros' specifies '${idir}' as an include dir, which is not found.  It does neither exist as an absolute directory nor in '/home/daksh/igvc/src/rplidar_ros/${idir}'.  ${_report}")
    endif()
    _list_append_unique(rplidar_ros_INCLUDE_DIRS ${include})
  endforeach()
endif()

set(libraries "")
foreach(library ${libraries})
  # keep build configuration keywords, target names and absolute libraries as-is
  if("${library}" MATCHES "^(debug|optimized|general)$")
    list(APPEND rplidar_ros_LIBRARIES ${library})
  elseif(${library} MATCHES "^-l")
    list(APPEND rplidar_ros_LIBRARIES ${library})
  elseif(${library} MATCHES "^-")
    # This is a linker flag/option (like -pthread)
    # There's no standard variable for these, so create an interface library to hold it
    if(NOT rplidar_ros_NUM_DUMMY_TARGETS)
      set(rplidar_ros_NUM_DUMMY_TARGETS 0)
    endif()
    # Make sure the target name is unique
    set(interface_target_name "catkin::rplidar_ros::wrapped-linker-option${rplidar_ros_NUM_DUMMY_TARGETS}")
    while(TARGET "${interface_target_name}")
      math(EXPR rplidar_ros_NUM_DUMMY_TARGETS "${rplidar_ros_NUM_DUMMY_TARGETS}+1")
      set(interface_target_name "catkin::rplidar_ros::wrapped-linker-option${rplidar_ros_NUM_DUMMY_TARGETS}")
    endwhile()
    add_library("${interface_target_name}" INTERFACE IMPORTED)
    if("${CMAKE_VERSION}" VERSION_LESS "3.13.0")
      set_property(
        TARGET
        "${interface_target_name}"
        APPEND PROPERTY
        INTERFACE_LINK_LIBRARIES "${library}")
    else()
      target_link_options("${interface_target_name}" INTERFACE "${library}")
    endif()
    list(APPEND rplidar_ros_LIBRARIES "${interface_target_name}")
  elseif(TARGET ${library})
    list(APPEND rplidar_ros_LIBRARIES ${library})
  elseif(IS_ABSOLUTE ${library})
    list(APPEND rplidar_ros_LIBRARIES ${library})
  else()
    set(lib_path "")
    set(lib "${library}-NOTFOUND")
    # since the path where the library is found is returned we have to iterate over the paths manually
    foreach(path /home/daksh/igvc/devel/lib;/home/daksh/igvc/devel/lib;/opt/ros/noetic/lib)
      find_library(lib ${library}
        PATHS ${path}
        NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
      if(lib)
        set(lib_path ${path})
        break()
      endif()
    endforeach()
    if(lib)
      _list_append_unique(rplidar_ros_LIBRARY_DIRS ${lib_path})
      list(APPEND rplidar_ros_LIBRARIES ${lib})
    else()
      # as a fall back for non-catkin libraries try to search globally
      find_library(lib ${library})
      if(NOT lib)
        message(FATAL_ERROR "Project '${PROJECT_NAME}' tried to find library '${library}'.  The library is neither a target nor built/installed properly.  Did you compile project 'rplidar_ros'?  Did you find_package() it before the subdirectory containing its code is included?")
      endif()
      list(APPEND rplidar_ros_LIBRARIES ${lib})
    endif()
  endif()
endforeach()

set(rplidar_ros_EXPORTED_TARGETS "")
# create dummy targets for exported code generation targets to make life of users easier
foreach(t ${rplidar_ros_EXPORTED_TARGETS})
  if(NOT TARGET ${t})
    add_custom_target(${t})
  endif()
endforeach()

set(depends "")
foreach(depend ${depends})
  string(REPLACE " " ";" depend_list ${depend})
  # the package name of the dependency must be kept in a unique variable so that it is not overwritten in recursive calls
  list(GET depend_list 0 rplidar_ros_dep)
  list(LENGTH depend_list count)
  if(${count} EQUAL 1)
    # simple dependencies must only be find_package()-ed once
    if(NOT ${rplidar_ros_dep}_FOUND)
      find_package(${rplidar_ros_dep} REQUIRED NO_MODULE)
    endif()
  else()
    # dependencies with components must be find_package()-ed again
    list(REMOVE_AT depend_list 0)
    find_package(${rplidar_ros_dep} REQUIRED NO_MODULE ${depend_list})
  endif()
  _list_append_unique(rplidar_ros_INCLUDE_DIRS ${${rplidar_ros_dep}_INCLUDE_DIRS})

  # merge build configuration keywords with library names to correctly deduplicate
  _pack_libraries_with_build_configuration(rplidar_ros_LIBRARIES ${rplidar_ros_LIBRARIES})
  _pack_libraries_with_build_configuration(_libraries ${${rplidar_ros_dep}_LIBRARIES})
  _list_append_deduplicate(rplidar_ros_LIBRARIES ${_libraries})
  # undo build configuration keyword merging after deduplication
  _unpack_libraries_with_build_configuration(rplidar_ros_LIBRARIES ${rplidar_ros_LIBRARIES})

  _list_append_unique(rplidar_ros_LIBRARY_DIRS ${${rplidar_ros_dep}_LIBRARY_DIRS})
  _list_append_deduplicate(rplidar_ros_EXPORTED_TARGETS ${${rplidar_ros_dep}_EXPORTED_TARGETS})
endforeach()

set(pkg_cfg_extras "")
foreach(extra ${pkg_cfg_extras})
  if(NOT IS_ABSOLUTE ${extra})
    set(extra ${rplidar_ros_DIR}/${extra})
  endif()
  include(${extra})
endforeach()



================================================
File: src/ashwini/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.0.2)
project(ashwini)

find_package(catkin REQUIRED COMPONENTS
  message_generation
  message_runtime
  roscpp
  rospy
  std_msgs
  tf
)

catkin_package(
#  INCLUDE_DIRS include
#  LIBRARIES ashwini
#  CATKIN_DEPENDS message_generation message_runtime roscpp rospy std_msgs
#  DEPENDS system_lib
)

include_directories(
# include
  ${catkin_INCLUDE_DIRS}
)


================================================
File: src/ashwini/digest.txt
================================================
Directory structure:
└── ashwini/
    ├── package.xml
    ├── config/
    │   ├── costmap_common_params.yaml
    │   ├── ekf.yaml
    │   ├── global_costmap_params.yaml
    │   ├── local_costmap_params.yaml
    │   ├── rplidar_filter.yaml
    │   └── trajectory_planner.yaml
    ├── launch/
    │   ├── lane.launch
    │   ├── move_base.launch
    │   ├── real.launch
    │   ├── robot_description.launch
    │   ├── simulation.launch
    │   └── suryatest.launch
    ├── meshes/
    ├── models/
    ├── rviz/
    │   ├── default.rviz
    │   └── real.rviz
    ├── script/
    │   ├── camera_publisher.py
    │   ├── imu.py
    │   ├── lane_detection.py
    │   ├── lane_follower.py
    │   ├── motor_serial.py
    │   ├── move_around.py
    │   ├── move_smart.py
    │   ├── move_straight.py
    │   └── waypoint.py
    ├── urdf/
    │   ├── ashwini.gazebo
    │   └── ashwini.xacro
    └── worlds/
        └── empty.world

================================================
File: package.xml
================================================
<?xml version="1.0"?>
<package format="2">
  <name>ashwini</name>
  <version>0.0.0</version>
  <description>The ashwini package</description>

  <maintainer email="harsh@todo.todo">harsh</maintainer>

  <license>TODO</license>

  <buildtool_depend>catkin</buildtool_depend>
  <build_depend>message_generation</build_depend>
  <build_depend>roscpp</build_depend>
  <build_depend>rospy</build_depend>
  <build_depend>std_msgs</build_depend>
  <build_depend>sensor_msgs</build_depend>
  <build_depend>opencv2</build_depend>
  <build_depend>cv_bridge</build_depend>
  

  <build_export_depend>roscpp</build_export_depend>
  <build_export_depend>rospy</build_export_depend>
  <build_export_depend>std_msgs</build_export_depend>
  <build_export_depend>sensor_msgs</build_export_depend>
  <build_export_depend>opencv2</build_export_depend>
  <build_export_depend>cv_bridge</build_export_depend>
  
  <depend>geometry_msgs</depend>
  <exec_depend>message_runtime</exec_depend>
  <exec_depend>roscpp</exec_depend>
  <exec_depend>rospy</exec_depend>
  <exec_depend>std_msgs</exec_depend>
  <exec_depend>sensor_msgs</exec_depend>
  <exec_depend>opencv2</exec_depend>
  <exec_depend>cv_bridge</exec_depend>

</package>



================================================
File: config/costmap_common_params.yaml
================================================
obstacle_range: 6.0
raytrace_range: 8.5
footprint: [[0.3,0.2],[0.3,-0.2],[-0.3,-0.2],[-0.3,0.2]]
map_topic: /map
subscribe_to_update: true
observation_sources: laser_scan_sensor
laser_scan_sensor: {sensor_frame: hokuyo, data_type: LaserScan, topic: /scan, marking: true, clearing: true }
global_frame: map
robot_base_frame: base_link
always_send_full_costmap: true



================================================
File: config/ekf.yaml
================================================
ekf_node:
  frequency: 30
  sensor_timeout: 0.1
  two_d_mode: true
  publish_tf: true
  map_frame: map
  odom_frame: odom
  base_link_frame: base_link
  world_frame: odom

  imu0: imu/data
  imu0_config: [false, false, false,  # x, y, z pos
                false, false, false,  # x, y, z vel
                false, false, true,   # x, y, z ori
                false, false, true]   # x, y, z ang vel
  imu0_differential: false
  imu0_remove_gravitational_acceleration: true

  use_control: false



================================================
File: config/global_costmap_params.yaml
================================================
global_costmap:
  update_frequency: 2.5
  publish_frequency: 2.5
  transform_tolerance: 2.1
  static_map: true
  rolling_window: false 
  width: 10
  height: 10
  origin_x: -7.5
  origin_y: -7.5
  resolution: 0.1
  inflation_radius: 2.5

  
 


================================================
File: config/local_costmap_params.yaml
================================================
local_costmap:
  update_frequency: 5
  publish_frequency: 5
  transform_tolerance: 1.25
  static_map: false
  rolling_window: true
  width: 3
  height: 3
  origin_x: -1.5
  origin_y: -1.5
  resolution: 0.1
  inflation_radius: 0.6

  


================================================
File: config/rplidar_filter.yaml
================================================
scan_filter_chain:
  - name: angle_filter
    type: laser_filters/ScanAngleFilter
    params:
      lower_angle: -1.5708  # -90 degrees
      upper_angle: 1.5708   # 90 degrees

  - name: range_filter
    type: laser_filters/ScanRangeFilter
    params:
      lower_threshold: 3.0
      upper_threshold: 7.5



================================================
File: config/trajectory_planner.yaml
================================================
TrajectoryPlannerROS:
  max_vel_x: 1
  min_vel_x: 0.5
  max_vel_theta: 0.35
  min_vel_theta: -0.35
  min_in_place_vel_theta: 0.25

  acc_lim_theta: 0.25
  acc_lim_X: 2.5
  acc_lim_Y: 2.5
  
  holonomic_robot: false
  meter_scoring: true

  xy_goal_tolerance: 0.5
  yaw_goal_tolerance: 1
  



================================================
File: launch/lane.launch
================================================
<launch>
  <!-- Launch lane detection node -->
  <node pkg="ashwini" type="lane_detection.py" name="lane_detection" output="screen" />

  <!-- Launch lane follower node -->
  <node pkg="ashwini" type="lane_follower.py" name="lane_follower" output="screen">
    <!-- You can adjust parameters here -->

  </node>
</launch>


================================================
File: launch/move_base.launch
================================================
<?xml version="1.0"?>
<launch>

    <node pkg="gmapping" type="slam_gmapping" name="maping_node">
        <param name="base_frame" value="base_link" />
        <param name="odom_frame" value="odom" />
        <param name="delta" value="0.1" />
    </node>

    <node pkg="move_base" type="move_base" name="Base_move" output="screen">
        <param name="controller_frequency" value="10.0" />
        <rosparam file="$(find ashwini)/config/trajectory_planner.yaml" command="load" />
        <rosparam file="$(find ashwini)/config/costmap_common_params.yaml" command="load" ns="global_costmap"/>
        <rosparam file="$(find ashwini)/config/costmap_common_params.yaml" command="load" ns="local_costmap"/>
        <rosparam file="$(find ashwini)/config/local_costmap_params.yaml" command="load" />
        <rosparam file="$(find ashwini)/config/global_costmap_params.yaml" command="load" />
    </node>

</launch>


================================================
File: launch/real.launch
================================================
<?xml version="1.0" encoding="UTF-8"?>

<launch>
	<arg name="robot_name" default="ashwini"/>

	<include file="$(find ashwini)/launch/robot_description.launch"/>
	<include file="$(find ashwini)/launch/move_base.launch"/>

	<node name="rviz" pkg="rviz" type="rviz" respawn="false"
		args="-d $(find ashwini)/rviz/real.rviz"/>

	<node pkg="rplidar_ros" type="rplidarNode" name="rplidarNode" output="screen">
		<param name="serial_port" value="/dev/ttyUSB0"/>
		<param name="serial_baudrate" value="256000"/>
		<param name="frame_id" value="hokuyo"/>
		<param name="angle_compensate" type="bool" value="true"/>
    </node>

	<rosparam command="load" file="$(find ashwini)/config/laser_filter.yaml" />
	<node pkg="laser_filters" type="scan_to_scan_filter_chain" name="scan_filter" />

	<node pkg="robot_localization" type="ekf_localization_node" name="ekf_filter_node" output="screen">
		<rosparam file="$(find ashwini)/config/ekf.yaml" command="load" />
	</node>

	<node pkg="ashwini" type="imu.py" name="imu_node" output="screen"/>

	<node pkg="ashwini" type="camera_publisher.py" name="camera_node" output="screen"/>

    
</launch>



================================================
File: launch/robot_description.launch
================================================
<?xml version="1.0"?>
<launch>

    <!-- send urdf to param server -->
    <param name="robot_description" command="$(find xacro)/xacro --inorder '$(find ashwini)/urdf/ashwini.xacro'" />

    <!-- Send fake joint values-->
    <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher">
        <param name="use_gui" value="false"/>
        <param name="publish_default_positions" value="true"/>
    </node>

    <!-- Send robot states to tf -->
    <node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher" respawn="false" output="screen">
	    <param name="publish_frequency" type="double" value="50.0" />
	</node>

</launch>



================================================
File: launch/simulation.launch
================================================
<?xml version="1.0" encoding="UTF-8"?>

<launch>
	<arg name="robot_name" default="ashwini"/>

	<include file="$(find ashwini)/launch/robot_description.launch"/>
	<include file="$(find ashwini)/launch/move_base.launch"/>
	
	<arg name="world_file" default="$(find ashwini)/worlds/empty.world"/>

	<include file="$(find gazebo_ros)/launch/empty_world.launch">
		<arg name="use_sim_time" value="true"/>
		<arg name="verbose" value="false"/>
		<arg name="debug" value="false"/>
		<arg name="gui" value="true" />
		<arg name="world_name" value="$(arg world_file)"/>
	</include>
	
	<node name="urdf_spawner" pkg="gazebo_ros" type="spawn_model" respawn="false" output="screen"
		args="-urdf -param robot_description -model ashwini
			  -x 6 -y 4 -z 0.23
			  -R 0 -P 0 -Y 0"/>

	<node name="rviz" pkg="rviz" type="rviz" respawn="false"
		args="-d $(find ashwini)/rviz/default.rviz"/>

	<node name="spawn_lane_overlay" pkg="gazebo_ros" type="spawn_model" output="screen"
	args="-file $(find ashwini)/models/lane_overlay/model.sdf -sdf -model lane_overlay -x 0 -y 0 -z 0.01"/>
	
	<!-- <node pkg="ashwini" type="imu.py" name="imu_node" output="screen"/> -->

</launch>



================================================
File: launch/suryatest.launch
================================================
<launch>

	<arg name="robot_name" default="ashwini"/>

	<include file="$(find ashwini)/launch/robot_description.launch"/>
	<include file="$(find ashwini)/launch/move_base.launch"/>

	<node name="rviz" pkg="rviz" type="rviz" respawn="false"
		args="-d $(find ashwini)/rviz/real.rviz"/>

	<node pkg="rplidar_ros" type="rplidarNode" name="rplidarNode" output="screen">
		<param name="serial_port" value="/dev/ttyUSB0"/>
		<param name="serial_baudrate" value="256000"/>
		<param name="frame_id" value="hokuyo"/>
		<param name="angle_compensate" type="bool" value="true"/>
    </node>

	<rosparam command="load" file="$(find ashwini)/config/rplidar_filter.yaml" />
	<node pkg="laser_filters" type="scan_to_scan_filter_chain" name="scan_filter" />

	<node pkg="robot_localization" type="ekf_localization_node" name="ekf_filter_node" output="screen">
		<rosparam file="$(find ashwini)/config/ekf.yaml" command="load" />
	</node>

	<node pkg="ashwini" type="imu.py" name="imu_node" output="screen"/>

	<!-- <node pkg="ashwini" type="camera_publisher.py" name="camera_node" output="screen"/> -->

  <node pkg="ashwini" type="motor_serial.py" name="tungtungtungsahur" output="screen"/>

</launch>




================================================
File: rviz/default.rviz
================================================
Panels:
  - Class: rviz/Displays
    Help Height: 78
    Name: Displays
    Property Tree Widget:
      Expanded:
        - /Imu1
      Splitter Ratio: 0.5058823823928833
    Tree Height: 531
  - Class: rviz/Selection
    Name: Selection
  - Class: rviz/Tool Properties
    Expanded:
      - /2D Pose Estimate1
      - /2D Nav Goal1
      - /Publish Point1
    Name: Tool Properties
    Splitter Ratio: 0.5886790156364441
  - Class: rviz/Views
    Expanded:
      - /Current View1
    Name: Views
    Splitter Ratio: 0.5
  - Class: rviz/Time
    Name: Time
    SyncMode: 0
    SyncSource: LaserScan
Preferences:
  PromptSaveOnExit: true
Toolbars:
  toolButtonStyle: 2
Visualization Manager:
  Class: ""
  Displays:
    - Alpha: 0.5
      Cell Size: 1
      Class: rviz/Grid
      Color: 160; 160; 164
      Enabled: true
      Line Style:
        Line Width: 0.029999999329447746
        Value: Lines
      Name: Grid
      Normal Cell Count: 0
      Offset:
        X: 0
        Y: 0
        Z: 0
      Plane: XY
      Plane Cell Count: 100
      Reference Frame: <Fixed Frame>
      Value: true
    - Class: rviz/Camera
      Enabled: true
      Image Rendering: background and overlay
      Image Topic: /ashwini/camera/rgb/image_raw
      Name: Camera
      Overlay Alpha: 0.5
      Queue Size: 2
      Transport Hint: raw
      Unreliable: false
      Value: true
      Visibility:
        Grid: true
        Imu: true
        LaserScan: true
        Map: true
        Path: true
        RobotModel: true
        TF: true
        Value: true
      Zoom Factor: 1
    - Alpha: 1
      Autocompute Intensity Bounds: true
      Autocompute Value Bounds:
        Max Value: 10
        Min Value: -10
        Value: true
      Axis: Z
      Channel Name: intensity
      Class: rviz/LaserScan
      Color: 255; 255; 255
      Color Transformer: Intensity
      Decay Time: 0
      Enabled: true
      Invert Rainbow: false
      Max Color: 255; 255; 255
      Min Color: 0; 0; 0
      Name: LaserScan
      Position Transformer: XYZ
      Queue Size: 10
      Selectable: true
      Size (Pixels): 3
      Size (m): 0.009999999776482582
      Style: Flat Squares
      Topic: /scan
      Unreliable: false
      Use Fixed Frame: true
      Use rainbow: true
      Value: true
    - Alpha: 1
      Class: rviz/RobotModel
      Collision Enabled: false
      Enabled: true
      Links:
        All Links Enabled: true
        Expand Joint Details: false
        Expand Link Details: false
        Expand Tree: false
        Link Tree Style: Links in Alphabetic Order
        base_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        camera:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        hokuyo:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        imu_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_castor_dummy_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_castor_mount_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_castor_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_drive_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        right_castor_dummy_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        right_castor_mount_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        right_castor_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        right_drive_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
      Name: RobotModel
      Robot Description: robot_description
      TF Prefix: ""
      Update Interval: 0
      Value: true
      Visual Enabled: true
    - Class: rviz/TF
      Enabled: false
      Filter (blacklist): ""
      Filter (whitelist): ""
      Frame Timeout: 15
      Frames:
        All Enabled: true
      Marker Alpha: 1
      Marker Scale: 1
      Name: TF
      Show Arrows: true
      Show Axes: true
      Show Names: true
      Tree:
        {}
      Update Interval: 0
      Value: false
    - Alpha: 1
      Buffer Length: 1
      Class: rviz/Path
      Color: 206; 92; 0
      Enabled: true
      Head Diameter: 0.30000001192092896
      Head Length: 0.20000000298023224
      Length: 0.30000001192092896
      Line Style: Lines
      Line Width: 0.029999999329447746
      Name: Path
      Offset:
        X: 0
        Y: 0
        Z: 0
      Pose Color: 255; 85; 255
      Pose Style: None
      Queue Size: 10
      Radius: 0.029999999329447746
      Shaft Diameter: 0.10000000149011612
      Shaft Length: 0.10000000149011612
      Topic: /Base_move/TrajectoryPlannerROS/local_plan
      Unreliable: false
      Value: true
    - Alpha: 1
      Buffer Length: 1
      Class: rviz/Path
      Color: 9; 8; 67
      Enabled: true
      Head Diameter: 0.30000001192092896
      Head Length: 0.20000000298023224
      Length: 0.30000001192092896
      Line Style: Lines
      Line Width: 0.029999999329447746
      Name: Path
      Offset:
        X: 0
        Y: 0
        Z: 0
      Pose Color: 255; 85; 255
      Pose Style: None
      Queue Size: 10
      Radius: 0.029999999329447746
      Shaft Diameter: 0.10000000149011612
      Shaft Length: 0.10000000149011612
      Topic: /Base_move/TrajectoryPlannerROS/global_plan
      Unreliable: false
      Value: true
    - Alpha: 0.699999988079071
      Class: rviz/Map
      Color Scheme: map
      Draw Behind: true
      Enabled: true
      Name: Map
      Topic: /map
      Unreliable: false
      Use Timestamp: false
      Value: true
    - Alpha: 0.699999988079071
      Class: rviz/Map
      Color Scheme: costmap
      Draw Behind: false
      Enabled: true
      Name: Map
      Topic: /Base_move/global_costmap/costmap
      Unreliable: false
      Use Timestamp: false
      Value: true
    - Alpha: 0.699999988079071
      Class: rviz/Map
      Color Scheme: raw
      Draw Behind: false
      Enabled: true
      Name: Map
      Topic: /Base_move/local_costmap/costmap
      Unreliable: false
      Use Timestamp: false
      Value: true
  Enabled: true
  Global Options:
    Background Color: 48; 48; 48
    Default Light: true
    Fixed Frame: map
    Frame Rate: 60
  Name: root
  Tools:
    - Class: rviz/Interact
      Hide Inactive Objects: true
    - Class: rviz/MoveCamera
    - Class: rviz/Select
    - Class: rviz/FocusCamera
    - Class: rviz/Measure
    - Class: rviz/SetInitialPose
      Theta std deviation: 0.2617993950843811
      Topic: /initialpose
      X std deviation: 0.5
      Y std deviation: 0.5
    - Class: rviz/SetGoal
      Topic: /move_base_simple/goal
    - Class: rviz/PublishPoint
      Single click: true
      Topic: /clicked_point
  Value: true
  Views:
    Current:
      Class: rviz/Orbit
      Distance: 32.96086883544922
      Enable Stereo Rendering:
        Stereo Eye Separation: 0.05999999865889549
        Stereo Focal Distance: 1
        Swap Stereo Eyes: false
        Value: false
      Field of View: 0.7853981852531433
      Focal Point:
        X: 7.145931243896484
        Y: 2.9171111583709717
        Z: -0.09273505210876465
      Focal Shape Fixed Size: true
      Focal Shape Size: 0.05000000074505806
      Invert Z Axis: false
      Name: Current View
      Near Clip Distance: 0.009999999776482582
      Pitch: 0.5297966599464417
      Target Frame: <Fixed Frame>
      Yaw: 2.9867522716522217
    Saved: ~
Window Geometry:
  Camera:
    collapsed: false
  Displays:
    collapsed: false
  Height: 1016
  Hide Left Dock: false
  Hide Right Dock: false
  QMainWindow State: 000000ff00000000fd0000000400000000000001560000035afc0200000009fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c006100790073010000003d0000029e000000c900fffffffb0000000c00430061006d00650072006101000002e1000000b60000001600fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261000000010000010f0000035afc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000000a00560069006500770073010000003d0000035a000000a400fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000007380000003efc0100000002fb0000000800540069006d0065010000000000000738000003bc00fffffffb0000000800540069006d00650100000000000004500000000000000000000004c70000035a00000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
  Selection:
    collapsed: false
  Time:
    collapsed: false
  Tool Properties:
    collapsed: false
  Views:
    collapsed: false
  Width: 1848
  X: 72
  Y: 27



================================================
File: rviz/real.rviz
================================================
Panels:
  - Class: rviz/Displays
    Help Height: 78
    Name: Displays
    Property Tree Widget:
      Expanded:
        - /Global Options1
        - /Imu1
      Splitter Ratio: 0.5058823823928833
    Tree Height: 531
  - Class: rviz/Selection
    Name: Selection
  - Class: rviz/Tool Properties
    Expanded:
      - /2D Pose Estimate1
      - /2D Nav Goal1
      - /Publish Point1
    Name: Tool Properties
    Splitter Ratio: 0.5886790156364441
  - Class: rviz/Views
    Expanded:
      - /Current View1
    Name: Views
    Splitter Ratio: 0.5
  - Class: rviz/Time
    Name: Time
    SyncMode: 0
    SyncSource: LaserScan
Preferences:
  PromptSaveOnExit: true
Toolbars:
  toolButtonStyle: 2
Visualization Manager:
  Class: ""
  Displays:
    - Alpha: 0.5
      Cell Size: 1
      Class: rviz/Grid
      Color: 160; 160; 164
      Enabled: true
      Line Style:
        Line Width: 0.029999999329447746
        Value: Lines
      Name: Grid
      Normal Cell Count: 0
      Offset:
        X: 0
        Y: 0
        Z: 0
      Plane: XY
      Plane Cell Count: 100
      Reference Frame: <Fixed Frame>
      Value: true
    - Class: rviz/Camera
      Enabled: true
      Image Rendering: background and overlay
      Image Topic: /ashwini/camera/rgb/image_raw
      Name: Camera
      Overlay Alpha: 0.5
      Queue Size: 2
      Transport Hint: raw
      Unreliable: false
      Value: true
      Visibility:
        Grid: true
        Imu: true
        LaserScan: true
        Map: true
        Path: true
        RobotModel: true
        TF: true
        Value: true
      Zoom Factor: 1
    - Alpha: 1
      Autocompute Intensity Bounds: true
      Autocompute Value Bounds:
        Max Value: 10
        Min Value: -10
        Value: true
      Axis: Z
      Channel Name: intensity
      Class: rviz/LaserScan
      Color: 255; 255; 255
      Color Transformer: Intensity
      Decay Time: 0
      Enabled: true
      Invert Rainbow: false
      Max Color: 255; 255; 255
      Min Color: 0; 0; 0
      Name: LaserScan
      Position Transformer: XYZ
      Queue Size: 10
      Selectable: true
      Size (Pixels): 3
      Size (m): 0.009999999776482582
      Style: Flat Squares
      Topic: /scan
      Unreliable: false
      Use Fixed Frame: true
      Use rainbow: true
      Value: true
    - Alpha: 1
      Class: rviz/RobotModel
      Collision Enabled: false
      Enabled: true
      Links:
        All Links Enabled: true
        Expand Joint Details: false
        Expand Link Details: false
        Expand Tree: false
        Link Tree Style: Links in Alphabetic Order
        base_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        camera:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        hokuyo:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        imu:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_castor_dummy_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_castor_mount_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_castor_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_drive_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        odom:
          Alpha: 1
          Show Axes: false
          Show Trail: false
        right_castor_dummy_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        right_castor_mount_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        right_castor_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        right_drive_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
      Name: RobotModel
      Robot Description: robot_description
      TF Prefix: ""
      Update Interval: 0
      Value: true
      Visual Enabled: true
    - Class: rviz/TF
      Enabled: false
      Filter (blacklist): ""
      Filter (whitelist): ""
      Frame Timeout: 15
      Frames:
        All Enabled: true
      Marker Alpha: 1
      Marker Scale: 1
      Name: TF
      Show Arrows: true
      Show Axes: true
      Show Names: true
      Tree:
        {}
      Update Interval: 0
      Value: false
    - Alpha: 1
      Buffer Length: 1
      Class: rviz/Path
      Color: 206; 92; 0
      Enabled: true
      Head Diameter: 0.30000001192092896
      Head Length: 0.20000000298023224
      Length: 0.30000001192092896
      Line Style: Lines
      Line Width: 0.029999999329447746
      Name: Path
      Offset:
        X: 0
        Y: 0
        Z: 0
      Pose Color: 255; 85; 255
      Pose Style: None
      Queue Size: 10
      Radius: 0.029999999329447746
      Shaft Diameter: 0.10000000149011612
      Shaft Length: 0.10000000149011612
      Topic: /Base_move/TrajectoryPlannerROS/local_plan
      Unreliable: false
      Value: true
    - Alpha: 1
      Buffer Length: 1
      Class: rviz/Path
      Color: 9; 8; 67
      Enabled: true
      Head Diameter: 0.30000001192092896
      Head Length: 0.20000000298023224
      Length: 0.30000001192092896
      Line Style: Lines
      Line Width: 0.029999999329447746
      Name: Path
      Offset:
        X: 0
        Y: 0
        Z: 0
      Pose Color: 255; 85; 255
      Pose Style: None
      Queue Size: 10
      Radius: 0.029999999329447746
      Shaft Diameter: 0.10000000149011612
      Shaft Length: 0.10000000149011612
      Topic: /Base_move/TrajectoryPlannerROS/global_plan
      Unreliable: false
      Value: true
    - Alpha: 0.699999988079071
      Class: rviz/Map
      Color Scheme: map
      Draw Behind: true
      Enabled: true
      Name: Map
      Topic: /map
      Unreliable: false
      Use Timestamp: false
      Value: true
    - Alpha: 0.699999988079071
      Class: rviz/Map
      Color Scheme: costmap
      Draw Behind: false
      Enabled: true
      Name: Map
      Topic: /Base_move/global_costmap/costmap
      Unreliable: false
      Use Timestamp: false
      Value: true
    - Alpha: 0.699999988079071
      Class: rviz/Map
      Color Scheme: raw
      Draw Behind: false
      Enabled: true
      Name: Map
      Topic: /Base_move/local_costmap/costmap
      Unreliable: false
      Use Timestamp: false
      Value: true
    - Alpha: 1
      Class: rviz_plugin_tutorials/Imu
      Color: 204; 51; 204
      Enabled: true
      History Length: 1
      Name: Imu
      Queue Size: 10
      Topic: /imu/data
      Unreliable: false
      Value: true
  Enabled: true
  Global Options:
    Background Color: 48; 48; 48
    Default Light: true
    Fixed Frame: map
    Frame Rate: 60
  Name: root
  Tools:
    - Class: rviz/Interact
      Hide Inactive Objects: true
    - Class: rviz/MoveCamera
    - Class: rviz/Select
    - Class: rviz/FocusCamera
    - Class: rviz/Measure
    - Class: rviz/SetInitialPose
      Theta std deviation: 0.2617993950843811
      Topic: /initialpose
      X std deviation: 0.5
      Y std deviation: 0.5
    - Class: rviz/SetGoal
      Topic: /move_base_simple/goal
    - Class: rviz/PublishPoint
      Single click: true
      Topic: /clicked_point
  Value: true
  Views:
    Current:
      Class: rviz/Orbit
      Distance: 38.24594497680664
      Enable Stereo Rendering:
        Stereo Eye Separation: 0.05999999865889549
        Stereo Focal Distance: 1
        Swap Stereo Eyes: false
        Value: false
      Field of View: 0.7853981852531433
      Focal Point:
        X: 5.44964599609375
        Y: 1.3938180208206177
        Z: -3.0869882106781006
      Focal Shape Fixed Size: true
      Focal Shape Size: 0.05000000074505806
      Invert Z Axis: false
      Name: Current View
      Near Clip Distance: 0.009999999776482582
      Pitch: 0.5147968530654907
      Target Frame: <Fixed Frame>
      Yaw: 3.246746063232422
    Saved: ~
Window Geometry:
  Camera:
    collapsed: false
  Displays:
    collapsed: false
  Height: 1016
  Hide Left Dock: false
  Hide Right Dock: false
  QMainWindow State: 000000ff00000000fd0000000400000000000001560000035afc0200000009fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c006100790073010000003d0000029e000000c900fffffffb0000000c00430061006d00650072006101000002e1000000b60000001600fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261000000010000010f0000035afc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000000a00560069006500770073010000003d0000035a000000a400fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000007380000003efc0100000002fb0000000800540069006d0065010000000000000738000003bc00fffffffb0000000800540069006d00650100000000000004500000000000000000000004c70000035a00000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
  Selection:
    collapsed: false
  Time:
    collapsed: false
  Tool Properties:
    collapsed: false
  Views:
    collapsed: false
  Width: 1848
  X: 72
  Y: 27



================================================
File: script/camera_publisher.py
================================================
#!/usr/bin/env python3
import rospy
import cv2
from sensor_msgs.msg import Image, CameraInfo
from cv_bridge import CvBridge, CvBridgeError

def get_dummy_camera_info(width=640, height=480):
    info = CameraInfo()
    info.width = width
    info.height = height
    info.K = [525, 0, width / 2,
              0, 525, height / 2,
              0, 0, 1]
    info.P = [525, 0, width / 2, 0,
              0, 525, height / 2, 0,
              0, 0, 1, 0]
    info.R = [1, 0, 0,
              0, 1, 0,
              0, 0, 1]
    info.D = [0, 0, 0, 0, 0]
    info.distortion_model = "plumb_bob"
    return info

def main():
    rospy.init_node('camera_publisher', anonymous=True)

    image_pub = rospy.Publisher('/ashwini/camera/rgb/image_raw', Image, queue_size=10)
    info_pub = rospy.Publisher('/ashwini/camera/rgb/camera_info', CameraInfo, queue_size=10)

    bridge = CvBridge()
    cap = cv2.VideoCapture(2)  # Use 1 if external camera

    if not cap.isOpened():
        rospy.logerr("Error: Cannot open camera.")
        return

    # Get width and height of the frame
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    camera_info = get_dummy_camera_info(width, height)

    rate = rospy.Rate(30)

    while not rospy.is_shutdown():
        ret, frame = cap.read()
        if ret:
            try:
                img_msg = bridge.cv2_to_imgmsg(frame, "bgr8")
                timestamp = rospy.Time.now()

                img_msg.header.stamp = timestamp
                img_msg.header.frame_id = "camera"

                camera_info.header.stamp = timestamp
                camera_info.header.frame_id = "camera"

                image_pub.publish(img_msg)
                info_pub.publish(camera_info)
            except CvBridgeError as e:
                rospy.logerr("CvBridge Error: %s", e)
        else:
            rospy.logwarn("Failed to capture image from camera.")
        
        rate.sleep()

    cap.release()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass


================================================
File: script/imu.py
================================================
#!/usr/bin/env python3
import rospy
import tf
from sensor_msgs.msg import Imu
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Twist, PoseWithCovariance, TwistWithCovariance
import subprocess
import serial.tools.list_ports
import threading

# ✅ Your Arduino IMU's serial number
IMU_SERIAL_NUMBER = "343313236353516030E1"

class IMUOdometry:
    def __init__(self):
        # Initialize publishers
        self.odom_pub = rospy.Publisher('/odom', Odometry, queue_size=10)
        self.twist_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
        
        # Initialize odometry message
        self.odom = Odometry()
        self.odom.header.frame_id = "odom"
        self.odom.child_frame_id = "base_link"
        self.odom.pose = PoseWithCovariance()
        self.odom.twist = TwistWithCovariance()
        
        # TF broadcaster
        # self.tf_broadcaster = tf.TransformBroadcaster()

    def publish_odometry(self, imu_msg):
        # Populate odometry message from IMU data
        self.odom.header.stamp = rospy.Time.now()
        
        # Orientation from IMU
        self.odom.pose.pose.orientation = imu_msg.orientation
        
        # Angular velocity (for twist)
        self.odom.twist.twist.angular = imu_msg.angular_velocity
        
        # Publish odometry
        self.odom_pub.publish(self.odom)
        
        # Publish TF transform (odom → base_link)
        # self.tf_broadcaster.sendTransform(
        #     (0, 0, 0),  # No position data from IMU
        #     (
        #         imu_msg.orientation.x,
        #         imu_msg.orientation.y,
        #         imu_msg.orientation.z,
        #         imu_msg.orientation.w
        #     ),
        #     rospy.Time.now(),
        #     "base_link",
        #     "odom"
        # )

def find_port_by_serial(serial_number):
    ports = serial.tools.list_ports.comports()
    for port in ports:
        if port.serial_number == serial_number:
            print(f"✅ Found Arduino with serial {serial_number} on port: {port.device}")
            return port.device
    print(f"❌ Arduino with serial {serial_number} not found.")
    return None

def run_arduino_imu_node(arduino_port):
    try:
        process = subprocess.Popen([
            "rosrun", 
            "rosserial_python", 
            "serial_node.py", 
            f"_port:={arduino_port}", 
            "_baud:=115200"
        ])
        print("🚀 IMU rosserial node started.")
        return process
    except Exception as e:
        print(f"❌ Failed to start rosserial node: {e}")
        return None

def imu_callback(msg, odom_handler):
    # Publish odometry and TF
    odom_handler.publish_odometry(msg)
    
    # Publish twist if needed (optional)
    twist = Twist()
    twist.angular.z = msg.angular_velocity.z
    odom_handler.twist_pub.publish(twist)

if __name__ == "__main__":
    arduino_port = find_port_by_serial(IMU_SERIAL_NUMBER)
    if not arduino_port:
        exit(1)

    # Start rosserial as background process
    rosserial_process = run_arduino_imu_node(arduino_port)
    if not rosserial_process:
        exit(1)

    try:
        rospy.init_node('imu_odometry_node')
        odom_handler = IMUOdometry()
        
        # Set covariance values (adjust based on your IMU's specs)
        odom_handler.odom.pose.covariance = [0.01]*36  # Position covariance
        odom_handler.odom.twist.covariance = [0.01]*36  # Velocity covariance
        
        rospy.Subscriber('/imu/data', Imu, imu_callback, odom_handler)
        rospy.loginfo("IMU Odometry node started!")
        rospy.spin()
        
    except KeyboardInterrupt:
        print("🛑 Shutting down...")
    finally:
        if rosserial_process:
            rosserial_process.terminate()
            rosserial_process.wait()


================================================
File: script/lane_detection.py
================================================
#!/usr/bin/env python3
import rospy
import cv2
import numpy as np
from sensor_msgs.msg import Image
from std_msgs.msg import Float32
from cv_bridge import CvBridge, CvBridgeError

class LaneDetector:
    def __init__(self):
        rospy.init_node('lane_detector', anonymous=True)
        self.bridge = CvBridge()
        self.image_sub = rospy.Subscriber("/ashwini/camera/rgb/image_raw", Image, self.image_callback)
        self.offset_pub = rospy.Publisher("/lane_offset", Float32, queue_size=10)
        rospy.loginfo("Lane Detector initialized using ROI + Contour + Centroid method")

    def image_callback(self, data):
        try:
            frame = self.bridge.imgmsg_to_cv2(data, "bgr8")
        except CvBridgeError as e:
            rospy.logerr(f"CV Bridge Error: {e}")
            return

        height, width, _ = frame.shape

        # 1. Crop ROI (bottom quarter of image)
        roi = frame[int(height * 0.2):, :]

        # 2. Convert to HSV and threshold for white lanes
        hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
        lower_white = np.array([0, 0, 200])
        upper_white = np.array([180, 55, 255])
        mask = cv2.inRange(hsv, lower_white, upper_white)

        # 3. Find contours
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        centroids = []
        for cnt in contours:
            area = cv2.contourArea(cnt)
            if area > 300:  # ignore small noise
                M = cv2.moments(cnt)
                if M["m00"] != 0:
                    cx = int(M["m10"] / M["m00"])
                    cy = int(M["m01"] / M["m00"])
                    centroids.append((cx, cy))
                    # Draw for debug
                    cv2.circle(roi, (cx, cy), 5, (0, 255, 0), -1)

        # 4. Find left and right lane centroids
        if len(centroids) >= 2:
            centroids = sorted(centroids, key=lambda x: x[0])  # sort by x
            left_lane = centroids[0]
            right_lane = centroids[-1]
            lane_center = (left_lane[0] + right_lane[0]) // 2
            image_center = width // 2
            error = image_center - lane_center
            self.offset_pub.publish(Float32(error))

            # Draw info
            cv2.line(roi, (lane_center, 0), (lane_center, roi.shape[0]), (255, 0, 0), 2)
            cv2.line(roi, (image_center, 0), (image_center, roi.shape[0]), (0, 0, 255), 2)
            rospy.loginfo(f"Lane center: {lane_center}, Error: {error}")
        else:
            rospy.logwarn("Did not find two lane lines")

        # Show for debug
        cv2.imshow("Lane ROI", roi)
        cv2.imshow("Mask", mask)
        cv2.waitKey(1)

    def run(self):
        rospy.spin()
        cv2.destroyAllWindows()


if __name__ == '__main__':
    try:
        detector = LaneDetector()
        detector.run()
    except rospy.ROSInterruptException:
        pass



================================================
File: script/lane_follower.py
================================================
#!/usr/bin/env python3
import rospy
from std_msgs.msg import Float32
from geometry_msgs.msg import Twist

class LaneFollower:
    def __init__(self):
        rospy.init_node('lane_follower', anonymous=True)
        # Subscriber to the lane offset error published by lane_detection
        self.offset_sub = rospy.Subscriber("/lane_offset", Float32, self.offset_callback)
        # Publisher to send velocity commands to the robot
        self.cmd_vel_pub = rospy.Publisher("/cmd_vel", Twist, queue_size=10)
        # Set parameters for controlling the robot
        self.linear_speed = rospy.get_param("~linear_speed", 2)
        self.angular_gain = rospy.get_param("~angular_gain", 0.005)
        self.current_error = 0.0
        rospy.loginfo("Lane Follower node started.")

    def offset_callback(self, msg):
        self.current_error = msg.data

    def run(self):
        rate = rospy.Rate(10)
        while not rospy.is_shutdown():
            twist = Twist()
            twist.linear.x = self.linear_speed
            # The angular velocity is proportional to the lane offset error.
            twist.angular.z = self.angular_gain * self.current_error
            self.cmd_vel_pub.publish(twist)
            rate.sleep()

if __name__ == '__main__':
    try:
        lane_follower = LaneFollower()
        lane_follower.run()
    except rospy.ROSInterruptException:
        pass



================================================
File: script/motor_serial.py
================================================
#!/usr/bin/env python3

import rospy
from geometry_msgs.msg import Twist
import serial
import time

class MDDS30Controller:
    def __init__(self):
        self.port = rospy.get_param("~port", "/dev/ttyUSB1")  # Updated to working port
        self.baudrate = rospy.get_param("~baudrate", 9600)
        self.wheel_base = rospy.get_param("~wheel_base", 0.61)  # meters
        self.max_speed = rospy.get_param("~max_speed", 100.0)     # m/s

        try:
            self.ser = serial.Serial(self.port, self.baudrate, timeout=1)
            time.sleep(2)  # Let the serial port settle
            rospy.loginfo("Connected to MDDS30 on %s", self.port)
        except serial.SerialException as e:
            rospy.logerr("Could not open serial port %s: %s", self.port, str(e))
            exit(1)

        rospy.Subscriber("/cmd_vel", Twist, self.cmd_vel_callback)
        rospy.on_shutdown(self.stop_motors)

    def cmd_vel_callback(self, msg):
        v = msg.linear.x * 300
        w = msg.angular.z

        left_speed = v - (w * self.wheel_base / 2)
        right_speed = v + (w * self.wheel_base / 2)
       
        # Clamp and scale speed to range 0–63
        left_cmd = self.make_command_byte(0, left_speed)
        right_cmd = self.make_command_byte(1, right_speed)

        # Log raw speeds and commands
        rospy.loginfo(f"Left Speed: {left_speed:.2f} m/s → Byte: {left_cmd}")
        rospy.loginfo(f"Right Speed: {right_speed:.2f} m/s → Byte: {right_cmd}")

        try:
            self.ser.write(bytes([left_cmd]))
            time.sleep(0.01)
            self.ser.write(bytes([right_cmd]))
        except serial.SerialException as e:
            rospy.logerr("Serial write failed: %s", str(e))

    def make_command_byte(self, motor, speed):
        # motor: 0=Left, 1=Right
        direction = 0 if speed >= 0 else 1
        abs_speed = abs(speed)
        scaled = int((min(abs_speed, self.max_speed) / self.max_speed) * 63)
        scaled = min(scaled, 63)
        return (motor << 7) | (direction << 6) | scaled

    def stop_motors(self):
        rospy.loginfo("Stopping motors")
        try:
            self.ser.write(bytes([0b00000000]))  # Left stop
            time.sleep(0.01)
            self.ser.write(bytes([0b10000000]))  # Right stop
        except serial.SerialException as e:
            rospy.logerr("Failed to stop motors: %s", str(e))

if __name__ == '__main__':
    rospy.init_node('mdds30_cmdvel_controller')
    controller = MDDS30Controller()
    rospy.spin()



================================================
File: script/move_around.py
================================================
#!/usr/bin/env python3

import rospy
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist

class MoveAroundObstacle:
    def __init__(self):
        rospy.init_node('move_around_obstacle', anonymous=True)
        
        self.cmd_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
        rospy.Subscriber('/scan', LaserScan, self.scan_callback)
        
        self.twist = Twist()
        self.obstacle_threshold = 1  # Stop if an obstacle is closer than 0.5m
        self.safe_to_move = True

        self.navigate()

    def scan_callback(self, msg):
        min_distance = min(msg.ranges)  # Get closest object
        rospy.loginfo(f"Min Distance: {min_distance:.2f}m")

        if min_distance < self.obstacle_threshold:
            self.safe_to_move = False  # Start turning
        else:
            self.safe_to_move = True  # Move forward

    def navigate(self):
        rate = rospy.Rate(10)  # 10 Hz
        while not rospy.is_shutdown():
            if self.safe_to_move:
                self.twist.linear.x = 0.2  # Move forward
                self.twist.angular.z = 0.0  # No rotation
            else:
                self.twist.linear.x = 0.0  # Stop moving forward
                self.twist.angular.z = 0.5  # Turn left
            
            self.cmd_pub.publish(self.twist)
            rate.sleep()

if __name__ == '__main__':
    try:
        MoveAroundObstacle()
    except rospy.ROSInterruptException:
        pass



================================================
File: script/move_smart.py
================================================
#!/usr/bin/env python3

import rospy
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist

class MoveStraight:
    def __init__(self):
        rospy.init_node('move_straight', anonymous=True)
        
        self.cmd_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
        rospy.Subscriber('/scan', LaserScan, self.scan_callback)
        
        self.twist = Twist()
        self.obstacle_threshold = 0.5  # Stop if an obstacle is closer than 0.5m
        self.safe_to_move = True

        self.move_forward()

    def scan_callback(self, msg):
        min_distance = min(msg.ranges)  # Get closest object
        rospy.loginfo(f"Min Distance: {min_distance:.2f}m")

        if min_distance < self.obstacle_threshold:
            self.safe_to_move = False  # Stop moving
        else:
            self.safe_to_move = True  # Continue moving

    def move_forward(self):
        rate = rospy.Rate(10)  # 10 Hz
        while not rospy.is_shutdown():
            if self.safe_to_move:
                self.twist.linear.x = 100
                print("chala jaa bsdk")  # Move forward
            else:
                self.twist.linear.x = 0.0
                print("stop baby")  # Stop
            
            self.cmd_pub.publish(self.twist)
            rate.sleep()

if __name__ == '__main__':
    try:
        MoveStraight()
    except rospy.ROSInterruptException:
        pass



================================================
File: script/move_straight.py
================================================
#!/usr/bin/env python3
import rospy
from geometry_msgs.msg import Twist

rospy.init_node("move_straight")
pub = rospy.Publisher("/cmd_vel", Twist, queue_size=10)  # Use correct topic
rate = rospy.Rate(10)

twist = Twist()
twist.linear.x = 0.5  # Move forward

while not rospy.is_shutdown():
    pub.publish(twist)
    rate.sleep()




================================================
File: script/waypoint.py
================================================
#!/usr/bin/env python3
import rospy
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
import actionlib
from tf.transformations import quaternion_from_euler
import math

class WaypointNavigator:
    def __init__(self):
        rospy.init_node('alligator')
        
        # List of waypoints (x, y, yaw_deg)
        self.waypoints = [
            (5.0, 5.0, 0),
            (-5.0, 5.0, 0),
            (-5.0, -5.0, 0),
            (5.0, -5.0, 0)
        ]
        
        self.current_waypoint_index = 0
        self.goal_active = False
        self.client = actionlib.SimpleActionClient('move_base', MoveBaseAction)
        rospy.loginfo("Waiting for move_base action server...")
        
        # Wait for the action server to come up
        if not self.client.wait_for_server(rospy.Duration(5.0)):
            rospy.logerr("Could not connect to move_base server")
            return
            
        rospy.loginfo("Connected to move_base server")
        self.send_next_waypoint()

    def send_next_waypoint(self):
        if self.goal_active:
            rospy.logwarn("Previous goal still active, not sending new waypoint")
            return
            
        if self.current_waypoint_index < len(self.waypoints):
            x, y, yaw_deg = self.waypoints[self.current_waypoint_index]
            self.send_waypoint(x, y, yaw_deg)
        else:
            rospy.loginfo("All waypoints completed!")

    def send_waypoint(self, x, y, yaw_deg=0):
        goal = MoveBaseGoal()
        goal.target_pose.header.frame_id = "map"
        goal.target_pose.header.stamp = rospy.Time.now()

        goal.target_pose.pose.position.x = x
        goal.target_pose.pose.position.y = y
        goal.target_pose.pose.position.z = 0

        yaw = math.radians(yaw_deg)
        q = quaternion_from_euler(0, 0, yaw)

        goal.target_pose.pose.orientation.x = q[0]
        goal.target_pose.pose.orientation.y = q[1]
        goal.target_pose.pose.orientation.z = q[2]
        goal.target_pose.pose.orientation.w = q[3]

        rospy.loginfo(f"Sending waypoint {self.current_waypoint_index + 1}: x={x}, y={y}, yaw={yaw_deg}")
        self.goal_active = True
        self.client.send_goal(goal, done_cb=self.goal_reached_callback)
        self.current_waypoint_index += 1

    def goal_reached_callback(self, status, result):
        self.goal_active = False
        
        if status == actionlib.GoalStatus.SUCCEEDED:
            rospy.loginfo(f"Waypoint {self.current_waypoint_index} reached!")
        else:
            rospy.logwarn(f"Failed to reach waypoint {self.current_waypoint_index}")
        
        # Use a timer to add a small delay before sending next waypoint
        rospy.Timer(rospy.Duration(0.5), self.delayed_next_waypoint, oneshot=True)

    def delayed_next_waypoint(self, event):
        self.send_next_waypoint()

if __name__ == '__main__':
    try:
        navigator = WaypointNavigator()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass



================================================
File: urdf/ashwini.gazebo
================================================
<?xml version="1.0"?>

<robot>

  <gazebo reference="base_link">
      <material>Gazebo/Blue</material>
  </gazebo>

  <gazebo reference="left_drive_wheel_link">
      <material>Gazebo/PurpleGlow</material>
   	  <kp>1000000.0</kp>
  	  <kd>10.0</kd>
      <mu1>1.5</mu1>
      <mu2>1.5</mu2>
      <fdir1>1 0 0</fdir1>
      <maxVel>1.0</maxVel>
      <minDepth>0.00</minDepth>
  </gazebo>

  <!--  -->
  <gazebo reference="right_drive_wheel_link">
      <material>Gazebo/PurpleGlow</material>
      <kp>1000000.0</kp>
      <kd>10.0</kd>
      <mu1>1.5</mu1>
      <mu2>1.5</mu2>
      <fdir1>1 0 0</fdir1>
      <maxVel>1.0</maxVel>
      <minDepth>0.00</minDepth>
  </gazebo>


  <!--  -->
  <gazebo reference="left_castor_wheel_link">
      <material>Gazebo/PurpleGlow</material>
      <!--tags are from: http://gazebosim.org/tutorials/?tut=ros_urdf-->
      <!--These values fixed the robot from bouncing side to side:
          Problem: http://answers.gazebosim.org/question/24459/model-contact-with-ground-issue/
          solution: see: http://answers.gazebosim.org/question/3334/slip1-slip2-in-urdf/-->
      <kp>1000000.0</kp>
      <kd>10.0</kd>
      <mu1>0.0</mu1>
      <mu2>0.0</mu2>
      <fdir1>1 0 0</fdir1>
      <maxVel>1.0</maxVel>
      <minDepth>0.00</minDepth>
  </gazebo>


  <!--  -->
  <gazebo reference="right_castor_wheel_link">
      <material>Gazebo/PurpleGlow</material>
      <!--tags are from: http://gazebosim.org/tutorials/?tut=ros_urdf-->
      <!--These values fixed the robot from bouncing side to side:
          Problem: http://answers.gazebosim.org/question/24459/model-contact-with-ground-issue/
          solution: see: http://answers.gazebosim.org/question/3334/slip1-slip2-in-urdf/-->
      <kp>1000000.0</kp>
      <kd>10.0</kd>
      <mu1>0.0</mu1>
      <mu2>0.0</mu2>
      <fdir1>1 0 0</fdir1>
      <maxVel>1.0</maxVel>
      <minDepth>0.00</minDepth>
  </gazebo>

  
<!--=========================================PLUG-INS======================================-->

  <!--This plugin allows us to run a diff_drive controller in Gazebo -->
    <gazebo>
    <plugin name="differential_drive_controller" filename="libgazebo_ros_diff_drive.so">
      <legacyMode>false</legacyMode>
      <alwaysOn>true</alwaysOn>
      <updateRate>20</updateRate>
      <leftJoint>base_to_left_drive_wheel_joint</leftJoint>
      <rightJoint>base_to_right_drive_wheel_joint</rightJoint>
      <wheelSeparation>0.4</wheelSeparation>
      <wheelDiameter>0.36</wheelDiameter>
      <torque>20</torque>
      <commandTopic>cmd_vel</commandTopic>
      <odometryTopic>odom</odometryTopic>
      <odometryFrame>odom</odometryFrame>
      <robotBaseFrame>base_link</robotBaseFrame>

      <!-- Added missing parameters -->
      <rosDebugLevel>info</rosDebugLevel>
      <publishWheelTF>false</publishWheelTF>
      <publishOdomTF>true</publishOdomTF>
      <publishWheelJointState>true</publishWheelJointState>
      <wheelAcceleration>1.0</wheelAcceleration> <!-- Adjust if needed -->
      <wheelTorque>5.0</wheelTorque> <!-- Adjust if needed -->
      <odometrySource>world</odometrySource> <!-- Use "encoder" if needed -->
      <publishTf>true</publishTf>
    </plugin>
  </gazebo>

  <!-- camera -->
  <gazebo reference="camera">
    <sensor type="camera" name="camera1">
      <update_rate>60.0</update_rate>
      <camera name="head">
        <horizontal_fov>1.36135682</horizontal_fov>
        <image>
          <width>800</width>
          <height>800</height>
          <format>R8G8B8</format>
        </image>
        <clip>
          <near>0.02</near>
          <far>300</far>
        </clip>
      </camera>
      <plugin name="camera_controller" filename="libgazebo_ros_camera.so">
        <robotNamespace>/ashwini</robotNamespace>
        <alwaysOn>true</alwaysOn>
        <updateRate>0.0</updateRate>
        <cameraName>camera</cameraName>
        <imageTopicName>rgb/image_raw</imageTopicName>
        <cameraInfoTopicName>rgb/camera_info</cameraInfoTopicName>
        <frameName>camera</frameName>
        <hackBaseline>0.07</hackBaseline>
        <distortionK1>0.0</distortionK1>
        <distortionK2>0.0</distortionK2>
        <distortionK3>0.0</distortionK3>
        <distortionT1>0.0</distortionT1>
        <distortionT2>0.0</distortionT2>
      </plugin>
    </sensor>
  </gazebo>

  <!-- hokuyo -->
  <gazebo reference="hokuyo">
    <sensor type="ray" name="head_hokuyo_sensor">
      <pose>0 0 0 0 0 0</pose>
      <visualize>true</visualize>
      <update_rate>40</update_rate>
      <ray>
        <scan>
          <horizontal>
            <samples>720</samples>
            <resolution>1</resolution>
            <min_angle>-1.570796</min_angle>
            <max_angle>1.570796</max_angle>
          </horizontal>
        </scan>
        <range>
          <min>0.10</min>
          <max>5.0</max>
          <resolution>0.01</resolution>
        </range>
        <noise>
          <type>gaussian</type>
          <!-- Noise parameters based on published spec for Hokuyo laser
               achieving "+-30mm" accuracy at range < 10m.  A mean of 0.0m and
               stddev of 0.01m will put 99.7% of samples within 0.03m of the true
               reading. -->
          <mean>0.0</mean>
          <stddev>0.01</stddev>
        </noise>
      </ray>
      <plugin name="gazebo_ros_head_hokuyo_controller" filename="libgazebo_ros_laser.so">
        <topicName>/scan</topicName>
        <frameName>hokuyo</frameName>
        <robotNamespace>/ashwini</robotNamespace>
      </plugin>
    </sensor>
  </gazebo>

    
  <gazebo reference="imu_link">
    <gravity>true</gravity>
    <sensor name="imu_sensor" type="imu">
      <always_on>true</always_on>
      <update_rate>100</update_rate>
      <visualize>true</visualize>
      <topic>__default_topic__</topic>
      <plugin filename="libgazebo_ros_imu_sensor.so" name="imu_plugin">
        <topicName>imu</topicName>
        <bodyName>imu_link</bodyName>
        <updateRateHZ>10.0</updateRateHZ>
        <gaussianNoise>0.0</gaussianNoise>
        <xyzOffset>0 0 0</xyzOffset>
        <rpyOffset>0 0 0</rpyOffset>
        <frameName>imu_link</frameName>
        <initialOrientationAsReference>false</initialOrientationAsReference>
      </plugin>
      <pose>0 0 0 0 0 0</pose>
    </sensor>
  </gazebo>




</robot>



================================================
File: urdf/ashwini.xacro
================================================
<?xml version="1.0"?>

<robot name="ashwini" xmlns:xacro="ashwini_description_xacro_namespace">
  <!-- Dummy root link without inertia -->
  <!-- base_footprint is a virtual frame at the ground contact point -->
  <link name="base_footprint" />

  <joint name="base_footprint_joint" type="fixed">
    <parent link="base_footprint" />
    <child link="base_link" />
    <!-- Adjust Z as needed (e.g., half the wheel radius or chassis height) -->
    <origin xyz="0 0 0.216" rpy="0 0 0" />
  </joint>


  <!-- <xacro:include filename="$(find ashwini)/urdf/ashwini.gazebo" /> -->
  <xacro:property name="camera_mass" value="0.1"/>
	<xacro:property name="hokoyu_mass" value="1e-5"/>

  <xacro:property name="base_link_length_width_height" value="0.650 0.381 0.132" />
  <xacro:property name="base_link_length" value="0.650" />
  <xacro:property name="base_link_width" value="0.381" />
  <xacro:property name="base_link_height" value="0.132" />
  <xacro:property name="base_link_mass" value="20"/> <!--25 kg-->
  
  <xacro:property name="drive_wheel_length" value="0.049" />
  <xacro:property name="drive_wheel_radius" value="0.181" />
  <xacro:property name="drive_wheel_mass" value="2"/> <!--2 kg-->

  <xacro:property name="castor_mount_link_length_width_height" value="0.1145 0.10 0.0057" />
  <xacro:property name="castor_mount_link_length" value="0.1145" />
  <xacro:property name="castor_mount_link_width" value="0.10" />
  <xacro:property name="castor_mount_link_height" value="0.0057" />
  <xacro:property name="castor_mount_link_mass" value="0.25"/> <!--0.25 kg-->

  <xacro:property name="castor_mount_dummy_link_length" value="0.02" />
  <xacro:property name="castor_mount_dummy_link_width" value="0.02" />
  <xacro:property name="castor_mount_dummy_link_height" value="0.02" />
  <xacro:property name="castor_mount_dummy_link_mass" value="1.5"/> <!--0.25 kg-->

  <xacro:property name="castor_wheel_length" value="0.049" />
  <xacro:property name="castor_wheel_radius" value="0.07925" />
  <xacro:property name="castor_wheel_mass" value="2"/> <!--2 kg-->

  <xacro:property name="friction_val" value="0.15"/>

  <xacro:macro name="box_link" params="link_name length width height mass *origin">
    <link name="${link_name}_link">
      <!--If you do not explicitly specify a <collision> element. Gazebo will 
      treat your link as "invisible" to laser scanners and collision checking-->
      <collision>
        <geometry>
          <box size="${length} ${width} ${height}"/>
        </geometry>
        <!-- line below allows us to insert:<origin rpy="${rpy}" xyz="${xyz}"/>-->
        <xacro:insert_block name="origin" />
      </collision>
      
      <visual>
        <geometry>
          <!--box dimensions is Meters. L X W X H where the L X H is a ractange, 
              and the H extrudes it upwards -->
          <box size="${length} ${width} ${height}"/>
        </geometry>
        <!-- line below allows us to insert:<origin rpy="${rpy}" xyz="${xyz}"/>-->
        <xacro:insert_block name="origin" />
      </visual>
      
      
      <inertial>
        <!-- line below allows us to insert:<origin rpy="${rpy}" xyz="${xyz}"/>-->
        <xacro:insert_block name="origin" />
        <!--all blocks now need a 'mass' argument-->
        <mass value="${mass}"/>
        <!--This is the 3x3 inertial matrix. See: https://wiki.ros.org/urdf/XML/link -->
        <!--where x=length; y=width; z=height. these lines of code came from 
        Emiliano Borghi's project-->
        <inertia
          ixx="${mass*(width*width+height*height)/12}" 
          ixy = "0" 
          ixz = "0"
          iyy="${mass*(length*length+height*height)/12}" 
          iyz = "0"
          izz="${mass*(length*length+height*height)/12}"/>
        </inertial>      
      
    </link>
  </xacro:macro>

  <xacro:macro name="cylinder_link" params="link_name length radius mass *origin">
    <link name="${link_name}_link">
      <!--If you do not explicitly specify a <collision> element. Gazebo will 
      treat your link as "invisible" to laser scanners and collision checking-->
      <collision>
        <geometry>
          <cylinder length="${length}" radius="${radius}"/>
        </geometry>
        <xacro:insert_block name="origin" />
      </collision>

      <visual>
        <geometry>
          <cylinder length="${length}" radius="${radius}"/>
        </geometry>
          <!-- roll pitch and yaw will move the item in 3D space to arrange it how
               we want it in relation to the origin. the XYZ is to move it around
             the 3D space relative to the origin. Note that 1.57075 is pi/2 -->
        <xacro:insert_block name="origin" />
        
      </visual>
      
      <!--TODO-->
      <inertial>
        <!-- line below allows us to insert:<origin rpy="${rpy}" xyz="${xyz}"/>-->
        <xacro:insert_block name="origin" />
        <!--all blocks now need a 'mass' argument-->
        <mass value="${mass}"/>
        
        <!--This is the 3x3 inertial matrix. See: https://wiki.ros.org/urdf/XML/link -->
        <inertia
          ixx="${mass*(3*radius*radius+length*length)/12}" 
    	  ixy = "0" 
    	  ixz = "0"
    	  iyy="${mass*(3*radius*radius+length*length)/12}" 
    	  iyz = "0"
    	  izz="${mass*radius*radius/2}"
        />
      </inertial>

    </link>
  </xacro:macro>

  <xacro:macro name="continuous_joint" params="name rpy xyz parent child friction *origin">
    <joint name="${name}_joint" type="continuous">
      <axis rpy="${rpy}" xyz="${xyz}"/>
      <parent link="${parent}_link"/>
      <child link="${child}_link"/>
      <!-- this is the point at which the two parts attach to one another    -->
      <xacro:insert_block name="origin" />
      <!--This introduces friction so that continious joints don't spin indefinitly
      damping is only used in Gazebo4 and earlier.... -->
      <dynamics damping="0.0" friction="${friction}"/> 
    </joint>
  </xacro:macro>

  <xacro:macro name="fixed_joint" params="name parent child *origin">
    <joint name="${name}_joint" type="fixed">
      <parent link="${parent}_link"/>
      <child link="${child}_link"/>
      <!-- this is the point at which the two parts attach to one another    -->
      <xacro:insert_block name="origin" />
    </joint>
  </xacro:macro>

  <xacro:box_link link_name="base" length="${base_link_length}"
                                   width="${base_link_width}"
                                   height="${base_link_height}"  mass="${base_link_mass}">
    <!--origin rpy="0 0 0" xyz="-0.325 -0.1905 0.066"/-->
    <origin rpy="0 0 0" xyz="-0.325 -0.1905 0.066"/>
  </xacro:box_link>

  <xacro:cylinder_link link_name="left_drive_wheel" length="${drive_wheel_length}" radius="${drive_wheel_radius}"  mass="${drive_wheel_mass}"> 
    <origin xyz="0 0 0" rpy="${pi/2} 0 0"/> 
  </xacro:cylinder_link>

  <!--        -->
  <xacro:continuous_joint name="base_to_left_drive_wheel" rpy="0 0 0" xyz="0 1 0" parent="base" child="left_drive_wheel" 
                          friction="${friction_val}">
    <origin xyz="-0.05 0.037 -0.035"/>
  </xacro:continuous_joint>

  <!--right_drive_wheel_link is a well named link :-) -->
  <xacro:cylinder_link link_name="right_drive_wheel" length="${drive_wheel_length}" radius="${drive_wheel_radius}"  mass="${drive_wheel_mass}"> 
    <origin xyz="0 0 0" rpy="${pi/2} 0 0"/> 
  </xacro:cylinder_link>

  <!--        -->
  <xacro:continuous_joint name="base_to_right_drive_wheel" rpy="0 0 0" xyz="0 1 0" parent="base" child="right_drive_wheel"
                          friction="${friction_val}">
    <origin xyz="-0.05 -0.421 -0.035"/>
  </xacro:continuous_joint>

  <!--+++++++++++++++++++++++++++++++++++LEFT CASTOR+++++++++++++++++++++++++++++++++++++++++++++++++++-->
  <!--left_caster_mount -->
  <xacro:box_link link_name="left_castor_mount" length="${castor_mount_link_length}" 
                                                width="${castor_mount_link_width}" 
                                                height="${castor_mount_link_height}" 
                                                mass="${castor_mount_link_mass}">  
    <origin xyz="0 0 0" rpy="0 0 0" /> 
  </xacro:box_link>

   <!--joint-->
  <xacro:fixed_joint name="base_to_left_castor_mount" parent="base" child="left_castor_mount">
    <origin xyz="-0.52835 -0.041 -0.03265"/>
  </xacro:fixed_joint>


  <!--left_caster_dummy to give the castor wheel rotation about the Z axis -->
  <xacro:box_link link_name="left_castor_dummy" length="${castor_mount_dummy_link_length}" 
                                                width="${castor_mount_dummy_link_width}" 
                                                height="${castor_mount_dummy_link_height}" 
                                                mass="${castor_mount_dummy_link_mass}">  
    <origin xyz="0 0 0" rpy="0 0 0" /> 
  </xacro:box_link>

  <!--joint between left castor mount and dummy link to allow rotation of castor wheel about z axis-->
  <xacro:continuous_joint name="left_castor_mount_to_left_castor_dummy" rpy="0 0 0" xyz="0 0 1" 
                          parent="left_castor_mount" child="left_castor_dummy" friction="${friction_val}">
    <origin xyz="0.0 0.0 -0.01"/>
  </xacro:continuous_joint>

  <!--left_castor_wheel_link is a well named link :-) -->
  <xacro:cylinder_link link_name="left_castor_wheel" length="${castor_wheel_length}" radius="${castor_wheel_radius}"  mass="${castor_wheel_mass}"> 
    <origin xyz="0 0 0" rpy="${pi/2} 0 0"/> 
  </xacro:cylinder_link>

  <!--        -->
  <xacro:continuous_joint name="left_castor_dummy_to_left_castor_wheel" rpy="0 0 0" xyz="0 1 0" 
                          parent="left_castor_dummy" child="left_castor_wheel" friction="${friction_val}">
    <origin xyz="-0.037 0.0 -0.10785"/>
  </xacro:continuous_joint>

  <!--+++++++++++++++++++++++++++++++++++RIGHT CASTOR+++++++++++++++++++++++++++++++++++++++++++++++++++-->


  <!--right_caster_plate_link is a well named link :-) -->
  <xacro:box_link link_name="right_castor_mount" length="${castor_mount_link_length}" 
                                                 width="${castor_mount_link_width}"
                                                 height="${castor_mount_link_height}" 
                                                 mass="${castor_mount_link_mass}">  
    <origin xyz="0 0 0" rpy="0 0 0" /> 
  </xacro:box_link>

   <!--        -->
  <xacro:fixed_joint name="base_to_right_castor_mount" parent="base" child="right_castor_mount">
    <origin xyz="-0.52835 -0.344 -0.03265"/>
  </xacro:fixed_joint>

  <!--right_caster_dummy to give the castor wheel rotation about the Z axis -->
  <xacro:box_link link_name="right_castor_dummy" length="${castor_mount_dummy_link_length}" 
                                                 width="${castor_mount_dummy_link_width}" 
                                                 height="${castor_mount_dummy_link_height}" 
                                                 mass="${castor_mount_dummy_link_mass}">  
    <origin xyz="0 0 0" rpy="0 0 0" /> 
  </xacro:box_link>

  <!--joint between right castor mount and dummy link to allow rotation of castor wheel about z axis-->
  <xacro:continuous_joint name="right_castor_mount_to_right_castor_dummy" rpy="0 0 0" xyz="0 0 1" 
                          parent="right_castor_mount" child="right_castor_dummy" friction="${friction_val}">
    <origin xyz="0.0 0.0  -0.01"/>
  </xacro:continuous_joint>


  <!--right_castor_wheel_link is a well named link :-) -->
  <xacro:cylinder_link link_name="right_castor_wheel" length="${castor_wheel_length}" radius="${castor_wheel_radius}"
                        mass="${castor_wheel_mass}"> 
    <origin xyz="0 0 0" rpy="${pi/2} 0 0"/> 
  </xacro:cylinder_link>

  <!--        -->
  <xacro:continuous_joint name="right_castor_dummy_to_right_castor_wheel" rpy="0 0 0" xyz="0 1 0" 
                          parent="right_castor_dummy" child="right_castor_wheel" friction="${friction_val}">
    <origin xyz="-0.037 0 -0.10785"/>
  </xacro:continuous_joint>

  <link name="camera">
    <inertial>
      <mass value="${camera_mass}"/>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <inertia
        ixx="1e-6" ixy="0.0" ixz="0.0"
        iyy="1e-6" iyz="0.0"
        izz="1e-6"/>
    </inertial>
    <visual>
      <geometry>
        <box size="0.05 0.05 0.05"/>
      </geometry>
      <origin xyz="0 0 0" rpy="0 0 0"/>
    </visual>
    <collision>
      <geometry>
        <box size="0.05 0.05 0.05"/>
      </geometry>
      <origin xyz="0 0 0" rpy="0 0 0"/>
    </collision>
  </link>

  <joint name="camera_joint" type="fixed">
		<origin xyz="0.006 -0.2 0.4" rpy="0 0.2 0" />
		<parent link="base_link"/>
		<child link="camera" />
		<axis xyz="0 1 0"/>
	</joint>

  <link name="hokuyo">
		<inertial>
			<mass value="${hokoyu_mass}"/>
			<origin xyz="0 0 0" rpy="0 0 0"/>

			<inertia
		        ixx="1e-6" ixy="0.0" ixz="0.0"
		        iyy="1e-6" iyz="0.0"
		        izz="1e-6"
		      />
		</inertial>

		<visual>
			<origin xyz="0 0 0" rpy="0 0 0"/>
			<geometry>
				<mesh filename="package://ashwini/meshes/hokuyo.dae"/>
			</geometry>
		</visual>

		<collision>
			<origin xyz="0 0 0" rpy="0 0 0"/>
			<geometry>
				<box size="0.1 0.1 0.1"/>
			</geometry>
		</collision>
	</link>

  
	<!-- Hokoyu Joint -->
	<joint name="hokuyo_joint" type="fixed">
	    <origin xyz="0.001 -0.2 0.2" rpy="0 0 3.1415592653589793238" />
	    <parent link="base_link"/>
	    <child link="hokuyo" />  
	    <axis xyz="0 1 0"/> 
	</joint>



    <!-- IMU Sensor -->
  <link name="imu_link">
    <inertial>
      <mass value="0.05"/>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <inertia ixx="0.0001" ixy="0.0" ixz="0.0"
               iyy="0.0001" iyz="0.0"
               izz="0.0001"/>
    </inertial>
    <visual>
      <geometry>
        <box size="0.05 0.05 0.02"/>
      </geometry>
      <material name="Blue">
        <color rgba="0.0 0.0 1.0 1.0"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <box size="0.05 0.05 0.02"/>
      </geometry>
    </collision>
  </link>

  <!-- IMU Joint (Attach to Base Link) -->
  <joint name="imu_joint" type="fixed">
    <parent link="base_link"/>
    <child link="imu_link"/>
    <origin xyz="-0.2 -0.2 0.144" rpy="0 0 0"/>
  </joint>

  <link name="odom"/>
  <joint name="odom_to_base" type="fixed">
    <parent link="odom"/>
    <child link="base_footprint"/>
    <origin xyz="0 0 0" rpy="0 0 0"/>
  </joint>


</robot>



================================================
File: worlds/empty.world
================================================
<?xml version="1.0" ?>
<sdf version="1.4">
  <world name="black_ground_world">
    
    <!-- Custom black ground -->
    <model name="black_ground">
      <static>true</static>
      <link name="ground_link">
        <collision name="ground_collision">
          <geometry>
            <plane>
              <size>50 50</size>
            </plane>
          </geometry>
        </collision>
        <visual name="ground_visual">
          <geometry>
            <plane>
              <size>50 50</size>
            </plane>
          </geometry>
          <material>
            <script>
              <uri>file://media/materials/scripts/gazebo.material</uri>
              <name>Gazebo/Black</name>
            </script>
          </material>
        </visual>
      </link>
    </model>

        Central obstacle cluster
    <!-- <model name="obstacle_center">
      <static>true</static>
      <pose>2.0 0 0.25 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.5 0.5 0.5</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.5 0.5 0.5</size>
            </box>
          </geometry>
          <material>
            <ambient>1 0 0 1</ambient>
            <diffuse>1 0 0 1</diffuse>
          </material>
        </visual>
      </link>
    </model> -->

    <!-- Left side obstacles -->
    <!-- <model name="obstacle_left_1">
      <static>true</static>
      <pose>1.0 2 0.25 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.4 0.4 0.5</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.4 0.4 0.5</size>
            </box>
          </geometry>
          <material>
            <ambient>0 1 0 1</ambient>
            <diffuse>0 1 0 1</diffuse>
          </material>
        </visual>
      </link>
    </model> -->

    <!-- <model name="obstacle_left_2">
      <static>true</static>
      <pose>3.0 1.5 0.25 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.3 0.6 0.5</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.3 0.6 0.5</size>
            </box>
          </geometry>
          <material>
            <ambient>0 0 1 1</ambient>
            <diffuse>0 0 1 1</diffuse>
          </material>
        </visual>
      </link>
    </model> -->

    <!-- Right side obstacles -->
    <!-- <model name="obstacle_right_1">
      <static>true</static>
      <pose>1.5 -1.0 0.25 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.6 0.3 0.5</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.6 0.3 0.5</size>
            </box>
          </geometry>
          <material>
            <ambient>1 1 0 1</ambient>
            <diffuse>1 1 0 1</diffuse>
          </material>
        </visual>
      </link>
    </model> -->

    <!-- <model name="obstacle_right_2">
      <static>true</static>
      <pose>3.5 -1.3 0.25 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.5 0.5 0.5</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.5 0.5 0.5</size>
            </box>
          </geometry>
          <material>
            <ambient>1 0 1 1</ambient>
            <diffuse>1 0 1 1</diffuse>
          </material>
        </visual>
      </link>
    </model> -->

    <!-- Narrow passage -->
    <!-- <model name="obstacle_gate_1">
      <static>true</static>
      <pose>5.0 0.5 0.25 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.3 0.3 0.5</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.3 0.3 0.5</size>
            </box>
          </geometry>
          <material>
            <ambient>0 1 1 1</ambient>
            <diffuse>0 1 1 1</diffuse>
          </material>
        </visual>
      </link>
    </model> -->

    <!-- <model name="obstacle_gate_2">
      <static>true</static>
      <pose>5.0 -0.5 0.25 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.3 0.3 0.5</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.3 0.3 0.5</size>
            </box>
          </geometry>
          <material>
            <ambient>0 1 1 1</ambient>
            <diffuse>0 1 1 1</diffuse>
          </material>
        </visual>
      </link>
    </model> -->

    <!-- Light source -->
    <include>
      <uri>model://sun</uri>
    </include>

    <!-- World camera -->
    <gui fullscreen='0'>
      <camera name='world_camera'>
        <pose>4.927360 -4.376610 3.740080 0.000000 0.275643 2.356190</pose>
        <view_controller>orbit</view_controller>
      </camera>
    </gui>
  </world>
</sdf>





================================================
File: src/ashwini/package.xml
================================================
<?xml version="1.0"?>
<package format="2">
  <name>ashwini</name>
  <version>0.0.0</version>
  <description>The ashwini package</description>

  <maintainer email="harsh@todo.todo">harsh</maintainer>

  <license>TODO</license>

  <buildtool_depend>catkin</buildtool_depend>
  <build_depend>message_generation</build_depend>
  <build_depend>roscpp</build_depend>
  <build_depend>rospy</build_depend>
  <build_depend>std_msgs</build_depend>
  <build_depend>sensor_msgs</build_depend>
  <build_depend>opencv2</build_depend>
  <build_depend>cv_bridge</build_depend>
  

  <build_export_depend>roscpp</build_export_depend>
  <build_export_depend>rospy</build_export_depend>
  <build_export_depend>std_msgs</build_export_depend>
  <build_export_depend>sensor_msgs</build_export_depend>
  <build_export_depend>opencv2</build_export_depend>
  <build_export_depend>cv_bridge</build_export_depend>
  
  <depend>geometry_msgs</depend>
  <exec_depend>message_runtime</exec_depend>
  <exec_depend>roscpp</exec_depend>
  <exec_depend>rospy</exec_depend>
  <exec_depend>std_msgs</exec_depend>
  <exec_depend>sensor_msgs</exec_depend>
  <exec_depend>opencv2</exec_depend>
  <exec_depend>cv_bridge</exec_depend>

</package>



================================================
File: src/ashwini/config/costmap_common_params.yaml
================================================
obstacle_range: 6.0
raytrace_range: 8.5
footprint: [[0.3,0.2],[0.3,-0.2],[-0.3,-0.2],[-0.3,0.2]]
map_topic: /map
subscribe_to_update: true
observation_sources: laser_scan_sensor
laser_scan_sensor: {sensor_frame: hokuyo, data_type: LaserScan, topic: /scan, marking: true, clearing: true }
global_frame: map
robot_base_frame: base_link
always_send_full_costmap: true



================================================
File: src/ashwini/config/ekf.yaml
================================================
ekf_node:
  frequency: 30
  sensor_timeout: 0.1
  two_d_mode: true
  publish_tf: true
  map_frame: map
  odom_frame: odom
  base_link_frame: base_link
  world_frame: odom

  imu0: imu/data
  imu0_config: [false, false, false,  # x, y, z pos
                false, false, false,  # x, y, z vel
                false, false, true,   # x, y, z ori
                false, false, true]   # x, y, z ang vel
  imu0_differential: false
  imu0_remove_gravitational_acceleration: true

  use_control: false



================================================
File: src/ashwini/config/global_costmap_params.yaml
================================================
global_costmap:
  update_frequency: 2.5
  publish_frequency: 2.5
  transform_tolerance: 2.1
  static_map: true
  rolling_window: false 
  width: 50
  height: 50
  origin_x: -7.5
  origin_y: -7.5
  resolution: 0.1
  inflation_radius: 2.5

  
 


================================================
File: src/ashwini/config/local_costmap_params.yaml
================================================
local_costmap:
  update_frequency: 5
  publish_frequency: 5
  transform_tolerance: 1.25
  static_map: false
  rolling_window: true
  width: 3
  height: 3
  origin_x: -1.5
  origin_y: -1.5
  resolution: 0.1
  inflation_radius: 0.6


================================================
File: src/ashwini/config/rplidar_filter.yaml
================================================
scan_filter_chain:
  - name: angle_filter
    type: laser_filters/ScanAngleFilter
    params:
      lower_angle: -1.5708  # -90 degrees
      upper_angle: 1.5708   # 90 degrees

  - name: range_filter
    type: laser_filters/ScanRangeFilter
    params:
      lower_threshold: 3.0
      upper_threshold: 7.5



================================================
File: src/ashwini/config/trajectory_planner.yaml
================================================
TrajectoryPlannerROS:
  max_vel_x: 1
  min_vel_x: 0.5
  max_vel_theta: 0.35
  min_vel_theta: -0.35
  min_in_place_vel_theta: 0
  escape_vel: -0.1             # ← allow moving backward if really stuck

  acc_lim_theta: 0.25
  acc_lim_X: 2.5
  acc_lim_Y: 2.5
  
  holonomic_robot: false
  meter_scoring: true

  xy_goal_tolerance: 0.5
  yaw_goal_tolerance: 1
    



================================================
File: src/ashwini/launch/lane.launch
================================================
<launch>
  <!-- Launch lane detection node -->
  <node pkg="ashwini" type="lane_detection.py" name="lane_detection" output="screen" />

  <!-- Launch lane follower node -->
  <node pkg="ashwini" type="lane_follower.py" name="lane_follower" output="screen">
    <!-- You can adjust parameters here -->

  </node>
</launch>


================================================
File: src/ashwini/launch/move_base.launch
================================================
<?xml version="1.0"?>
<launch>

    <node pkg="gmapping" type="slam_gmapping" name="maping_node">
        <param name="base_frame" value="base_link" />
        <param name="odom_frame" value="odom" />
        <param name="delta" value="0.1" />
    </node>

    <node pkg="move_base" type="move_base" name="Base_move" output="screen">
        <param name="controller_frequency" value="10.0" />
        <rosparam file="$(find ashwini)/config/trajectory_planner.yaml" command="load" />
        <rosparam file="$(find ashwini)/config/costmap_common_params.yaml" command="load" ns="global_costmap"/>
        <rosparam file="$(find ashwini)/config/costmap_common_params.yaml" command="load" ns="local_costmap"/>
        <rosparam file="$(find ashwini)/config/local_costmap_params.yaml" command="load" />
        <rosparam file="$(find ashwini)/config/global_costmap_params.yaml" command="load" />
    </node>

</launch>


================================================
File: src/ashwini/launch/real.launch
================================================
<?xml version="1.0" encoding="UTF-8"?>

<launch>
	<arg name="robot_name" default="ashwini"/>

	<include file="$(find ashwini)/launch/robot_description.launch"/>
	<include file="$(find ashwini)/launch/move_base.launch"/>

	<node name="rviz" pkg="rviz" type="rviz" respawn="false"
		args="-d $(find ashwini)/rviz/real.rviz"/>

	<node pkg="rplidar_ros" type="rplidarNode" name="rplidarNode" output="screen">
		<param name="serial_port" value="/dev/ttyUSB0"/>
		<param name="serial_baudrate" value="256000"/>
		<param name="frame_id" value="hokuyo"/>
		<param name="angle_compensate" type="bool" value="true"/>
    </node>

	<rosparam command="load" file="$(find ashwini)/config/laser_filter.yaml" />
	<node pkg="laser_filters" type="scan_to_scan_filter_chain" name="scan_filter" />

	<node pkg="robot_localization" type="ekf_localization_node" name="ekf_filter_node" output="screen">
		<rosparam file="$(find ashwini)/config/ekf.yaml" command="load" />
	</node>

	<node pkg="ashwini" type="imu.py" name="imu_node" output="screen"/>

	<node pkg="ashwini" type="camera_publisher.py" name="camera_node" output="screen"/>

    
</launch>



================================================
File: src/ashwini/launch/robot_description.launch
================================================
<?xml version="1.0"?>
<launch>

    <!-- send urdf to param server -->
    <param name="robot_description" command="$(find xacro)/xacro --inorder '$(find ashwini)/urdf/ashwini.xacro'" />

    <!-- Send fake joint values-->
    <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher">
        <param name="use_gui" value="false"/>
        <param name="publish_default_positions" value="true"/>
    </node>

    <!-- Send robot states to tf -->
    <node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher" respawn="false" output="screen">
	    <param name="publish_frequency" type="double" value="50.0" />
	</node>

</launch>



================================================
File: src/ashwini/launch/simulation.launch
================================================
<?xml version="1.0" encoding="UTF-8"?>

<launch>
	<arg name="robot_name" default="ashwini"/>

	<include file="$(find ashwini)/launch/robot_description.launch"/>
	<include file="$(find ashwini)/launch/move_base.launch"/>
	
	<arg name="world_file" default="$(find ashwini)/worlds/empty.world"/>

	<include file="$(find gazebo_ros)/launch/empty_world.launch">
		<arg name="use_sim_time" value="true"/>
		<arg name="verbose" value="false"/>
		<arg name="debug" value="false"/>
		<arg name="gui" value="true" />
		<arg name="world_name" value="$(arg world_file)"/>
	</include>
	
	<node name="urdf_spawner" pkg="gazebo_ros" type="spawn_model" respawn="false" output="screen"
		args="-urdf -param robot_description -model ashwini
			  -x 6 -y 4 -z 0.23
			  -R 0 -P 0 -Y 0"/>

	<node name="rviz" pkg="rviz" type="rviz" respawn="false"
		args="-d $(find ashwini)/rviz/default.rviz"/>

	<node name="spawn_lane_overlay" pkg="gazebo_ros" type="spawn_model" output="screen"
	args="-file $(find ashwini)/models/lane_overlay/model.sdf -sdf -model lane_overlay -x 0 -y 0 -z 0.01"/>
	
	<!-- <node pkg="ashwini" type="imu.py" name="imu_node" output="screen"/> -->

</launch>



================================================
File: src/ashwini/launch/suryatest.launch
================================================
<launch>

	<arg name="robot_name" default="ashwini"/>

	<include file="$(find ashwini)/launch/robot_description.launch"/>
	<include file="$(find ashwini)/launch/move_base.launch"/>

	<node name="rviz" pkg="rviz" type="rviz" respawn="false"
		args="-d $(find ashwini)/rviz/real.rviz"/>

	<node pkg="rplidar_ros" type="rplidarNode" name="rplidarNode" output="screen">
		<param name="serial_port" value="/dev/ttyUSB0"/>
		<param name="serial_baudrate" value="256000"/>
		<param name="frame_id" value="hokuyo"/>
		<param name="angle_compensate" type="bool" value="true"/>
    </node>

	<!-- <rosparam command="load" file="$(find ashwini)/config/rplidar_filter.yaml" /> -->
	<!-- <node pkg="laser_filters" type="scan_to_scan_filter_chain" name="scan_filter" /> -->

	<node pkg="robot_localization" type="ekf_localization_node" name="ekf_filter_node" output="screen">
		<rosparam file="$(find ashwini)/config/ekf.yaml" command="load" />
	</node>

	<node pkg="ashwini" type="imu.py" name="imu_node" output="screen"/>

	<!-- <node pkg="ashwini" type="camera_publisher.py" name="camera_node" output="screen"/> -->

  <node pkg="ashwini" type="motor_serial.py" name="tungtungtungsahur" output="screen"/>

</launch>



================================================
File: src/ashwini/models/cool_model/model.config
================================================
<?xml version="1.0" ?>
<model>
  <name>cool_model</name>
  <version>1.0</version>
  <sdf version="1.6">model.sdf</sdf>
  <author>
    <name>Your Name</name>
    <email>you@example.com</email>
  </author>
  <description>A DAE model with flat red color</description>
</model>




================================================
File: src/ashwini/models/cool_model/model.sdf
================================================
<?xml version="1.0" ?>
<sdf version="1.6">
  <model name="cool_model">
    <static>true</static>
    <pose>0 0 0 -1.5708 0 0</pose>
    <link name="map_link">
      <visual name="map_visual">
        <geometry>
          <mesh>
            <uri>model://cool_model/meshes/mapfinal.dae</uri>
            <scale>0.01 0.01 0.01</scale>
          </mesh>
        </geometry>
      </visual>
      <collision name="map_collision">
        <geometry>
          <mesh>
            <uri>model://cool_model/meshes/mapfinal.dae</uri>
            <!-- <scale>0.01 0.01 0.01</scale> -->
          </mesh>
        </geometry>
      </collision>
    </link>
  </model>
</sdf>




================================================
File: src/ashwini/models/cool_model/materials/scripts/plain.material
================================================
material MyMaterial/Red
{
  technique
  {
    pass
    {
      ambient 1.0 0.0 0.0 1.0
      diffuse 1.0 0.0 0.0 1.0
      specular 0.5 0.5 0.5 1.0
    }
  }
}






================================================
File: src/ashwini/models/lane_overlay/model.config
================================================
<?xml version="1.0"?>
<model>
  <name>lane_overlay</name>
  <version>1.0</version>
  <sdf version="1.6">model.sdf</sdf>
  <author>
    <name>Utheo</name>
    <email>you@example.com</email>
  </author>
  <description>
    Lane overlay texture model.
  </description>
</model>




================================================
File: src/ashwini/models/lane_overlay/model.sdf
================================================
<?xml version="1.0" ?>
<sdf version="1.6">
  <model name="lane_overlay">
    <static>true</static>
    <link name="lane_plane_link">
      <visual name="lane_plane_visual">
        <geometry>
          <plane>
            <normal>0 0 1</normal>
            <size>70 70</size>
          </plane>
        </geometry>
        <material>
          <script>
            <uri>model://lane_overlay/materials/scripts</uri>
            <uri>model://lane_overlay/materials/textures</uri>
            <name>lane_overlay/lanetex</name>
          </script>
        </material>
      </visual>
      <collision name="lane_plane_collision">
        <geometry>
          <plane>
            <normal>0 0 1</normal>
            <size>70 70</size>
          </plane>
        </geometry>
      </collision>
    </link>
  </model>
</sdf>




================================================
File: src/ashwini/models/lane_overlay/materials/scripts/lanetex.material
================================================
material lane_overlay/lanetex
{
  receive_shadows on
  technique
  {
    pass
    {
      texture_unit
      {
        texture lane_image.png
        filtering anisotropic
        max_anisotropy 16
      }
    }
  }
}





================================================
File: src/ashwini/rviz/default.rviz
================================================
Panels:
  - Class: rviz/Displays
    Help Height: 78
    Name: Displays
    Property Tree Widget:
      Expanded:
        - /Imu1
      Splitter Ratio: 0.5058823823928833
    Tree Height: 531
  - Class: rviz/Selection
    Name: Selection
  - Class: rviz/Tool Properties
    Expanded:
      - /2D Pose Estimate1
      - /2D Nav Goal1
      - /Publish Point1
    Name: Tool Properties
    Splitter Ratio: 0.5886790156364441
  - Class: rviz/Views
    Expanded:
      - /Current View1
    Name: Views
    Splitter Ratio: 0.5
  - Class: rviz/Time
    Name: Time
    SyncMode: 0
    SyncSource: LaserScan
Preferences:
  PromptSaveOnExit: true
Toolbars:
  toolButtonStyle: 2
Visualization Manager:
  Class: ""
  Displays:
    - Alpha: 0.5
      Cell Size: 1
      Class: rviz/Grid
      Color: 160; 160; 164
      Enabled: true
      Line Style:
        Line Width: 0.029999999329447746
        Value: Lines
      Name: Grid
      Normal Cell Count: 0
      Offset:
        X: 0
        Y: 0
        Z: 0
      Plane: XY
      Plane Cell Count: 100
      Reference Frame: <Fixed Frame>
      Value: true
    - Class: rviz/Camera
      Enabled: true
      Image Rendering: background and overlay
      Image Topic: /ashwini/camera/rgb/image_raw
      Name: Camera
      Overlay Alpha: 0.5
      Queue Size: 2
      Transport Hint: raw
      Unreliable: false
      Value: true
      Visibility:
        Grid: true
        Imu: true
        LaserScan: true
        Map: true
        Path: true
        RobotModel: true
        TF: true
        Value: true
      Zoom Factor: 1
    - Alpha: 1
      Autocompute Intensity Bounds: true
      Autocompute Value Bounds:
        Max Value: 10
        Min Value: -10
        Value: true
      Axis: Z
      Channel Name: intensity
      Class: rviz/LaserScan
      Color: 255; 255; 255
      Color Transformer: Intensity
      Decay Time: 0
      Enabled: true
      Invert Rainbow: false
      Max Color: 255; 255; 255
      Min Color: 0; 0; 0
      Name: LaserScan
      Position Transformer: XYZ
      Queue Size: 10
      Selectable: true
      Size (Pixels): 3
      Size (m): 0.009999999776482582
      Style: Flat Squares
      Topic: /scan
      Unreliable: false
      Use Fixed Frame: true
      Use rainbow: true
      Value: true
    - Alpha: 1
      Class: rviz/RobotModel
      Collision Enabled: false
      Enabled: true
      Links:
        All Links Enabled: true
        Expand Joint Details: false
        Expand Link Details: false
        Expand Tree: false
        Link Tree Style: Links in Alphabetic Order
        base_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        camera:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        hokuyo:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        imu_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_castor_dummy_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_castor_mount_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_castor_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_drive_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        right_castor_dummy_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        right_castor_mount_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        right_castor_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        right_drive_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
      Name: RobotModel
      Robot Description: robot_description
      TF Prefix: ""
      Update Interval: 0
      Value: true
      Visual Enabled: true
    - Class: rviz/TF
      Enabled: false
      Filter (blacklist): ""
      Filter (whitelist): ""
      Frame Timeout: 15
      Frames:
        All Enabled: true
      Marker Alpha: 1
      Marker Scale: 1
      Name: TF
      Show Arrows: true
      Show Axes: true
      Show Names: true
      Tree:
        {}
      Update Interval: 0
      Value: false
    - Alpha: 1
      Buffer Length: 1
      Class: rviz/Path
      Color: 206; 92; 0
      Enabled: true
      Head Diameter: 0.30000001192092896
      Head Length: 0.20000000298023224
      Length: 0.30000001192092896
      Line Style: Lines
      Line Width: 0.029999999329447746
      Name: Path
      Offset:
        X: 0
        Y: 0
        Z: 0
      Pose Color: 255; 85; 255
      Pose Style: None
      Queue Size: 10
      Radius: 0.029999999329447746
      Shaft Diameter: 0.10000000149011612
      Shaft Length: 0.10000000149011612
      Topic: /Base_move/TrajectoryPlannerROS/local_plan
      Unreliable: false
      Value: true
    - Alpha: 1
      Buffer Length: 1
      Class: rviz/Path
      Color: 9; 8; 67
      Enabled: true
      Head Diameter: 0.30000001192092896
      Head Length: 0.20000000298023224
      Length: 0.30000001192092896
      Line Style: Lines
      Line Width: 0.029999999329447746
      Name: Path
      Offset:
        X: 0
        Y: 0
        Z: 0
      Pose Color: 255; 85; 255
      Pose Style: None
      Queue Size: 10
      Radius: 0.029999999329447746
      Shaft Diameter: 0.10000000149011612
      Shaft Length: 0.10000000149011612
      Topic: /Base_move/TrajectoryPlannerROS/global_plan
      Unreliable: false
      Value: true
    - Alpha: 0.699999988079071
      Class: rviz/Map
      Color Scheme: map
      Draw Behind: true
      Enabled: true
      Name: Map
      Topic: /map
      Unreliable: false
      Use Timestamp: false
      Value: true
    - Alpha: 0.699999988079071
      Class: rviz/Map
      Color Scheme: costmap
      Draw Behind: false
      Enabled: true
      Name: Map
      Topic: /Base_move/global_costmap/costmap
      Unreliable: false
      Use Timestamp: false
      Value: true
    - Alpha: 0.699999988079071
      Class: rviz/Map
      Color Scheme: raw
      Draw Behind: false
      Enabled: true
      Name: Map
      Topic: /Base_move/local_costmap/costmap
      Unreliable: false
      Use Timestamp: false
      Value: true
  Enabled: true
  Global Options:
    Background Color: 48; 48; 48
    Default Light: true
    Fixed Frame: map
    Frame Rate: 60
  Name: root
  Tools:
    - Class: rviz/Interact
      Hide Inactive Objects: true
    - Class: rviz/MoveCamera
    - Class: rviz/Select
    - Class: rviz/FocusCamera
    - Class: rviz/Measure
    - Class: rviz/SetInitialPose
      Theta std deviation: 0.2617993950843811
      Topic: /initialpose
      X std deviation: 0.5
      Y std deviation: 0.5
    - Class: rviz/SetGoal
      Topic: /move_base_simple/goal
    - Class: rviz/PublishPoint
      Single click: true
      Topic: /clicked_point
  Value: true
  Views:
    Current:
      Class: rviz/Orbit
      Distance: 32.96086883544922
      Enable Stereo Rendering:
        Stereo Eye Separation: 0.05999999865889549
        Stereo Focal Distance: 1
        Swap Stereo Eyes: false
        Value: false
      Field of View: 0.7853981852531433
      Focal Point:
        X: 7.145931243896484
        Y: 2.9171111583709717
        Z: -0.09273505210876465
      Focal Shape Fixed Size: true
      Focal Shape Size: 0.05000000074505806
      Invert Z Axis: false
      Name: Current View
      Near Clip Distance: 0.009999999776482582
      Pitch: 0.5297966599464417
      Target Frame: <Fixed Frame>
      Yaw: 2.9867522716522217
    Saved: ~
Window Geometry:
  Camera:
    collapsed: false
  Displays:
    collapsed: false
  Height: 1016
  Hide Left Dock: false
  Hide Right Dock: false
  QMainWindow State: 000000ff00000000fd0000000400000000000001560000035afc0200000009fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c006100790073010000003d0000029e000000c900fffffffb0000000c00430061006d00650072006101000002e1000000b60000001600fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261000000010000010f0000035afc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000000a00560069006500770073010000003d0000035a000000a400fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000007380000003efc0100000002fb0000000800540069006d0065010000000000000738000003bc00fffffffb0000000800540069006d00650100000000000004500000000000000000000004c70000035a00000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
  Selection:
    collapsed: false
  Time:
    collapsed: false
  Tool Properties:
    collapsed: false
  Views:
    collapsed: false
  Width: 1848
  X: 72
  Y: 27



================================================
File: src/ashwini/rviz/real.rviz
================================================
Panels:
  - Class: rviz/Displays
    Help Height: 78
    Name: Displays
    Property Tree Widget:
      Expanded:
        - /Global Options1
        - /Imu1
      Splitter Ratio: 0.5058823823928833
    Tree Height: 531
  - Class: rviz/Selection
    Name: Selection
  - Class: rviz/Tool Properties
    Expanded:
      - /2D Pose Estimate1
      - /2D Nav Goal1
      - /Publish Point1
    Name: Tool Properties
    Splitter Ratio: 0.5886790156364441
  - Class: rviz/Views
    Expanded:
      - /Current View1
    Name: Views
    Splitter Ratio: 0.5
  - Class: rviz/Time
    Name: Time
    SyncMode: 0
    SyncSource: LaserScan
Preferences:
  PromptSaveOnExit: true
Toolbars:
  toolButtonStyle: 2
Visualization Manager:
  Class: ""
  Displays:
    - Alpha: 0.5
      Cell Size: 1
      Class: rviz/Grid
      Color: 160; 160; 164
      Enabled: true
      Line Style:
        Line Width: 0.029999999329447746
        Value: Lines
      Name: Grid
      Normal Cell Count: 0
      Offset:
        X: 0
        Y: 0
        Z: 0
      Plane: XY
      Plane Cell Count: 100
      Reference Frame: <Fixed Frame>
      Value: true
    - Class: rviz/Camera
      Enabled: true
      Image Rendering: background and overlay
      Image Topic: /ashwini/camera/rgb/image_raw
      Name: Camera
      Overlay Alpha: 0.5
      Queue Size: 2
      Transport Hint: raw
      Unreliable: false
      Value: true
      Visibility:
        Grid: true
        Imu: true
        LaserScan: true
        Map: true
        Path: true
        RobotModel: true
        TF: true
        Value: true
      Zoom Factor: 1
    - Alpha: 1
      Autocompute Intensity Bounds: true
      Autocompute Value Bounds:
        Max Value: 10
        Min Value: -10
        Value: true
      Axis: Z
      Channel Name: intensity
      Class: rviz/LaserScan
      Color: 255; 255; 255
      Color Transformer: Intensity
      Decay Time: 0
      Enabled: true
      Invert Rainbow: false
      Max Color: 255; 255; 255
      Min Color: 0; 0; 0
      Name: LaserScan
      Position Transformer: XYZ
      Queue Size: 10
      Selectable: true
      Size (Pixels): 3
      Size (m): 0.009999999776482582
      Style: Flat Squares
      Topic: /scan
      Unreliable: false
      Use Fixed Frame: true
      Use rainbow: true
      Value: true
    - Alpha: 1
      Class: rviz/RobotModel
      Collision Enabled: false
      Enabled: true
      Links:
        All Links Enabled: true
        Expand Joint Details: false
        Expand Link Details: false
        Expand Tree: false
        Link Tree Style: Links in Alphabetic Order
        base_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        camera:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        hokuyo:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        imu:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_castor_dummy_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_castor_mount_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_castor_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        left_drive_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        odom:
          Alpha: 1
          Show Axes: false
          Show Trail: false
        right_castor_dummy_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        right_castor_mount_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        right_castor_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
        right_drive_wheel_link:
          Alpha: 1
          Show Axes: false
          Show Trail: false
          Value: true
      Name: RobotModel
      Robot Description: robot_description
      TF Prefix: ""
      Update Interval: 0
      Value: true
      Visual Enabled: true
    - Class: rviz/TF
      Enabled: false
      Filter (blacklist): ""
      Filter (whitelist): ""
      Frame Timeout: 15
      Frames:
        All Enabled: true
      Marker Alpha: 1
      Marker Scale: 1
      Name: TF
      Show Arrows: true
      Show Axes: true
      Show Names: true
      Tree:
        {}
      Update Interval: 0
      Value: false
    - Alpha: 1
      Buffer Length: 1
      Class: rviz/Path
      Color: 206; 92; 0
      Enabled: true
      Head Diameter: 0.30000001192092896
      Head Length: 0.20000000298023224
      Length: 0.30000001192092896
      Line Style: Lines
      Line Width: 0.029999999329447746
      Name: Path
      Offset:
        X: 0
        Y: 0
        Z: 0
      Pose Color: 255; 85; 255
      Pose Style: None
      Queue Size: 10
      Radius: 0.029999999329447746
      Shaft Diameter: 0.10000000149011612
      Shaft Length: 0.10000000149011612
      Topic: /Base_move/TrajectoryPlannerROS/local_plan
      Unreliable: false
      Value: true
    - Alpha: 1
      Buffer Length: 1
      Class: rviz/Path
      Color: 9; 8; 67
      Enabled: true
      Head Diameter: 0.30000001192092896
      Head Length: 0.20000000298023224
      Length: 0.30000001192092896
      Line Style: Lines
      Line Width: 0.029999999329447746
      Name: Path
      Offset:
        X: 0
        Y: 0
        Z: 0
      Pose Color: 255; 85; 255
      Pose Style: None
      Queue Size: 10
      Radius: 0.029999999329447746
      Shaft Diameter: 0.10000000149011612
      Shaft Length: 0.10000000149011612
      Topic: /Base_move/TrajectoryPlannerROS/global_plan
      Unreliable: false
      Value: true
    - Alpha: 0.699999988079071
      Class: rviz/Map
      Color Scheme: map
      Draw Behind: true
      Enabled: true
      Name: Map
      Topic: /map
      Unreliable: false
      Use Timestamp: false
      Value: true
    - Alpha: 0.699999988079071
      Class: rviz/Map
      Color Scheme: costmap
      Draw Behind: false
      Enabled: true
      Name: Map
      Topic: /Base_move/global_costmap/costmap
      Unreliable: false
      Use Timestamp: false
      Value: true
    - Alpha: 0.699999988079071
      Class: rviz/Map
      Color Scheme: raw
      Draw Behind: false
      Enabled: true
      Name: Map
      Topic: /Base_move/local_costmap/costmap
      Unreliable: false
      Use Timestamp: false
      Value: true
    - Alpha: 1
      Class: rviz_plugin_tutorials/Imu
      Color: 204; 51; 204
      Enabled: true
      History Length: 1
      Name: Imu
      Queue Size: 10
      Topic: /imu/data
      Unreliable: false
      Value: true
  Enabled: true
  Global Options:
    Background Color: 48; 48; 48
    Default Light: true
    Fixed Frame: map
    Frame Rate: 60
  Name: root
  Tools:
    - Class: rviz/Interact
      Hide Inactive Objects: true
    - Class: rviz/MoveCamera
    - Class: rviz/Select
    - Class: rviz/FocusCamera
    - Class: rviz/Measure
    - Class: rviz/SetInitialPose
      Theta std deviation: 0.2617993950843811
      Topic: /initialpose
      X std deviation: 0.5
      Y std deviation: 0.5
    - Class: rviz/SetGoal
      Topic: /move_base_simple/goal
    - Class: rviz/PublishPoint
      Single click: true
      Topic: /clicked_point
  Value: true
  Views:
    Current:
      Class: rviz/Orbit
      Distance: 38.24594497680664
      Enable Stereo Rendering:
        Stereo Eye Separation: 0.05999999865889549
        Stereo Focal Distance: 1
        Swap Stereo Eyes: false
        Value: false
      Field of View: 0.7853981852531433
      Focal Point:
        X: 5.44964599609375
        Y: 1.3938180208206177
        Z: -3.0869882106781006
      Focal Shape Fixed Size: true
      Focal Shape Size: 0.05000000074505806
      Invert Z Axis: false
      Name: Current View
      Near Clip Distance: 0.009999999776482582
      Pitch: 0.5147968530654907
      Target Frame: <Fixed Frame>
      Yaw: 3.246746063232422
    Saved: ~
Window Geometry:
  Camera:
    collapsed: false
  Displays:
    collapsed: false
  Height: 1016
  Hide Left Dock: false
  Hide Right Dock: false
  QMainWindow State: 000000ff00000000fd0000000400000000000001560000035afc0200000009fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c006100790073010000003d0000029e000000c900fffffffb0000000c00430061006d00650072006101000002e1000000b60000001600fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261000000010000010f0000035afc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000000a00560069006500770073010000003d0000035a000000a400fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000007380000003efc0100000002fb0000000800540069006d0065010000000000000738000003bc00fffffffb0000000800540069006d00650100000000000004500000000000000000000004c70000035a00000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
  Selection:
    collapsed: false
  Time:
    collapsed: false
  Tool Properties:
    collapsed: false
  Views:
    collapsed: false
  Width: 1848
  X: 72
  Y: 27



================================================
File: src/ashwini/script/camera_publisher.py
================================================
#!/usr/bin/env python3
import rospy
import cv2
from sensor_msgs.msg import Image, CameraInfo
from cv_bridge import CvBridge, CvBridgeError

def get_dummy_camera_info(width=640, height=480):
    info = CameraInfo()
    info.width = width
    info.height = height
    info.K = [525, 0, width / 2,
              0, 525, height / 2,
              0, 0, 1]
    info.P = [525, 0, width / 2, 0,
              0, 525, height / 2, 0,
              0, 0, 1, 0]
    info.R = [1, 0, 0,
              0, 1, 0,
              0, 0, 1]
    info.D = [0, 0, 0, 0, 0]
    info.distortion_model = "plumb_bob"
    return info

def main():
    rospy.init_node('camera_publisher', anonymous=True)

    image_pub = rospy.Publisher('/ashwini/camera/rgb/image_raw', Image, queue_size=10)
    info_pub = rospy.Publisher('/ashwini/camera/rgb/camera_info', CameraInfo, queue_size=10)

    bridge = CvBridge()
    cap = cv2.VideoCapture(2)  # Use 1 if external camera

    if not cap.isOpened():
        rospy.logerr("Error: Cannot open camera.")
        return

    # Get width and height of the frame
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    camera_info = get_dummy_camera_info(width, height)

    rate = rospy.Rate(30)

    while not rospy.is_shutdown():
        ret, frame = cap.read()
        if ret:
            try:
                img_msg = bridge.cv2_to_imgmsg(frame, "bgr8")
                timestamp = rospy.Time.now()

                img_msg.header.stamp = timestamp
                img_msg.header.frame_id = "camera"

                camera_info.header.stamp = timestamp
                camera_info.header.frame_id = "camera"

                image_pub.publish(img_msg)
                info_pub.publish(camera_info)
            except CvBridgeError as e:
                rospy.logerr("CvBridge Error: %s", e)
        else:
            rospy.logwarn("Failed to capture image from camera.")
        
        rate.sleep()

    cap.release()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass


================================================
File: src/ashwini/script/imu.py
================================================
#!/usr/bin/env python3
import rospy
import tf
from sensor_msgs.msg import Imu
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Twist, PoseWithCovariance, TwistWithCovariance
import subprocess
import serial.tools.list_ports
import threading

# ✅ Your Arduino IMU's serial number
IMU_SERIAL_NUMBER = "343313236353516030E1"

class IMUOdometry:
    def __init__(self):
        # Initialize publishers
        self.odom_pub = rospy.Publisher('/odom', Odometry, queue_size=10)
        self.twist_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
        
        # Initialize odometry message
        self.odom = Odometry()
        self.odom.header.frame_id = "odom"
        self.odom.child_frame_id = "base_link"
        self.odom.pose = PoseWithCovariance()
        self.odom.twist = TwistWithCovariance()
        
        # TF broadcaster
        # self.tf_broadcaster = tf.TransformBroadcaster()

    def publish_odometry(self, imu_msg):
        # Populate odometry message from IMU data
        self.odom.header.stamp = rospy.Time.now()
        
        # Orientation from IMU
        self.odom.pose.pose.orientation = imu_msg.orientation
        
        # Angular velocity (for twist)
        self.odom.twist.twist.angular = imu_msg.angular_velocity
        
        # Publish odometry
        self.odom_pub.publish(self.odom)
        
        # Publish TF transform (odom → base_link)
        # self.tf_broadcaster.sendTransform(
        #     (0, 0, 0),  # No position data from IMU
        #     (
        #         imu_msg.orientation.x,
        #         imu_msg.orientation.y,
        #         imu_msg.orientation.z,
        #         imu_msg.orientation.w
        #     ),
        #     rospy.Time.now(),
        #     "base_link",
        #     "odom"
        # )

def find_port_by_serial(serial_number):
    ports = serial.tools.list_ports.comports()
    for port in ports:
        if port.serial_number == serial_number:
            print(f"✅ Found Arduino with serial {serial_number} on port: {port.device}")
            return port.device
    print(f"❌ Arduino with serial {serial_number} not found.")
    return None

def run_arduino_imu_node(arduino_port):
    try:
        process = subprocess.Popen([
            "rosrun", 
            "rosserial_python", 
            "serial_node.py", 
            f"_port:={arduino_port}", 
            "_baud:=115200"
        ])
        print("🚀 IMU rosserial node started.")
        return process
    except Exception as e:
        print(f"❌ Failed to start rosserial node: {e}")
        return None

def imu_callback(msg, odom_handler):
    # Publish odometry and TF
    odom_handler.publish_odometry(msg)
    
    # Publish twist if needed (optional)
    twist = Twist()
    twist.angular.z = msg.angular_velocity.z
    odom_handler.twist_pub.publish(twist)

if __name__ == "__main__":
    arduino_port = find_port_by_serial(IMU_SERIAL_NUMBER)
    if not arduino_port:
        exit(1)

    # Start rosserial as background process
    rosserial_process = run_arduino_imu_node(arduino_port)
    if not rosserial_process:
        exit(1)

    try:
        rospy.init_node('imu_odometry_node')
        odom_handler = IMUOdometry()
        
        # Set covariance values (adjust based on your IMU's specs)
        odom_handler.odom.pose.covariance = [0.01]*36  # Position covariance
        odom_handler.odom.twist.covariance = [0.01]*36  # Velocity covariance
        
        rospy.Subscriber('/imu/data', Imu, imu_callback, odom_handler)
        rospy.loginfo("IMU Odometry node started!")
        rospy.spin()
        
    except KeyboardInterrupt:
        print("🛑 Shutting down...")
    finally:
        if rosserial_process:
            rosserial_process.terminate()
            rosserial_process.wait()


================================================
File: src/ashwini/script/lane_detection.py
================================================
#!/usr/bin/env python3
import rospy
import cv2
import numpy as np
from sensor_msgs.msg import Image
from std_msgs.msg import Float32
from cv_bridge import CvBridge, CvBridgeError

class LaneDetector:
    def __init__(self):
        rospy.init_node('lane_detector', anonymous=True)
        self.bridge = CvBridge()
        self.image_sub = rospy.Subscriber("/ashwini/camera/rgb/image_raw", Image, self.image_callback)
        self.offset_pub = rospy.Publisher("/lane_offset", Float32, queue_size=10)
        rospy.loginfo("Lane Detector initialized using ROI + Contour + Centroid method")

    def image_callback(self, data):
        try:
            frame = self.bridge.imgmsg_to_cv2(data, "bgr8")
        except CvBridgeError as e:
            rospy.logerr(f"CV Bridge Error: {e}")
            return

        height, width, _ = frame.shape

        # 1. Crop ROI (bottom quarter of image)
        roi = frame[int(height * 0.2):, :]

        # 2. Convert to HSV and threshold for white lanes
        hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
        lower_white = np.array([0, 0, 200])
        upper_white = np.array([180, 55, 255])
        mask = cv2.inRange(hsv, lower_white, upper_white)

        # 3. Find contours
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        centroids = []
        for cnt in contours:
            area = cv2.contourArea(cnt)
            if area > 300:  # ignore small noise
                M = cv2.moments(cnt)
                if M["m00"] != 0:
                    cx = int(M["m10"] / M["m00"])
                    cy = int(M["m01"] / M["m00"])
                    centroids.append((cx, cy))
                    # Draw for debug
                    cv2.circle(roi, (cx, cy), 5, (0, 255, 0), -1)

        # 4. Find left and right lane centroids
        if len(centroids) >= 2:
            centroids = sorted(centroids, key=lambda x: x[0])  # sort by x
            left_lane = centroids[0]
            right_lane = centroids[-1]
            lane_center = (left_lane[0] + right_lane[0]) // 2
            image_center = width // 2
            error = image_center - lane_center
            self.offset_pub.publish(Float32(error))

            # Draw info
            cv2.line(roi, (lane_center, 0), (lane_center, roi.shape[0]), (255, 0, 0), 2)
            cv2.line(roi, (image_center, 0), (image_center, roi.shape[0]), (0, 0, 255), 2)
            rospy.loginfo(f"Lane center: {lane_center}, Error: {error}")
        else:
            rospy.logwarn("Did not find two lane lines")

        # Show for debug
        cv2.imshow("Lane ROI", roi)
        cv2.imshow("Mask", mask)
        cv2.waitKey(1)

    def run(self):
        rospy.spin()
        cv2.destroyAllWindows()


if __name__ == '__main__':
    try:
        detector = LaneDetector()
        detector.run()
    except rospy.ROSInterruptException:
        pass



================================================
File: src/ashwini/script/lane_follower.py
================================================
#!/usr/bin/env python3
import rospy
from std_msgs.msg import Float32
from geometry_msgs.msg import Twist

class LaneFollower:
    def __init__(self):
        rospy.init_node('lane_follower', anonymous=True)
        # Subscriber to the lane offset error published by lane_detection
        self.offset_sub = rospy.Subscriber("/lane_offset", Float32, self.offset_callback)
        # Publisher to send velocity commands to the robot
        self.cmd_vel_pub = rospy.Publisher("/cmd_vel", Twist, queue_size=10)
        # Set parameters for controlling the robot
        self.linear_speed = rospy.get_param("~linear_speed", 2)
        self.angular_gain = rospy.get_param("~angular_gain", 0.005)
        self.current_error = 0.0
        rospy.loginfo("Lane Follower node started.")

    def offset_callback(self, msg):
        self.current_error = msg.data

    def run(self):
        rate = rospy.Rate(10)
        while not rospy.is_shutdown():
            twist = Twist()
            twist.linear.x = self.linear_speed
            # The angular velocity is proportional to the lane offset error.
            twist.angular.z = self.angular_gain * self.current_error
            self.cmd_vel_pub.publish(twist)
            rate.sleep()

if __name__ == '__main__':
    try:
        lane_follower = LaneFollower()
        lane_follower.run()
    except rospy.ROSInterruptException:
        pass



================================================
File: src/ashwini/script/motor_serial.py
================================================
#!/usr/bin/env python3

import rospy
from geometry_msgs.msg import Twist
import serial
import time

class MDDS30Controller:
    def __init__(self):
        self.port = rospy.get_param("~port", "/dev/ttyUSB1")  # Updated to working port
        self.baudrate = rospy.get_param("~baudrate", 9600)
        self.wheel_base = rospy.get_param("~wheel_base", 0.61)  # meters
        self.max_speed = rospy.get_param("~max_speed", 500.0)     # m/s

        try:
            self.ser = serial.Serial(self.port, self.baudrate, timeout=1)
            time.sleep(2)  # Let the serial port settle
            rospy.loginfo("Connected to MDDS30 on %s", self.port)
        except serial.SerialException as e:
            rospy.logerr("Could not open serial port %s: %s", self.port, str(e))
            exit(1)

        rospy.Subscriber("/cmd_vel", Twist, self.cmd_vel_callback)
        rospy.on_shutdown(self.stop_motors)

    def cmd_vel_callback(self, msg):
        v = msg.linear.x * 1000
        w = msg.angular.z

        left_speed = v - (w * self.wheel_base / 2)
        right_speed = v + (w * self.wheel_base / 2)
       
        # Clamp and scale speed to range 0–63
        left_cmd = self.make_command_byte(0, left_speed)
        right_cmd = self.make_command_byte(1, right_speed)

        # Log raw speeds and commands
        rospy.loginfo(f"Left Speed: {left_speed:.2f} m/s → Byte: {left_cmd}")
        rospy.loginfo(f"Right Speed: {right_speed:.2f} m/s → Byte: {right_cmd}")

        try:
            self.ser.write(bytes([left_cmd]))
            time.sleep(0.01)
            self.ser.write(bytes([right_cmd]))
        except serial.SerialException as e:
            rospy.logerr("Serial write failed: %s", str(e))

    def make_command_byte(self, motor, speed):
        # motor: 0=Left, 1=Right
        direction = 0 if speed >= 0 else 1
        abs_speed = abs(speed)
        scaled = int((min(abs_speed, self.max_speed) / self.max_speed) * 63)
        scaled = min(scaled, 63)
        return (motor << 7) | (direction << 6) | scaled

    def stop_motors(self):
        rospy.loginfo("Stopping motors")
        try:
            self.ser.write(bytes([0b00000000]))  # Left stop
            time.sleep(0.01)
            self.ser.write(bytes([0b10000000]))  # Right stop
        except serial.SerialException as e:
            rospy.logerr("Failed to stop motors: %s", str(e))

if __name__ == '__main__':
    rospy.init_node('mdds30_cmdvel_controller')
    controller = MDDS30Controller()
    rospy.spin()



================================================
File: src/ashwini/script/move_around.py
================================================
#!/usr/bin/env python3

import rospy
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist

class MoveAroundObstacle:
    def __init__(self):
        rospy.init_node('move_around_obstacle', anonymous=True)
        
        self.cmd_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
        rospy.Subscriber('/scan', LaserScan, self.scan_callback)
        
        self.twist = Twist()
        self.obstacle_threshold = 1  # Stop if an obstacle is closer than 0.5m
        self.safe_to_move = True

        self.navigate()

    def scan_callback(self, msg):
        min_distance = min(msg.ranges)  # Get closest object
        rospy.loginfo(f"Min Distance: {min_distance:.2f}m")

        if min_distance < self.obstacle_threshold:
            self.safe_to_move = False  # Start turning
        else:
            self.safe_to_move = True  # Move forward

    def navigate(self):
        rate = rospy.Rate(10)  # 10 Hz
        while not rospy.is_shutdown():
            if self.safe_to_move:
                self.twist.linear.x = 0.2  # Move forward
                self.twist.angular.z = 0.0  # No rotation
            else:
                self.twist.linear.x = 0.0  # Stop moving forward
                self.twist.angular.z = 0.5  # Turn left
            
            self.cmd_pub.publish(self.twist)
            rate.sleep()

if __name__ == '__main__':
    try:
        MoveAroundObstacle()
    except rospy.ROSInterruptException:
        pass



================================================
File: src/ashwini/script/move_smart.py
================================================
#!/usr/bin/env python3

import rospy
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist

class MoveStraight:
    def __init__(self):
        rospy.init_node('move_straight', anonymous=True)
        
        self.cmd_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
        rospy.Subscriber('/scan', LaserScan, self.scan_callback)
        
        self.twist = Twist()
        self.obstacle_threshold = 0.5  # Stop if an obstacle is closer than 0.5m
        self.safe_to_move = True

        self.move_forward()

    def scan_callback(self, msg):
        min_distance = min(msg.ranges)  # Get closest object
        rospy.loginfo(f"Min Distance: {min_distance:.2f}m")

        if min_distance < self.obstacle_threshold:
            self.safe_to_move = False  # Stop moving
        else:
            self.safe_to_move = True  # Continue moving

    def move_forward(self):
        rate = rospy.Rate(10)  # 10 Hz
        while not rospy.is_shutdown():
            if self.safe_to_move:
                self.twist.linear.x = 100
                print("chala jaa bsdk")  # Move forward
            else:
                self.twist.linear.x = 0.0
                print("stop baby")  # Stop
            
            self.cmd_pub.publish(self.twist)
            rate.sleep()

if __name__ == '__main__':
    try:
        MoveStraight()
    except rospy.ROSInterruptException:
        pass



================================================
File: src/ashwini/script/move_straight.py
================================================
#!/usr/bin/env python3
import rospy
from geometry_msgs.msg import Twist

rospy.init_node("move_straight")
pub = rospy.Publisher("/cmd_vel", Twist, queue_size=10)  # Use correct topic
rate = rospy.Rate(10)

twist = Twist()
twist.linear.x = 0.5  # Move forward

while not rospy.is_shutdown():
    pub.publish(twist)
    rate.sleep()




================================================
File: src/ashwini/script/waypoint.py
================================================
#!/usr/bin/env python3
import rospy
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
import actionlib
from tf.transformations import quaternion_from_euler
import math

class WaypointNavigator:
    def __init__(self):
        rospy.init_node('alligator')
        
        # List of waypoints (x, y, yaw_deg)
        self.waypoints = [
            (5.0, 5.0, 0),
            (-5.0, 5.0, 0),
            (-5.0, -5.0, 0),
            (5.0, -5.0, 0)
        ]
        
        self.current_waypoint_index = 0
        self.goal_active = False
        self.client = actionlib.SimpleActionClient('move_base', MoveBaseAction)
        rospy.loginfo("Waiting for move_base action server...")
        
        # Wait for the action server to come up
        if not self.client.wait_for_server(rospy.Duration(5.0)):
            rospy.logerr("Could not connect to move_base server")
            return
            
        rospy.loginfo("Connected to move_base server")
        self.send_next_waypoint()

    def send_next_waypoint(self):
        if self.goal_active:
            rospy.logwarn("Previous goal still active, not sending new waypoint")
            return
            
        if self.current_waypoint_index < len(self.waypoints):
            x, y, yaw_deg = self.waypoints[self.current_waypoint_index]
            self.send_waypoint(x, y, yaw_deg)
        else:
            rospy.loginfo("All waypoints completed!")

    def send_waypoint(self, x, y, yaw_deg=0):
        goal = MoveBaseGoal()
        goal.target_pose.header.frame_id = "map"
        goal.target_pose.header.stamp = rospy.Time.now()

        goal.target_pose.pose.position.x = x
        goal.target_pose.pose.position.y = y
        goal.target_pose.pose.position.z = 0

        yaw = math.radians(yaw_deg)
        q = quaternion_from_euler(0, 0, yaw)

        goal.target_pose.pose.orientation.x = q[0]
        goal.target_pose.pose.orientation.y = q[1]
        goal.target_pose.pose.orientation.z = q[2]
        goal.target_pose.pose.orientation.w = q[3]

        rospy.loginfo(f"Sending waypoint {self.current_waypoint_index + 1}: x={x}, y={y}, yaw={yaw_deg}")
        self.goal_active = True
        self.client.send_goal(goal, done_cb=self.goal_reached_callback)
        self.current_waypoint_index += 1

    def goal_reached_callback(self, status, result):
        self.goal_active = False
        
        if status == actionlib.GoalStatus.SUCCEEDED:
            rospy.loginfo(f"Waypoint {self.current_waypoint_index} reached!")
        else:
            rospy.logwarn(f"Failed to reach waypoint {self.current_waypoint_index}")
        
        # Use a timer to add a small delay before sending next waypoint
        rospy.Timer(rospy.Duration(0.5), self.delayed_next_waypoint, oneshot=True)

    def delayed_next_waypoint(self, event):
        self.send_next_waypoint()

if __name__ == '__main__':
    try:
        navigator = WaypointNavigator()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass



================================================
File: src/ashwini/urdf/ashwini.gazebo
================================================
<?xml version="1.0"?>

<robot>

  <gazebo reference="base_link">
      <material>Gazebo/Blue</material>
  </gazebo>

  <gazebo reference="left_drive_wheel_link">
      <material>Gazebo/PurpleGlow</material>
   	  <kp>1000000.0</kp>
  	  <kd>10.0</kd>
      <mu1>1.5</mu1>
      <mu2>1.5</mu2>
      <fdir1>1 0 0</fdir1>
      <maxVel>1.0</maxVel>
      <minDepth>0.00</minDepth>
  </gazebo>

  <!--  -->
  <gazebo reference="right_drive_wheel_link">
      <material>Gazebo/PurpleGlow</material>
      <kp>1000000.0</kp>
      <kd>10.0</kd>
      <mu1>1.5</mu1>
      <mu2>1.5</mu2>
      <fdir1>1 0 0</fdir1>
      <maxVel>1.0</maxVel>
      <minDepth>0.00</minDepth>
  </gazebo>


  <!--  -->
  <gazebo reference="left_castor_wheel_link">
      <material>Gazebo/PurpleGlow</material>
      <!--tags are from: http://gazebosim.org/tutorials/?tut=ros_urdf-->
      <!--These values fixed the robot from bouncing side to side:
          Problem: http://answers.gazebosim.org/question/24459/model-contact-with-ground-issue/
          solution: see: http://answers.gazebosim.org/question/3334/slip1-slip2-in-urdf/-->
      <kp>1000000.0</kp>
      <kd>10.0</kd>
      <mu1>0.0</mu1>
      <mu2>0.0</mu2>
      <fdir1>1 0 0</fdir1>
      <maxVel>1.0</maxVel>
      <minDepth>0.00</minDepth>
  </gazebo>


  <!--  -->
  <gazebo reference="right_castor_wheel_link">
      <material>Gazebo/PurpleGlow</material>
      <!--tags are from: http://gazebosim.org/tutorials/?tut=ros_urdf-->
      <!--These values fixed the robot from bouncing side to side:
          Problem: http://answers.gazebosim.org/question/24459/model-contact-with-ground-issue/
          solution: see: http://answers.gazebosim.org/question/3334/slip1-slip2-in-urdf/-->
      <kp>1000000.0</kp>
      <kd>10.0</kd>
      <mu1>0.0</mu1>
      <mu2>0.0</mu2>
      <fdir1>1 0 0</fdir1>
      <maxVel>1.0</maxVel>
      <minDepth>0.00</minDepth>
  </gazebo>

  
<!--=========================================PLUG-INS======================================-->

  <!--This plugin allows us to run a diff_drive controller in Gazebo -->
    <gazebo>
    <plugin name="differential_drive_controller" filename="libgazebo_ros_diff_drive.so">
      <legacyMode>false</legacyMode>
      <alwaysOn>true</alwaysOn>
      <updateRate>20</updateRate>
      <leftJoint>base_to_left_drive_wheel_joint</leftJoint>
      <rightJoint>base_to_right_drive_wheel_joint</rightJoint>
      <wheelSeparation>0.4</wheelSeparation>
      <wheelDiameter>0.36</wheelDiameter>
      <torque>20</torque>
      <commandTopic>cmd_vel</commandTopic>
      <odometryTopic>odom</odometryTopic>
      <odometryFrame>odom</odometryFrame>
      <robotBaseFrame>base_link</robotBaseFrame>

      <!-- Added missing parameters -->
      <rosDebugLevel>info</rosDebugLevel>
      <publishWheelTF>false</publishWheelTF>
      <publishOdomTF>true</publishOdomTF>
      <publishWheelJointState>true</publishWheelJointState>
      <wheelAcceleration>1.0</wheelAcceleration> <!-- Adjust if needed -->
      <wheelTorque>5.0</wheelTorque> <!-- Adjust if needed -->
      <odometrySource>world</odometrySource> <!-- Use "encoder" if needed -->
      <publishTf>true</publishTf>
    </plugin>
  </gazebo>

  <!-- camera -->
  <gazebo reference="camera">
    <sensor type="camera" name="camera1">
      <update_rate>60.0</update_rate>
      <camera name="head">
        <horizontal_fov>1.36135682</horizontal_fov>
        <image>
          <width>800</width>
          <height>800</height>
          <format>R8G8B8</format>
        </image>
        <clip>
          <near>0.02</near>
          <far>300</far>
        </clip>
      </camera>
      <plugin name="camera_controller" filename="libgazebo_ros_camera.so">
        <robotNamespace>/ashwini</robotNamespace>
        <alwaysOn>true</alwaysOn>
        <updateRate>0.0</updateRate>
        <cameraName>camera</cameraName>
        <imageTopicName>rgb/image_raw</imageTopicName>
        <cameraInfoTopicName>rgb/camera_info</cameraInfoTopicName>
        <frameName>camera</frameName>
        <hackBaseline>0.07</hackBaseline>
        <distortionK1>0.0</distortionK1>
        <distortionK2>0.0</distortionK2>
        <distortionK3>0.0</distortionK3>
        <distortionT1>0.0</distortionT1>
        <distortionT2>0.0</distortionT2>
      </plugin>
    </sensor>
  </gazebo>

  <!-- hokuyo -->
  <gazebo reference="hokuyo">
    <sensor type="ray" name="head_hokuyo_sensor">
      <pose>0 0 0 0 0 0</pose>
      <visualize>true</visualize>
      <update_rate>40</update_rate>
      <ray>
        <scan>
          <horizontal>
            <samples>720</samples>
            <resolution>1</resolution>
            <min_angle>-1.570796</min_angle>
            <max_angle>1.570796</max_angle>
          </horizontal>
        </scan>
        <range>
          <min>0.10</min>
          <max>5.0</max>
          <resolution>0.01</resolution>
        </range>
        <noise>
          <type>gaussian</type>
          <!-- Noise parameters based on published spec for Hokuyo laser
               achieving "+-30mm" accuracy at range < 10m.  A mean of 0.0m and
               stddev of 0.01m will put 99.7% of samples within 0.03m of the true
               reading. -->
          <mean>0.0</mean>
          <stddev>0.01</stddev>
        </noise>
      </ray>
      <plugin name="gazebo_ros_head_hokuyo_controller" filename="libgazebo_ros_laser.so">
        <topicName>/scan</topicName>
        <frameName>hokuyo</frameName>
        <robotNamespace>/ashwini</robotNamespace>
      </plugin>
    </sensor>
  </gazebo>

    
  <gazebo reference="imu_link">
    <gravity>true</gravity>
    <sensor name="imu_sensor" type="imu">
      <always_on>true</always_on>
      <update_rate>100</update_rate>
      <visualize>true</visualize>
      <topic>__default_topic__</topic>
      <plugin filename="libgazebo_ros_imu_sensor.so" name="imu_plugin">
        <topicName>imu</topicName>
        <bodyName>imu_link</bodyName>
        <updateRateHZ>10.0</updateRateHZ>
        <gaussianNoise>0.0</gaussianNoise>
        <xyzOffset>0 0 0</xyzOffset>
        <rpyOffset>0 0 0</rpyOffset>
        <frameName>imu_link</frameName>
        <initialOrientationAsReference>false</initialOrientationAsReference>
      </plugin>
      <pose>0 0 0 0 0 0</pose>
    </sensor>
  </gazebo>




</robot>



================================================
File: src/ashwini/urdf/ashwini.xacro
================================================
<?xml version="1.0"?>

<robot name="ashwini" xmlns:xacro="ashwini_description_xacro_namespace">
  <!-- Dummy root link without inertia -->
  <!-- base_footprint is a virtual frame at the ground contact point -->
  <link name="base_footprint" />

  <joint name="base_footprint_joint" type="fixed">
    <parent link="base_footprint" />
    <child link="base_link" />
    <!-- Adjust Z as needed (e.g., half the wheel radius or chassis height) -->
    <origin xyz="0 0 0.216" rpy="0 0 0" />
  </joint>


  <!-- <xacro:include filename="$(find ashwini)/urdf/ashwini.gazebo" /> -->
  <xacro:property name="camera_mass" value="0.1"/>
	<xacro:property name="hokoyu_mass" value="1e-5"/>

  <xacro:property name="base_link_length_width_height" value="0.650 0.381 0.132" />
  <xacro:property name="base_link_length" value="0.650" />
  <xacro:property name="base_link_width" value="0.381" />
  <xacro:property name="base_link_height" value="0.132" />
  <xacro:property name="base_link_mass" value="20"/> <!--25 kg-->
  
  <xacro:property name="drive_wheel_length" value="0.049" />
  <xacro:property name="drive_wheel_radius" value="0.181" />
  <xacro:property name="drive_wheel_mass" value="2"/> <!--2 kg-->

  <xacro:property name="castor_mount_link_length_width_height" value="0.1145 0.10 0.0057" />
  <xacro:property name="castor_mount_link_length" value="0.1145" />
  <xacro:property name="castor_mount_link_width" value="0.10" />
  <xacro:property name="castor_mount_link_height" value="0.0057" />
  <xacro:property name="castor_mount_link_mass" value="0.25"/> <!--0.25 kg-->

  <xacro:property name="castor_mount_dummy_link_length" value="0.02" />
  <xacro:property name="castor_mount_dummy_link_width" value="0.02" />
  <xacro:property name="castor_mount_dummy_link_height" value="0.02" />
  <xacro:property name="castor_mount_dummy_link_mass" value="1.5"/> <!--0.25 kg-->

  <xacro:property name="castor_wheel_length" value="0.049" />
  <xacro:property name="castor_wheel_radius" value="0.07925" />
  <xacro:property name="castor_wheel_mass" value="2"/> <!--2 kg-->

  <xacro:property name="friction_val" value="0.15"/>

  <xacro:macro name="box_link" params="link_name length width height mass *origin">
    <link name="${link_name}_link">
      <!--If you do not explicitly specify a <collision> element. Gazebo will 
      treat your link as "invisible" to laser scanners and collision checking-->
      <collision>
        <geometry>
          <box size="${length} ${width} ${height}"/>
        </geometry>
        <!-- line below allows us to insert:<origin rpy="${rpy}" xyz="${xyz}"/>-->
        <xacro:insert_block name="origin" />
      </collision>
      
      <visual>
        <geometry>
          <!--box dimensions is Meters. L X W X H where the L X H is a ractange, 
              and the H extrudes it upwards -->
          <box size="${length} ${width} ${height}"/>
        </geometry>
        <!-- line below allows us to insert:<origin rpy="${rpy}" xyz="${xyz}"/>-->
        <xacro:insert_block name="origin" />
      </visual>
      
      
      <inertial>
        <!-- line below allows us to insert:<origin rpy="${rpy}" xyz="${xyz}"/>-->
        <xacro:insert_block name="origin" />
        <!--all blocks now need a 'mass' argument-->
        <mass value="${mass}"/>
        <!--This is the 3x3 inertial matrix. See: https://wiki.ros.org/urdf/XML/link -->
        <!--where x=length; y=width; z=height. these lines of code came from 
        Emiliano Borghi's project-->
        <inertia
          ixx="${mass*(width*width+height*height)/12}" 
          ixy = "0" 
          ixz = "0"
          iyy="${mass*(length*length+height*height)/12}" 
          iyz = "0"
          izz="${mass*(length*length+height*height)/12}"/>
        </inertial>      
      
    </link>
  </xacro:macro>

  <xacro:macro name="cylinder_link" params="link_name length radius mass *origin">
    <link name="${link_name}_link">
      <!--If you do not explicitly specify a <collision> element. Gazebo will 
      treat your link as "invisible" to laser scanners and collision checking-->
      <collision>
        <geometry>
          <cylinder length="${length}" radius="${radius}"/>
        </geometry>
        <xacro:insert_block name="origin" />
      </collision>

      <visual>
        <geometry>
          <cylinder length="${length}" radius="${radius}"/>
        </geometry>
          <!-- roll pitch and yaw will move the item in 3D space to arrange it how
               we want it in relation to the origin. the XYZ is to move it around
             the 3D space relative to the origin. Note that 1.57075 is pi/2 -->
        <xacro:insert_block name="origin" />
        
      </visual>
      
      <!--TODO-->
      <inertial>
        <!-- line below allows us to insert:<origin rpy="${rpy}" xyz="${xyz}"/>-->
        <xacro:insert_block name="origin" />
        <!--all blocks now need a 'mass' argument-->
        <mass value="${mass}"/>
        
        <!--This is the 3x3 inertial matrix. See: https://wiki.ros.org/urdf/XML/link -->
        <inertia
          ixx="${mass*(3*radius*radius+length*length)/12}" 
    	  ixy = "0" 
    	  ixz = "0"
    	  iyy="${mass*(3*radius*radius+length*length)/12}" 
    	  iyz = "0"
    	  izz="${mass*radius*radius/2}"
        />
      </inertial>

    </link>
  </xacro:macro>

  <xacro:macro name="continuous_joint" params="name rpy xyz parent child friction *origin">
    <joint name="${name}_joint" type="continuous">
      <axis rpy="${rpy}" xyz="${xyz}"/>
      <parent link="${parent}_link"/>
      <child link="${child}_link"/>
      <!-- this is the point at which the two parts attach to one another    -->
      <xacro:insert_block name="origin" />
      <!--This introduces friction so that continious joints don't spin indefinitly
      damping is only used in Gazebo4 and earlier.... -->
      <dynamics damping="0.0" friction="${friction}"/> 
    </joint>
  </xacro:macro>

  <xacro:macro name="fixed_joint" params="name parent child *origin">
    <joint name="${name}_joint" type="fixed">
      <parent link="${parent}_link"/>
      <child link="${child}_link"/>
      <!-- this is the point at which the two parts attach to one another    -->
      <xacro:insert_block name="origin" />
    </joint>
  </xacro:macro>

  <xacro:box_link link_name="base" length="${base_link_length}"
                                   width="${base_link_width}"
                                   height="${base_link_height}"  mass="${base_link_mass}">
    <!--origin rpy="0 0 0" xyz="-0.325 -0.1905 0.066"/-->
    <origin rpy="0 0 0" xyz="-0.325 -0.1905 0.066"/>
  </xacro:box_link>

  <xacro:cylinder_link link_name="left_drive_wheel" length="${drive_wheel_length}" radius="${drive_wheel_radius}"  mass="${drive_wheel_mass}"> 
    <origin xyz="0 0 0" rpy="${pi/2} 0 0"/> 
  </xacro:cylinder_link>

  <!--        -->
  <xacro:continuous_joint name="base_to_left_drive_wheel" rpy="0 0 0" xyz="0 1 0" parent="base" child="left_drive_wheel" 
                          friction="${friction_val}">
    <origin xyz="-0.05 0.037 -0.035"/>
  </xacro:continuous_joint>

  <!--right_drive_wheel_link is a well named link :-) -->
  <xacro:cylinder_link link_name="right_drive_wheel" length="${drive_wheel_length}" radius="${drive_wheel_radius}"  mass="${drive_wheel_mass}"> 
    <origin xyz="0 0 0" rpy="${pi/2} 0 0"/> 
  </xacro:cylinder_link>

  <!--        -->
  <xacro:continuous_joint name="base_to_right_drive_wheel" rpy="0 0 0" xyz="0 1 0" parent="base" child="right_drive_wheel"
                          friction="${friction_val}">
    <origin xyz="-0.05 -0.421 -0.035"/>
  </xacro:continuous_joint>

  <!--+++++++++++++++++++++++++++++++++++LEFT CASTOR+++++++++++++++++++++++++++++++++++++++++++++++++++-->
  <!--left_caster_mount -->
  <xacro:box_link link_name="left_castor_mount" length="${castor_mount_link_length}" 
                                                width="${castor_mount_link_width}" 
                                                height="${castor_mount_link_height}" 
                                                mass="${castor_mount_link_mass}">  
    <origin xyz="0 0 0" rpy="0 0 0" /> 
  </xacro:box_link>

   <!--joint-->
  <xacro:fixed_joint name="base_to_left_castor_mount" parent="base" child="left_castor_mount">
    <origin xyz="-0.52835 -0.041 -0.03265"/>
  </xacro:fixed_joint>


  <!--left_caster_dummy to give the castor wheel rotation about the Z axis -->
  <xacro:box_link link_name="left_castor_dummy" length="${castor_mount_dummy_link_length}" 
                                                width="${castor_mount_dummy_link_width}" 
                                                height="${castor_mount_dummy_link_height}" 
                                                mass="${castor_mount_dummy_link_mass}">  
    <origin xyz="0 0 0" rpy="0 0 0" /> 
  </xacro:box_link>

  <!--joint between left castor mount and dummy link to allow rotation of castor wheel about z axis-->
  <xacro:continuous_joint name="left_castor_mount_to_left_castor_dummy" rpy="0 0 0" xyz="0 0 1" 
                          parent="left_castor_mount" child="left_castor_dummy" friction="${friction_val}">
    <origin xyz="0.0 0.0 -0.01"/>
  </xacro:continuous_joint>

  <!--left_castor_wheel_link is a well named link :-) -->
  <xacro:cylinder_link link_name="left_castor_wheel" length="${castor_wheel_length}" radius="${castor_wheel_radius}"  mass="${castor_wheel_mass}"> 
    <origin xyz="0 0 0" rpy="${pi/2} 0 0"/> 
  </xacro:cylinder_link>

  <!--        -->
  <xacro:continuous_joint name="left_castor_dummy_to_left_castor_wheel" rpy="0 0 0" xyz="0 1 0" 
                          parent="left_castor_dummy" child="left_castor_wheel" friction="${friction_val}">
    <origin xyz="-0.037 0.0 -0.10785"/>
  </xacro:continuous_joint>

  <!--+++++++++++++++++++++++++++++++++++RIGHT CASTOR+++++++++++++++++++++++++++++++++++++++++++++++++++-->


  <!--right_caster_plate_link is a well named link :-) -->
  <xacro:box_link link_name="right_castor_mount" length="${castor_mount_link_length}" 
                                                 width="${castor_mount_link_width}"
                                                 height="${castor_mount_link_height}" 
                                                 mass="${castor_mount_link_mass}">  
    <origin xyz="0 0 0" rpy="0 0 0" /> 
  </xacro:box_link>

   <!--        -->
  <xacro:fixed_joint name="base_to_right_castor_mount" parent="base" child="right_castor_mount">
    <origin xyz="-0.52835 -0.344 -0.03265"/>
  </xacro:fixed_joint>

  <!--right_caster_dummy to give the castor wheel rotation about the Z axis -->
  <xacro:box_link link_name="right_castor_dummy" length="${castor_mount_dummy_link_length}" 
                                                 width="${castor_mount_dummy_link_width}" 
                                                 height="${castor_mount_dummy_link_height}" 
                                                 mass="${castor_mount_dummy_link_mass}">  
    <origin xyz="0 0 0" rpy="0 0 0" /> 
  </xacro:box_link>

  <!--joint between right castor mount and dummy link to allow rotation of castor wheel about z axis-->
  <xacro:continuous_joint name="right_castor_mount_to_right_castor_dummy" rpy="0 0 0" xyz="0 0 1" 
                          parent="right_castor_mount" child="right_castor_dummy" friction="${friction_val}">
    <origin xyz="0.0 0.0  -0.01"/>
  </xacro:continuous_joint>


  <!--right_castor_wheel_link is a well named link :-) -->
  <xacro:cylinder_link link_name="right_castor_wheel" length="${castor_wheel_length}" radius="${castor_wheel_radius}"
                        mass="${castor_wheel_mass}"> 
    <origin xyz="0 0 0" rpy="${pi/2} 0 0"/> 
  </xacro:cylinder_link>

  <!--        -->
  <xacro:continuous_joint name="right_castor_dummy_to_right_castor_wheel" rpy="0 0 0" xyz="0 1 0" 
                          parent="right_castor_dummy" child="right_castor_wheel" friction="${friction_val}">
    <origin xyz="-0.037 0 -0.10785"/>
  </xacro:continuous_joint>

  <link name="camera">
    <inertial>
      <mass value="${camera_mass}"/>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <inertia
        ixx="1e-6" ixy="0.0" ixz="0.0"
        iyy="1e-6" iyz="0.0"
        izz="1e-6"/>
    </inertial>
    <visual>
      <geometry>
        <box size="0.05 0.05 0.05"/>
      </geometry>
      <origin xyz="0 0 0" rpy="0 0 0"/>
    </visual>
    <collision>
      <geometry>
        <box size="0.05 0.05 0.05"/>
      </geometry>
      <origin xyz="0 0 0" rpy="0 0 0"/>
    </collision>
  </link>

  <joint name="camera_joint" type="fixed">
		<origin xyz="0.006 -0.2 0.4" rpy="0 0.2 0" />
		<parent link="base_link"/>
		<child link="camera" />
		<axis xyz="0 1 0"/>
	</joint>

  <link name="hokuyo">
		<inertial>
			<mass value="${hokoyu_mass}"/>
			<origin xyz="0 0 0" rpy="0 0 0"/>

			<inertia
		        ixx="1e-6" ixy="0.0" ixz="0.0"
		        iyy="1e-6" iyz="0.0"
		        izz="1e-6"
		      />
		</inertial>

		<visual>
			<origin xyz="0 0 0" rpy="0 0 0"/>
			<geometry>
				<mesh filename="package://ashwini/meshes/hokuyo.dae"/>
			</geometry>
		</visual>

		<collision>
			<origin xyz="0 0 0" rpy="0 0 0"/>
			<geometry>
				<box size="0.1 0.1 0.1"/>
			</geometry>
		</collision>
	</link>

  
	<!-- Hokoyu Joint -->
	<joint name="hokuyo_joint" type="fixed">
	    <origin xyz="0.001 -0.2 0.2" rpy="0 0 3.1415592653589793238" />
	    <parent link="base_link"/>
	    <child link="hokuyo" />  
	    <axis xyz="0 1 0"/> 
	</joint>



    <!-- IMU Sensor -->
  <link name="imu_link">
    <inertial>
      <mass value="0.05"/>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <inertia ixx="0.0001" ixy="0.0" ixz="0.0"
               iyy="0.0001" iyz="0.0"
               izz="0.0001"/>
    </inertial>
    <visual>
      <geometry>
        <box size="0.05 0.05 0.02"/>
      </geometry>
      <material name="Blue">
        <color rgba="0.0 0.0 1.0 1.0"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <box size="0.05 0.05 0.02"/>
      </geometry>
    </collision>
  </link>

  <!-- IMU Joint (Attach to Base Link) -->
  <joint name="imu_joint" type="fixed">
    <parent link="base_link"/>
    <child link="imu_link"/>
    <origin xyz="-0.2 -0.2 0.144" rpy="0 0 0"/>
  </joint>

  <link name="odom"/>
  <joint name="odom_to_base" type="fixed">
    <parent link="odom"/>
    <child link="base_footprint"/>
    <origin xyz="0 0 0" rpy="0 0 0"/>
  </joint>


</robot>



================================================
File: src/ashwini/worlds/empty.world
================================================
<?xml version="1.0" ?>
<sdf version="1.4">
  <world name="black_ground_world">
    
    <!-- Custom black ground -->
    <model name="black_ground">
      <static>true</static>
      <link name="ground_link">
        <collision name="ground_collision">
          <geometry>
            <plane>
              <size>50 50</size>
            </plane>
          </geometry>
        </collision>
        <visual name="ground_visual">
          <geometry>
            <plane>
              <size>50 50</size>
            </plane>
          </geometry>
          <material>
            <script>
              <uri>file://media/materials/scripts/gazebo.material</uri>
              <name>Gazebo/Black</name>
            </script>
          </material>
        </visual>
      </link>
    </model>

        Central obstacle cluster
    <!-- <model name="obstacle_center">
      <static>true</static>
      <pose>2.0 0 0.25 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.5 0.5 0.5</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.5 0.5 0.5</size>
            </box>
          </geometry>
          <material>
            <ambient>1 0 0 1</ambient>
            <diffuse>1 0 0 1</diffuse>
          </material>
        </visual>
      </link>
    </model> -->

    <!-- Left side obstacles -->
    <!-- <model name="obstacle_left_1">
      <static>true</static>
      <pose>1.0 2 0.25 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.4 0.4 0.5</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.4 0.4 0.5</size>
            </box>
          </geometry>
          <material>
            <ambient>0 1 0 1</ambient>
            <diffuse>0 1 0 1</diffuse>
          </material>
        </visual>
      </link>
    </model> -->

    <!-- <model name="obstacle_left_2">
      <static>true</static>
      <pose>3.0 1.5 0.25 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.3 0.6 0.5</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.3 0.6 0.5</size>
            </box>
          </geometry>
          <material>
            <ambient>0 0 1 1</ambient>
            <diffuse>0 0 1 1</diffuse>
          </material>
        </visual>
      </link>
    </model> -->

    <!-- Right side obstacles -->
    <!-- <model name="obstacle_right_1">
      <static>true</static>
      <pose>1.5 -1.0 0.25 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.6 0.3 0.5</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.6 0.3 0.5</size>
            </box>
          </geometry>
          <material>
            <ambient>1 1 0 1</ambient>
            <diffuse>1 1 0 1</diffuse>
          </material>
        </visual>
      </link>
    </model> -->

    <!-- <model name="obstacle_right_2">
      <static>true</static>
      <pose>3.5 -1.3 0.25 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.5 0.5 0.5</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.5 0.5 0.5</size>
            </box>
          </geometry>
          <material>
            <ambient>1 0 1 1</ambient>
            <diffuse>1 0 1 1</diffuse>
          </material>
        </visual>
      </link>
    </model> -->

    <!-- Narrow passage -->
    <!-- <model name="obstacle_gate_1">
      <static>true</static>
      <pose>5.0 0.5 0.25 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.3 0.3 0.5</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.3 0.3 0.5</size>
            </box>
          </geometry>
          <material>
            <ambient>0 1 1 1</ambient>
            <diffuse>0 1 1 1</diffuse>
          </material>
        </visual>
      </link>
    </model> -->

    <!-- <model name="obstacle_gate_2">
      <static>true</static>
      <pose>5.0 -0.5 0.25 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.3 0.3 0.5</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.3 0.3 0.5</size>
            </box>
          </geometry>
          <material>
            <ambient>0 1 1 1</ambient>
            <diffuse>0 1 1 1</diffuse>
          </material>
        </visual>
      </link>
    </model> -->

    <!-- Light source -->
    <include>
      <uri>model://sun</uri>
    </include>

    <!-- World camera -->
    <gui fullscreen='0'>
      <camera name='world_camera'>
        <pose>4.927360 -4.376610 3.740080 0.000000 0.275643 2.356190</pose>
        <view_controller>orbit</view_controller>
      </camera>
    </gui>
  </world>
</sdf>



================================================
File: src/rplidar_ros/README.md
================================================
# RPLIDAR ROS package

ROS node and test application for RPLIDAR

Visit following Website for more details about RPLIDAR:

rplidar roswiki: <http://wiki.ros.org/rplidar>

rplidar HomePage: <http://www.slamtec.com/en/Lidar>

rplidar SDK: <https://github.com/Slamtec/rplidar_sdk>

rplidar Tutorial: <https://github.com/robopeak/rplidar_ros/wiki>

## How to build rplidar ros package

   1) Clone this project to your catkin's workspace src folder
   2) Running catkin_make to build rplidarNode and rplidarNodeClient

## How to run rplidar ros package

There're two ways to run rplidar ros package

### I. Run rplidar node and view in the rviz

The command for RPLIDAR A1 is :

```bash
roslaunch rplidar_ros view_rplidar_a1.launch
```

The command for RPLIDAR A2M7 is :

```bash
roslaunch rplidar_ros view_rplidar_a2m7.launch
```

The command for RPLIDAR A2M8 is :

```bash
roslaunch rplidar_ros view_rplidar_a2m8.launch
```

The command for RPLIDAR A2M12 is :

```bash
roslaunch rplidar_ros view_rplidar_a2m12.launch
```

The command for RPLIDAR A3 is :

```bash
roslaunch rplidar_ros view_rplidar_a3.launch
```

The command for RPLIDAR S1 is :

```bash
roslaunch rplidar_ros view_rplidar_s1.launch
```

The command for RPLIDAR S2 is :

```bash
roslaunch rplidar_ros view_rplidar_s2.launch
```

The command for RPLIDAR S3 is :

```bash
roslaunch rplidar_ros view_rplidar_s3.launch
```

The command for RPLIDAR S2E is :

```bash
roslaunch rplidar_ros view_rplidar_s2e.launch
```

The command for RPLIDAR T1 is :

```bash
roslaunch rplidar_ros view_rplidar_t1.launch
```

The command for RPLIDAR C1 is :

```bash
roslaunch rplidar_ros view_rplidar_c1.launch
```

You should see rplidar's scan result in the rviz.

### II. Run rplidar node and view using test application

The command for RPLIDAR A1 is :

```bash
roslaunch rplidar_ros rplidar_a1.launch
```

The command for RPLIDAR A2M7 is :

```bash
roslaunch rplidar_ros rplidar_a2m7.launch
```

The command for RPLIDAR A2M8 is :

```bash
roslaunch rplidar_ros rplidar_a2m8.launch
```

The command for RPLIDAR A2M12 is :

```bash
roslaunch rplidar_ros rplidar_a2m12.launch
```

The command for RPLIDAR A3 is :

```bash
roslaunch rplidar_ros rplidar_a3.launch
```

The command for RPLIDAR S1 is :

```bash
roslaunch rplidar_ros rplidar_s1.launch
```

The command for RPLIDAR S2 is :

```bash
roslaunch rplidar_ros rplidar_s2.launch
```

The command for RPLIDAR S3 is :

```bash
roslaunch rplidar_ros rplidar_s3.launch
```

The command for RPLIDAR S2E is :

```bash
roslaunch rplidar_ros rplidar_s2e.launch
```

The command for RPLIDAR T1 is :

```bash
roslaunch rplidar_ros rplidar_t1.launch
```

The command for RPLIDAR C1 is :

```bash
roslaunch rplidar_ros rplidar_c1.launch
```

and in another terminal, run the following command

```bash
rosrun rplidar_ros rplidarNodeClient
```

You should see rplidar's scan result in the console.

Notice: different lidar use different serial_baudrate.

## RPLidar frame

RPLidar frame must be broadcasted according to picture shown in rplidar-frame.png



================================================
File: src/rplidar_ros/CHANGELOG.rst
================================================
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Changelog for package rplidar_ros
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2.1.5 (2023-11-20)
------------------
* Update RPLIDAR SDK to 2.1.0
  * Support RPLIDAR C1 (`#142 <https://github.com/Slamtec/rplidar_ros/issues/142>`_)
  * Re-implemented the data retrieving logic based on async fetching and decoding mechanism to improve performance
  * UltraDense protocol support
  * support for stoppping A1 motor
  * bugfix:start/stop_motor(service) cause lidar to stop scanning
* Fix build with C++14 && --march=native
* scan frequency configuration support
* Add launch file for RPLIDAR a2m*,C1
* Install udev rules via debian. (`#126 <https://github.com/Slamtec/rplidar_ros/issues/126>`_)
* Bugfix:create_udev_rules.sh dose not take effect immediately.
* When node starts to reset rplidar, if rplidar info is not obtained within 15 seconds, rplidar reset fails
* Add initial_reset option to reset rplidar on node start
* Compilation optimization
* Contributors: Babak-SSh, Tim Clephas, Tony Baltovski, Ubuntu248, Victor Belov, Wang DeYou, WubinXia, kint, yzx

2.0.0 (2021-10-8)
-----------------
* Update RPLIDAR SDK to 2.0.0
* [new feature] 1.redesign the skelton of the sdk. 2.support Rplidar S2
* Contributors: tony,WubinXia

1.10.0 (2019-02-22)
-------------------
* Update RPLIDAR SDK to 1.10.0
* [new feature] support Rplidar S1
* Contributors: tony,WubinXia

1.9.0 (2018-08-24)
------------------
* Update RPLIDAR SDK to 1.9.0
* [new feature] support baudrate 57600 and 1382400, support HQ scan response
* [bugfix] TCP channel doesn't work
* [improvement] Print warning messages when deprecated APIs are called; imporve angular accuracy for ultra capsuled scan points
* Contributors: tony,kint

1.7.0 (2018-07-19)
------------------
* Update RPLIDAR SDK to 1.7.0
* support scan points farther than 16.38m
* upport display and set scan mode
* Contributors: kint


1.6.0 (2018-05-21)
------------------
* Release 1.6.0.
* Update RPLIDAR SDK to 1.6.0
* Support new product RPLIDAR A3(default 16K model and max_distance 25m)
* Contributors: kint


1.5.7 (2016-12-15)
------------------
* Release 1.5.7.
* Update RPLIDAR SDK to 1.5.7
* Fixed the motor default speed at 10 HZ. Extend the measurement of max_distance from 6m to 8m.
* Contributors: kint

1.5.5 (2016-08-23)
------------------
* Release 1.5.5.
* Update RPLIDAR SDK to 1.5.5
* Add RPLIDAR information print, and fix the standard motor speed of RPLIDAR A2.
* Contributors: kint

1.5.4 (2016-06-02)
------------------
* Release 1.5.4.
* Update RPLIDAR SDK to 1.5.4
* Support RPLIDAR A2
* Contributors: kint

1.5.2 (2016-04-29)
------------------
* Release 1.5.2.
* Update RPLIDAR SDK to 1.5.2
* Support RPLIDAR A2
* Contributors: kint

1.0.1 (2014-06-03)
------------------
* Release 1.0.1.
* Add angle compensate mechanism to compatible with ROS scan message
* Add RPLIDAR sdk to the repo.
* First release of RPLIDAR ROS package (1.0.0)
* Initial commit
* Contributors: Ling, RoboPeak Public Repos



================================================
File: src/rplidar_ros/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 2.8.3)
project(rplidar_ros)

set(RPLIDAR_SDK_PATH "./sdk/")
set(CMAKE_BUILD_TYPE "Release")
set(CMAKE_CXX_FLAGS "-std=c++11 ${CMAKE_CXX_FLAGS}")

FILE(GLOB RPLIDAR_SDK_SRC 
  "${RPLIDAR_SDK_PATH}/src/arch/linux/*.cpp"
  "${RPLIDAR_SDK_PATH}/src/dataunpacker/*.cpp"
  "${RPLIDAR_SDK_PATH}/src/dataunpacker/unpacker/*.cpp"
  "${RPLIDAR_SDK_PATH}/src/hal/*.cpp"
  "${RPLIDAR_SDK_PATH}/src/*.cpp"
)

find_package(catkin REQUIRED COMPONENTS
  roscpp
  rosconsole
  sensor_msgs
)

include_directories(
  ${RPLIDAR_SDK_PATH}/include
  ${RPLIDAR_SDK_PATH}/src
  ${catkin_INCLUDE_DIRS}
)

catkin_package()

add_executable(rplidarNode src/node.cpp ${RPLIDAR_SDK_SRC})
target_link_libraries(rplidarNode ${catkin_LIBRARIES})

add_executable(rplidarNodeClient src/client.cpp)
target_link_libraries(rplidarNodeClient ${catkin_LIBRARIES})

install(TARGETS rplidarNode rplidarNodeClient
  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)

install(DIRECTORY launch rviz sdk
  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
  USE_SOURCE_PERMISSIONS
)



================================================
File: src/rplidar_ros/LICENSE
================================================
Copyright (c) 2009 - 2014 RoboPeak Team
Copyright (c) 2014 - 2018 Shanghai Slamtec Co., Ltd.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



================================================
File: src/rplidar_ros/package.xml
================================================
<?xml version="1.0"?>
<package>
  <name>rplidar_ros</name>
  <version>2.1.5</version>
  <description>The rplidar ros package, support rplidar A1/A2/A3/S1/S2/S3/T1/C1</description>

  <maintainer email="ros@slamtec.com">Slamtec ROS Maintainer</maintainer>
  <license>BSD</license>

  <buildtool_depend>catkin</buildtool_depend>
  <build_depend>roscpp</build_depend>
  <build_depend>rosconsole</build_depend>
  <build_depend>sensor_msgs</build_depend>
  <build_depend>std_srvs</build_depend>
  <run_depend>roscpp</run_depend>
  <run_depend>rosconsole</run_depend>
  <run_depend>sensor_msgs</run_depend>
  <run_depend>std_srvs</run_depend>

</package>



================================================
File: src/rplidar_ros/debian/udev
================================================
# set the udev rule , make the device_port be fixed by rplidar
#
KERNEL=="ttyUSB*", ATTRS{idVendor}=="10c4", ATTRS{idProduct}=="ea60", MODE:="0666", SYMLINK+="rplidar"




================================================
File: src/rplidar_ros/launch/rplidar_a1.launch
================================================
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="serial_port"         type="string" value="/dev/ttyUSB0"/>
  <param name="serial_baudrate"     type="int"    value="115200"/>
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>
  </node>
</launch>



================================================
File: src/rplidar_ros/launch/rplidar_a2m12.launch
================================================
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="serial_port"         type="string" value="/dev/ttyUSB0"/>
  <param name="serial_baudrate"     type="int"    value="256000"/>
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>
  </node>
</launch>



================================================
File: src/rplidar_ros/launch/rplidar_a2m7.launch
================================================
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="serial_port"         type="string" value="/dev/ttyUSB0"/>
  <param name="serial_baudrate"     type="int"    value="256000"/>
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>
  </node>
</launch>



================================================
File: src/rplidar_ros/launch/rplidar_a2m8.launch
================================================
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="serial_port"         type="string" value="/dev/ttyUSB0"/>
  <param name="serial_baudrate"     type="int"    value="115200"/>
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>
  </node>
</launch>



================================================
File: src/rplidar_ros/launch/rplidar_a3.launch
================================================
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="serial_port"         type="string" value="/dev/ttyUSB0"/>  
  <param name="serial_baudrate"     type="int"    value="256000"/><!--A3 -->
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>
  <param name="scan_mode"           type="string" value="Sensitivity"/>
  </node>
</launch>



================================================
File: src/rplidar_ros/launch/rplidar_c1.launch
================================================
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="serial_port"         type="string" value="/dev/ttyUSB0"/>  
  <param name="serial_baudrate"     type="int"    value="460800"/>
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>
  <param name="scan_frequency"      type="double" value="10.0"/>
  <param name="scan_mode"           type="string" value="Standard"/>
  </node>
</launch>



================================================
File: src/rplidar_ros/launch/rplidar_s1.launch
================================================
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="serial_port"         type="string" value="/dev/ttyUSB0"/>  
  <param name="serial_baudrate"     type="int"    value="256000"/>
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>
  </node>
</launch>



================================================
File: src/rplidar_ros/launch/rplidar_s1_tcp.launch
================================================
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="channel_type"        type="string" value="tcp"/>  
  <param name="tcp_ip"              type="string" value="192.168.0.7"/>  
  <param name="tcp_port"            type="int"    value="20108"/>
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>
  </node>
</launch>



================================================
File: src/rplidar_ros/launch/rplidar_s2.launch
================================================
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="serial_port"         type="string" value="/dev/ttyUSB0"/>  
  <param name="serial_baudrate"     type="int"    value="1000000"/>
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>
  <param name="scan_frequency"      type="double" value="10.0"/>
  </node>
</launch>



================================================
File: src/rplidar_ros/launch/rplidar_s2e.launch
================================================
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="channel_type"        type="string" value="udp"/>  
  <param name="udp_ip"              type="string" value="192.168.11.2"/>  
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>
  <param name="scan_mode"           type="string" value="Sensitivity"/>
  <param name="scan_frequency"      type="int"    value="10"/>
  </node>
</launch>



================================================
File: src/rplidar_ros/launch/rplidar_s3.launch
================================================
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="serial_port"         type="string" value="/dev/ttyUSB0"/>  
  <param name="serial_baudrate"     type="int"    value="1000000"/>
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>
  <param name="scan_frequency"      type="double" value="10.0"/>
  </node>
</launch>



================================================
File: src/rplidar_ros/launch/rplidar_t1.launch
================================================
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="channel_type"        type="string" value="udp"/>  
  <param name="udp_ip"              type="string" value="192.168.11.2"/>  
  <param name="udp_port"            type="int"    value="8089"/>
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>
  </node>
</launch>



================================================
File: src/rplidar_ros/launch/test_rplidar.launch
================================================
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="serial_port"         type="string" value="/dev/ttyUSB0"/>  
  <param name="serial_baudrate"     type="int"    value="115200"/>
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>

 </node>
  <node name="rplidarNodeClient"    pkg="rplidar_ros"  type="rplidarNodeClient" output="screen">
  </node>
</launch>



================================================
File: src/rplidar_ros/launch/test_rplidar_a3.launch
================================================
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="serial_port"         type="string" value="/dev/ttyUSB0"/>  
  <param name="serial_baudrate"     type="int"    value="256000"/>
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>
  <param name="scan_mode"           type="string" value="Sensitivity"/>

 </node>
  <node name="rplidarNodeClient"    pkg="rplidar_ros"  type="rplidarNodeClient" output="screen">
  </node>
</launch>



================================================
File: src/rplidar_ros/launch/view_rplidar_a1.launch
================================================
<!--
  Used for visualising rplidar in action.  
  
  It requires rplidar.launch.
 -->
<launch>
  <include file="$(find rplidar_ros)/launch/rplidar_a1.launch" />

  <node name="rviz" pkg="rviz" type="rviz" args="-d $(find rplidar_ros)/rviz/rplidar.rviz" />
</launch>



================================================
File: src/rplidar_ros/launch/view_rplidar_a2m12.launch
================================================
<!--
  Used for visualising rplidar in action.  
  
  It requires rplidar.launch.
 -->
<launch>
  <include file="$(find rplidar_ros)/launch/rplidar_a2m12.launch" />

  <node name="rviz" pkg="rviz" type="rviz" args="-d $(find rplidar_ros)/rviz/rplidar.rviz" />
</launch>



================================================
File: src/rplidar_ros/launch/view_rplidar_a2m7.launch
================================================
<!--
  Used for visualising rplidar in action.  
  
  It requires rplidar.launch.
 -->
<launch>
  <include file="$(find rplidar_ros)/launch/rplidar_a2m7.launch" />

  <node name="rviz" pkg="rviz" type="rviz" args="-d $(find rplidar_ros)/rviz/rplidar.rviz" />
</launch>



================================================
File: src/rplidar_ros/launch/view_rplidar_a2m8.launch
================================================
<!--
  Used for visualising rplidar in action.  
  
  It requires rplidar.launch.
 -->
<launch>
  <include file="$(find rplidar_ros)/launch/rplidar_a2m8.launch" />

  <node name="rviz" pkg="rviz" type="rviz" args="-d $(find rplidar_ros)/rviz/rplidar.rviz" />
</launch>



================================================
File: src/rplidar_ros/launch/view_rplidar_a3.launch
================================================
<!--
  Used for visualising rplidar in action.  
  
  It requires rplidar.launch.
 -->
<launch>
  <include file="$(find rplidar_ros)/launch/rplidar_a3.launch" />

  <node name="rviz" pkg="rviz" type="rviz" args="-d $(find rplidar_ros)/rviz/rplidar.rviz" />
</launch>



================================================
File: src/rplidar_ros/launch/view_rplidar_c1.launch
================================================
<!--
  Used for visualising rplidar in action.  
  
  It requires rplidar.launch.
 -->
<launch>
  <include file="$(find rplidar_ros)/launch/rplidar_c1.launch" />

  <node name="rviz" pkg="rviz" type="rviz" args="-d $(find rplidar_ros)/rviz/rplidar.rviz" />
</launch>



================================================
File: src/rplidar_ros/launch/view_rplidar_s1.launch
================================================
<!--
  Used for visualising rplidar in action.  
  
  It requires rplidar.launch.
 -->
<launch>
  <include file="$(find rplidar_ros)/launch/rplidar_s1.launch" />

  <node name="rviz" pkg="rviz" type="rviz" args="-d $(find rplidar_ros)/rviz/rplidar.rviz" />
</launch>



================================================
File: src/rplidar_ros/launch/view_rplidar_s1_tcp.launch
================================================
<!--
  Used for visualising rplidar in action.  
  
  It requires rplidar.launch.
 -->
<launch>
  <include file="$(find rplidar_ros)/launch/rplidar_s1_tcp.launch" />

  <node name="rviz" pkg="rviz" type="rviz" args="-d $(find rplidar_ros)/rviz/rplidar.rviz" />
</launch>



================================================
File: src/rplidar_ros/launch/view_rplidar_s2.launch
================================================
<!--
  Used for visualising rplidar in action.  
  
  It requires rplidar.launch.
 -->
<launch>
  <include file="$(find rplidar_ros)/launch/rplidar_s2.launch" />

  <node name="rviz" pkg="rviz" type="rviz" args="-d $(find rplidar_ros)/rviz/rplidar.rviz" />
</launch>



================================================
File: src/rplidar_ros/launch/view_rplidar_s2e.launch
================================================
<!--
  Used for visualising rplidar in action.  
  
  It requires rplidar.launch.
 -->
<launch>
  <include file="$(find rplidar_ros)/launch/rplidar_s2e.launch" />

  <node name="rviz" pkg="rviz" type="rviz" args="-d $(find rplidar_ros)/rviz/rplidar.rviz" />
</launch>



================================================
File: src/rplidar_ros/launch/view_rplidar_s3.launch
================================================
<!--
  Used for visualising rplidar in action.  
  
  It requires rplidar.launch.
 -->
<launch>
  <include file="$(find rplidar_ros)/launch/rplidar_s3.launch" />

  <node name="rviz" pkg="rviz" type="rviz" args="-d $(find rplidar_ros)/rviz/rplidar.rviz" />
</launch>



================================================
File: src/rplidar_ros/launch/view_rplidar_t1.launch
================================================
<!--
  Used for visualising rplidar in action.  
  
  It requires rplidar.launch.
 -->
<launch>
  <include file="$(find rplidar_ros)/launch/rplidar_t1.launch" />

  <node name="rviz" pkg="rviz" type="rviz" args="-d $(find rplidar_ros)/rviz/rplidar.rviz" />
</launch>



================================================
File: src/rplidar_ros/rviz/rplidar.rviz
================================================
Panels:
  - Class: rviz/Displays
    Help Height: 78
    Name: Displays
    Property Tree Widget:
      Expanded:
        - /Global Options1
        - /Status1
        - /RPLidarLaserScan1
      Splitter Ratio: 0.5
    Tree Height: 413
  - Class: rviz/Selection
    Name: Selection
  - Class: rviz/Tool Properties
    Expanded:
      - /2D Pose Estimate1
      - /2D Nav Goal1
    Name: Tool Properties
    Splitter Ratio: 0.588679
  - Class: rviz/Views
    Expanded:
      - /Current View1
    Name: Views
    Splitter Ratio: 0.5
  - Class: rviz/Time
    Experimental: false
    Name: Time
    SyncMode: 0
    SyncSource: ""
Visualization Manager:
  Class: ""
  Displays:
    - Alpha: 0.5
      Cell Size: 1
      Class: rviz/Grid
      Color: 160; 160; 164
      Enabled: true
      Line Style:
        Line Width: 0.03
        Value: Lines
      Name: Grid
      Normal Cell Count: 0
      Offset:
        X: 0
        Y: 0
        Z: 0
      Plane: XY
      Plane Cell Count: 10
      Reference Frame: <Fixed Frame>
      Value: true
    - Alpha: 1
      Autocompute Intensity Bounds: true
      Autocompute Value Bounds:
        Max Value: 0
        Min Value: 0
        Value: true
      Axis: Z
      Channel Name: intensity
      Class: rviz/LaserScan
      Color: 255; 255; 255
      Color Transformer: AxisColor
      Decay Time: 0
      Enabled: true
      Invert Rainbow: false
      Max Color: 255; 255; 255
      Max Intensity: 4096
      Min Color: 0; 0; 0
      Min Intensity: 0
      Name: RPLidarLaserScan
      Position Transformer: XYZ
      Queue Size: 1000
      Selectable: true
      Size (Pixels): 5
      Size (m): 0.03
      Style: Squares
      Topic: /scan
      Use Fixed Frame: true
      Use rainbow: true
      Value: true
  Enabled: true
  Global Options:
    Background Color: 48; 48; 48
    Fixed Frame: laser
    Frame Rate: 30
  Name: root
  Tools:
    - Class: rviz/MoveCamera
    - Class: rviz/Interact
      Hide Inactive Objects: true
    - Class: rviz/Select
    - Class: rviz/SetInitialPose
      Topic: /initialpose
    - Class: rviz/SetGoal
      Topic: /move_base_simple/goal
  Value: true
  Views:
    Current:
      Class: rviz/Orbit
      Distance: 11.1184
      Focal Point:
        X: -0.0344972
        Y: 0.065886
        Z: 0.148092
      Name: Current View
      Near Clip Distance: 0.01
      Pitch: 0.615399
      Target Frame: <Fixed Frame>
      Value: Orbit (rviz)
      Yaw: 5.82358
    Saved: ~
Window Geometry:
  Displays:
    collapsed: false
  Height: 626
  Hide Left Dock: false
  Hide Right Dock: false
  QMainWindow State: 000000ff00000000fd0000000400000000000001950000022cfc0200000006fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c00610079007301000000280000022c000000dd00fffffffb0000000a0049006d006100670065000000028d000000c60000000000000000000000010000010b00000294fc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000000a00560069006500770073000000003300000294000000b000fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000004a00000003efc0100000002fb0000000800540069006d00650000000000000004a0000002f600fffffffb0000000800540069006d00650100000000000004500000000000000000000003240000022c00000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
  Selection:
    collapsed: false
  Time:
    collapsed: false
  Tool Properties:
    collapsed: false
  Views:
    collapsed: false
  Width: 1215
  X: 65
  Y: 24



================================================
File: src/rplidar_ros/scripts/create_udev_rules.sh
================================================
#!/bin/bash

echo "remap the device serial port(ttyUSBX) to  rplidar"
echo "rplidar usb connection as /dev/rplidar , check it using the command : ls -l /dev|grep ttyUSB"
echo "start copy rplidar.rules to  /etc/udev/rules.d/"
echo "`rospack find rplidar_ros`/scripts/rplidar.rules"
sudo cp `rospack find rplidar_ros`/scripts/rplidar.rules  /etc/udev/rules.d
echo " "
echo "Restarting udev"
echo ""
sudo service udev reload
sudo service udev restart
sudo udevadm control --reload && sudo udevadm trigger
echo "finish "



================================================
File: src/rplidar_ros/scripts/delete_udev_rules.sh
================================================
#!/bin/bash

echo "delete remap the device serial port(ttyUSBX) to  rplidar"
echo "sudo rm   /etc/udev/rules.d/rplidar.rules"
sudo rm   /etc/udev/rules.d/rplidar.rules
echo " "
echo "Restarting udev"
echo ""
sudo service udev reload
sudo service udev restart
echo "finish  delete"



================================================
File: src/rplidar_ros/scripts/rplidar.rules
================================================
# set the udev rule , make the device_port be fixed by rplidar
#
KERNEL=="ttyUSB*", ATTRS{idVendor}=="10c4", ATTRS{idProduct}=="ea60", MODE:="0777", SYMLINK+="rplidar"




================================================
File: src/rplidar_ros/sdk/Makefile
================================================
#/*
# *  RPLIDAR SDK
# *
# *  Copyright (c) 2009 - 2014 RoboPeak Team
# *  http://www.robopeak.com
# *  Copyright (c) 2014 - 2019 Shanghai Slamtec Co., Ltd.
# *  http://www.slamtec.com
# *
# */
#/*
# * Redistribution and use in source and binary forms, with or without
# * modification, are permitted provided that the following conditions are met:
# *
# * 1. Redistributions of source code must retain the above copyright notice,
# *    this list of conditions and the following disclaimer.
# *
# * 2. Redistributions in binary form must reproduce the above copyright notice,
# *    this list of conditions and the following disclaimer in the documentation
# *    and/or other materials provided with the distribution.
# *
# * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
# * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# *
# */
#
HOME_TREE := ../

MODULE_NAME := $(notdir $(CURDIR))

include $(HOME_TREE)/mak_def.inc

CXXSRC += src/sl_lidar_driver.cpp \
          src/hal/thread.cpp\
          src/sl_crc.cpp\
	      src/sl_serial_channel.cpp\
	      src/sl_lidarprotocol_codec.cpp\
          src/sl_async_transceiver.cpp\
          src/sl_tcp_channel.cpp\
	      src/sl_udp_channel.cpp


C_INCLUDES += -I$(CURDIR)/include -I$(CURDIR)/src


#dataunpacker
CXXSRC += $(shell find $(CURDIR)/src/dataunpacker/ -name "*.cpp")

C_INCLUDES += -I$(CURDIR)/src/dataunpacker  -I$(CURDIR)/src/dataunpacker/unpacker


ifeq ($(BUILD_TARGET_PLATFORM),Linux)
CXXSRC += src/arch/linux/net_serial.cpp \
          src/arch/linux/net_socket.cpp \
          src/arch/linux/timer.cpp 
endif


ifeq ($(BUILD_TARGET_PLATFORM),Darwin)
CXXSRC += src/arch/macOS/net_serial.cpp \
          src/arch/macOS/net_socket.cpp \
          src/arch/macOS/timer.cpp
endif

all: build_sdk

include $(HOME_TREE)/mak_common.inc

clean: clean_sdk



================================================
File: src/rplidar_ros/sdk/include/rplidar.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2019 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

#include <vector>
#include "hal/types.h"
#include "rplidar_protocol.h"
#include "rplidar_cmd.h"

#include "rplidar_driver.h"

#define RPLIDAR_SDK_VERSION "2.0.0"
#define SLAMTEC_LIDAR_SDK_VERSION  SL_LIDAR_SDK_VERSION



================================================
File: src/rplidar_ros/sdk/include/rplidar_cmd.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014-2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once
#include "sl_lidar_cmd.h"
#include "rplidar_protocol.h"

// Commands
//-----------------------------------------

#define RPLIDAR_AUTOBAUD_MAGICBYTE     SL_LIDAR_AUTOBAUD_MAGICBYTE

// Commands without payload and response
#define RPLIDAR_CMD_STOP               SL_LIDAR_CMD_STOP
#define RPLIDAR_CMD_SCAN               SL_LIDAR_CMD_SCAN
#define RPLIDAR_CMD_FORCE_SCAN         SL_LIDAR_CMD_FORCE_SCAN
#define RPLIDAR_CMD_RESET              SL_LIDAR_CMD_RESET


// Commands without payload but have response
#define RPLIDAR_CMD_GET_DEVICE_INFO          SL_LIDAR_CMD_GET_DEVICE_INFO
#define RPLIDAR_CMD_GET_DEVICE_HEALTH        SL_LIDAR_CMD_GET_DEVICE_HEALTH

#define RPLIDAR_CMD_GET_SAMPLERATE           SL_LIDAR_CMD_GET_SAMPLERATE //added in fw 1.17

#define RPLIDAR_CMD_HQ_MOTOR_SPEED_CTRL      SL_LIDAR_CMD_HQ_MOTOR_SPEED_CTRL

// Commands with payload but no response
#define RPLIDAR_CMD_NEW_BAUDRATE_CONFIRM     SL_LIDAR_CMD_NEW_BAUDRATE_CONFIRM //added in fw 1.30

// Commands with payload and have response
#define RPLIDAR_CMD_EXPRESS_SCAN            SL_LIDAR_CMD_EXPRESS_SCAN //added in fw 1.17
#define RPLIDAR_CMD_HQ_SCAN                 SL_LIDAR_CMD_HQ_SCAN //added in fw 1.24
#define RPLIDAR_CMD_GET_LIDAR_CONF          SL_LIDAR_CMD_GET_LIDAR_CONF //added in fw 1.24
#define RPLIDAR_CMD_SET_LIDAR_CONF          SL_LIDAR_CMD_SET_LIDAR_CONF //added in fw 1.24
//add for A2 to set RPLIDAR motor pwm when using accessory board
#define RPLIDAR_CMD_SET_MOTOR_PWM           SL_LIDAR_CMD_SET_MOTOR_PWM
#define RPLIDAR_CMD_GET_ACC_BOARD_FLAG      SL_LIDAR_CMD_GET_ACC_BOARD_FLAG

#if defined(_WIN32)
#pragma pack(1)
#endif


// Payloads
// ------------------------------------------
#define RPLIDAR_EXPRESS_SCAN_MODE_NORMAL      SL_LIDAR_EXPRESS_SCAN_MODE_NORMAL 
#define RPLIDAR_EXPRESS_SCAN_MODE_FIXANGLE    SL_LIDAR_EXPRESS_SCAN_MODE_FIXANGLE  // won't been supported but keep to prevent build fail
//for express working flag(extending express scan protocol)
#define RPLIDAR_EXPRESS_SCAN_FLAG_BOOST                 SL_LIDAR_EXPRESS_SCAN_FLAG_BOOST 
#define RPLIDAR_EXPRESS_SCAN_FLAG_SUNLIGHT_REJECTION    SL_LIDAR_EXPRESS_SCAN_FLAG_SUNLIGHT_REJECTION

//for ultra express working flag
#define RPLIDAR_ULTRAEXPRESS_SCAN_FLAG_STD                 SL_LIDAR_ULTRAEXPRESS_SCAN_FLAG_STD 
#define RPLIDAR_ULTRAEXPRESS_SCAN_FLAG_HIGH_SENSITIVITY    SL_LIDAR_ULTRAEXPRESS_SCAN_FLAG_HIGH_SENSITIVITY

#define RPLIDAR_HQ_SCAN_FLAG_CCW            (0x1<<0)
#define RPLIDAR_HQ_SCAN_FLAG_RAW_ENCODER    (0x1<<1)
#define RPLIDAR_HQ_SCAN_FLAG_RAW_DISTANCE   (0x1<<2)

typedef sl_lidar_payload_express_scan_t   rplidar_payload_express_scan_t;
typedef sl_lidar_payload_hq_scan_t        rplidar_payload_hq_scan_t;
typedef sl_lidar_payload_get_scan_conf_t  rplidar_payload_get_scan_conf_t;
typedef sl_lidar_payload_motor_pwm_t      rplidar_payload_motor_pwm_t;
typedef sl_lidar_payload_acc_board_flag_t rplidar_payload_acc_board_flag_t;
typedef sl_lidar_payload_set_scan_conf_t  rplidar_payload_set_scan_conf_t;
typedef sl_lidar_payload_new_bps_confirmation_t  rplidar_payload_new_bps_confirmation_t;

// Response
// ------------------------------------------
#define RPLIDAR_ANS_TYPE_DEVINFO                                 SL_LIDAR_ANS_TYPE_DEVINFO
#define RPLIDAR_ANS_TYPE_DEVHEALTH                               SL_LIDAR_ANS_TYPE_DEVHEALTH
#define RPLIDAR_ANS_TYPE_MEASUREMENT                             SL_LIDAR_ANS_TYPE_MEASUREMENT
// Added in FW ver 1.17
#define RPLIDAR_ANS_TYPE_MEASUREMENT_CAPSULED                    SL_LIDAR_ANS_TYPE_MEASUREMENT_CAPSULED
#define RPLIDAR_ANS_TYPE_MEASUREMENT_HQ                          SL_LIDAR_ANS_TYPE_MEASUREMENT_HQ
// Added in FW ver 1.17
#define RPLIDAR_ANS_TYPE_SAMPLE_RATE                             SL_LIDAR_ANS_TYPE_SAMPLE_RATE
//added in FW ver 1.23alpha
#define RPLIDAR_ANS_TYPE_MEASUREMENT_CAPSULED_ULTRA              SL_LIDAR_ANS_TYPE_MEASUREMENT_CAPSULED_ULTRA
//added in FW ver 1.24
#define RPLIDAR_ANS_TYPE_GET_LIDAR_CONF                          SL_LIDAR_ANS_TYPE_GET_LIDAR_CONF
#define RPLIDAR_ANS_TYPE_SET_LIDAR_CONF                          SL_LIDAR_ANS_TYPE_SET_LIDAR_CONF
#define RPLIDAR_ANS_TYPE_MEASUREMENT_DENSE_CAPSULED              SL_LIDAR_ANS_TYPE_MEASUREMENT_DENSE_CAPSULED
#define RPLIDAR_ANS_TYPE_MEASUREMENT_ULTRA_DENSE_CAPSULED        SL_LIDAR_ANS_TYPE_MEASUREMENT_ULTRA_DENSE_CAPSULED

#define RPLIDAR_ANS_TYPE_ACC_BOARD_FLAG                          SL_LIDAR_ANS_TYPE_ACC_BOARD_FLAG

#define RPLIDAR_RESP_ACC_BOARD_FLAG_MOTOR_CTRL_SUPPORT_MASK      SL_LIDAR_RESP_ACC_BOARD_FLAG_MOTOR_CTRL_SUPPORT_MASK

typedef sl_lidar_response_acc_board_flag_t rplidar_response_acc_board_flag_t;


#define RPLIDAR_STATUS_OK                 SL_LIDAR_STATUS_OK
#define RPLIDAR_STATUS_WARNING            SL_LIDAR_STATUS_WARNING
#define RPLIDAR_STATUS_ERROR              SL_LIDAR_STATUS_ERROR

#define RPLIDAR_RESP_MEASUREMENT_SYNCBIT        SL_LIDAR_RESP_MEASUREMENT_SYNCBIT
#define RPLIDAR_RESP_MEASUREMENT_QUALITY_SHIFT  SL_LIDAR_RESP_MEASUREMENT_QUALITY_SHIFT
#define RPLIDAR_RESP_HQ_FLAG_SYNCBIT            SL_LIDAR_RESP_HQ_FLAG_SYNCBIT
#define RPLIDAR_RESP_MEASUREMENT_CHECKBIT       SL_LIDAR_RESP_MEASUREMENT_CHECKBIT
#define RPLIDAR_RESP_MEASUREMENT_ANGLE_SHIFT    SL_LIDAR_RESP_MEASUREMENT_ANGLE_SHIFT

typedef sl_lidar_response_sample_rate_t rplidar_response_sample_rate_t;
typedef sl_lidar_response_measurement_node_t rplidar_response_measurement_node_t;

//[distance_sync flags]
#define RPLIDAR_RESP_MEASUREMENT_EXP_ANGLE_MASK           SL_LIDAR_RESP_MEASUREMENT_EXP_ANGLE_MASK
#define RPLIDAR_RESP_MEASUREMENT_EXP_DISTANCE_MASK        SL_LIDAR_RESP_MEASUREMENT_EXP_DISTANCE_MASK

typedef sl_lidar_response_cabin_nodes_t rplidar_response_cabin_nodes_t;


#define RPLIDAR_RESP_MEASUREMENT_EXP_SYNC_1               SL_LIDAR_RESP_MEASUREMENT_EXP_SYNC_1
#define RPLIDAR_RESP_MEASUREMENT_EXP_SYNC_2               SL_LIDAR_RESP_MEASUREMENT_EXP_SYNC_2
#define RPLIDAR_RESP_MEASUREMENT_HQ_SYNC                  SL_LIDAR_RESP_MEASUREMENT_HQ_SYNC
#define RPLIDAR_RESP_MEASUREMENT_EXP_SYNCBIT              SL_LIDAR_RESP_MEASUREMENT_EXP_SYNCBIT


typedef sl_lidar_response_capsule_measurement_nodes_t         rplidar_response_capsule_measurement_nodes_t;
typedef sl_lidar_response_dense_cabin_nodes_t                 rplidar_response_dense_cabin_nodes_t;
typedef sl_lidar_response_dense_capsule_measurement_nodes_t   rplidar_response_dense_capsule_measurement_nodes_t;
typedef sl_lidar_response_ultra_dense_capsule_measurement_nodes_t rplidar_response_ultra_dense_capsule_measurement_nodes_t;
// ext1 : x2 boost mode

#define RPLIDAR_RESP_MEASUREMENT_EXP_ULTRA_MAJOR_BITS     SL_LIDAR_RESP_MEASUREMENT_EXP_ULTRA_MAJOR_BITS
#define RPLIDAR_RESP_MEASUREMENT_EXP_ULTRA_PREDICT_BITS   SL_LIDAR_RESP_MEASUREMENT_EXP_ULTRA_PREDICT_BITS

typedef sl_lidar_response_ultra_cabin_nodes_t                      rplidar_response_ultra_cabin_nodes_t;
typedef sl_lidar_response_ultra_capsule_measurement_nodes_t        rplidar_response_ultra_capsule_measurement_nodes_t;
typedef sl_lidar_response_measurement_node_hq_t                    rplidar_response_measurement_node_hq_t;
typedef sl_lidar_response_hq_capsule_measurement_nodes_t           rplidar_response_hq_capsule_measurement_nodes_t;


#   define RPLIDAR_CONF_SCAN_COMMAND_STD            SL_LIDAR_CONF_SCAN_COMMAND_STD
#   define RPLIDAR_CONF_SCAN_COMMAND_EXPRESS        SL_LIDAR_CONF_SCAN_COMMAND_EXPRESS
#   define RPLIDAR_CONF_SCAN_COMMAND_HQ             SL_LIDAR_CONF_SCAN_COMMAND_HQ
#   define RPLIDAR_CONF_SCAN_COMMAND_BOOST          SL_LIDAR_CONF_SCAN_COMMAND_BOOST
#   define RPLIDAR_CONF_SCAN_COMMAND_STABILITY      SL_LIDAR_CONF_SCAN_COMMAND_STABILITY
#   define RPLIDAR_CONF_SCAN_COMMAND_SENSITIVITY    SL_LIDAR_CONF_SCAN_COMMAND_SENSITIVITY

#define RPLIDAR_CONF_ANGLE_RANGE                    SL_LIDAR_CONF_ANGLE_RANGE
#define RPLIDAR_CONF_DESIRED_ROT_FREQ               SL_LIDAR_CONF_DESIRED_ROT_FREQ
#define RPLIDAR_CONF_SCAN_COMMAND_BITMAP            SL_LIDAR_CONF_SCAN_COMMAND_BITMAP
#define RPLIDAR_CONF_MIN_ROT_FREQ                   SL_LIDAR_CONF_MIN_ROT_FREQ
#define RPLIDAR_CONF_MAX_ROT_FREQ                   SL_LIDAR_CONF_MAX_ROT_FREQ
#define RPLIDAR_CONF_MAX_DISTANCE                   SL_LIDAR_CONF_MAX_DISTANCE
        
#define RPLIDAR_CONF_SCAN_MODE_COUNT                SL_LIDAR_CONF_SCAN_MODE_COUNT
#define RPLIDAR_CONF_SCAN_MODE_US_PER_SAMPLE        SL_LIDAR_CONF_SCAN_MODE_US_PER_SAMPLE
#define RPLIDAR_CONF_SCAN_MODE_MAX_DISTANCE         SL_LIDAR_CONF_SCAN_MODE_MAX_DISTANCE
#define RPLIDAR_CONF_SCAN_MODE_ANS_TYPE             SL_LIDAR_CONF_SCAN_MODE_ANS_TYPE
#define RPLIDAR_CONF_SCAN_MODE_TYPICAL              SL_LIDAR_CONF_SCAN_MODE_TYPICAL
#define RPLIDAR_CONF_SCAN_MODE_NAME                 SL_LIDAR_CONF_SCAN_MODE_NAME
#define RPLIDAR_EXPRESS_SCAN_STABILITY_BITMAP                 SL_LIDAR_EXPRESS_SCAN_STABILITY_BITMAP
#define RPLIDAR_EXPRESS_SCAN_SENSITIVITY_BITMAP               SL_LIDAR_EXPRESS_SCAN_SENSITIVITY_BITMAP
#define RPLIDAR_CONF_LIDAR_STATIC_IP_ADDR           SL_LIDAR_CONF_LIDAR_STATIC_IP_ADDR
#define RPLIDAR_CONF_LIDAR_MAC_ADDR                 SL_LIDAR_CONF_LIDAR_MAC_ADDR

#define RPLIDAR_CONF_DETECTED_SERIAL_BPS            SL_LIDAR_CONF_DETECTED_SERIAL_BPS

typedef sl_lidar_response_get_lidar_conf_t       rplidar_response_get_lidar_conf_t;
typedef sl_lidar_response_set_lidar_conf_t       rplidar_response_set_lidar_conf_t;
typedef sl_lidar_response_device_info_t          rplidar_response_device_info_t;
typedef sl_lidar_response_device_health_t        rplidar_response_device_health_t;
typedef sl_lidar_ip_conf_t                       rplidar_ip_conf_t;
typedef sl_lidar_response_device_macaddr_info_t  rplidar_response_device_macaddr_info_t;

// Definition of the variable bit scale encoding mechanism
#define RPLIDAR_VARBITSCALE_X2_SRC_BIT  SL_LIDAR_VARBITSCALE_X2_SRC_BIT
#define RPLIDAR_VARBITSCALE_X4_SRC_BIT  SL_LIDAR_VARBITSCALE_X4_SRC_BIT
#define RPLIDAR_VARBITSCALE_X8_SRC_BIT  SL_LIDAR_VARBITSCALE_X8_SRC_BIT
#define RPLIDAR_VARBITSCALE_X16_SRC_BIT SL_LIDAR_VARBITSCALE_X16_SRC_BIT

#define RPLIDAR_VARBITSCALE_X2_DEST_VAL SL_LIDAR_VARBITSCALE_X2_DEST_VAL
#define RPLIDAR_VARBITSCALE_X4_DEST_VAL SL_LIDAR_VARBITSCALE_X4_DEST_VAL
#define RPLIDAR_VARBITSCALE_X8_DEST_VAL SL_LIDAR_VARBITSCALE_X8_DEST_VAL
#define RPLIDAR_VARBITSCALE_X16_DEST_VAL SL_LIDAR_VARBITSCALE_X16_DEST_VAL

#define RPLIDAR_VARBITSCALE_GET_SRC_MAX_VAL_BY_BITS(_BITS_)   SL_LIDAR_VARBITSCALE_GET_SRC_MAX_VAL_BY_BITS(_BITS_)

#if defined(_WIN32)
#pragma pack()
#endif



================================================
File: src/rplidar_ros/sdk/include/rplidar_driver.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2019 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once
#include "sl_lidar_driver.h"

#ifndef __cplusplus
#error "The RPlidar SDK requires a C++ compiler to be built"
#endif


namespace rp { namespace standalone{ namespace rplidar {
    using namespace sl;
    typedef LidarScanMode RplidarScanMode;

enum {
   DRIVER_TYPE_SERIALPORT = 0x0,
   DRIVER_TYPE_TCP = 0x1,
   DRIVER_TYPE_UDP = 0x2,
};

class RPlidarDriver {
public:
    enum {
        DEFAULT_TIMEOUT = 2000, //2000 ms
    };

    enum {
        MAX_SCAN_NODES = 8192,
    };

    enum {
        LEGACY_SAMPLE_DURATION = 476,
    };

public:
    /// Create an RPLIDAR Driver Instance
    /// This interface should be invoked first before any other operations
    ///
    /// \param drivertype the connection type used by the driver. 
    static RPlidarDriver * CreateDriver(_u32 drivertype = CHANNEL_TYPE_SERIALPORT);
    

    RPlidarDriver(sl_u32 channelType);

    /// Dispose the RPLIDAR Driver Instance specified by the drv parameter
    /// Applications should invoke this interface when the driver instance is no longer used in order to free memory
    static void DisposeDriver(RPlidarDriver * drv);

    /// Open the specified serial port and connect to a target RPLIDAR device
    ///
    /// \param port_path     the device path of the serial port 
    ///        e.g. on Windows, it may be com3 or \\.\com10 
    ///             on Unix-Like OS, it may be /dev/ttyS1, /dev/ttyUSB2, etc
    ///
    /// \param baudrate      the baudrate used
    ///        For most RPLIDAR models, the baudrate should be set to 115200
    ///
    /// \param flag          other flags
    ///        Reserved for future use, always set to Zero
    u_result connect(const char *path, _u32 portOrBaud, _u32 flag = 0);
    
    /// Disconnect with the RPLIDAR and close the serial port
    void disconnect();

    /// Returns TRUE when the connection has been established
    bool isConnected(); 

    /// Ask the RPLIDAR core system to reset it self
    /// The host system can use the Reset operation to help RPLIDAR escape the self-protection mode.
    ///
    ///  \param timeout       The operation timeout value (in millisecond) for the serial port communication                     
    u_result reset(_u32 timeout = DEFAULT_TIMEOUT);

    u_result clearNetSerialRxCache() {
        return RESULT_OK;
    }
    // FW1.24
    /// Get all scan modes that supported by lidar
    u_result getAllSupportedScanModes(std::vector<RplidarScanMode>& outModes, _u32 timeoutInMs = DEFAULT_TIMEOUT);
   
    /// Get typical scan mode of lidar
    u_result getTypicalScanMode(_u16& outMode, _u32 timeoutInMs = DEFAULT_TIMEOUT);

    /// Start scan
    ///
    /// \param force            Force the core system to output scan data regardless whether the scanning motor is rotating or not.
    /// \param useTypicalScan   Use lidar's typical scan mode or use the compatibility mode (2k sps)
    /// \param options          Scan options (please use 0)
    /// \param outUsedScanMode  The scan mode selected by lidar
    u_result startScan(bool force, bool useTypicalScan, _u32 options = 0, RplidarScanMode* outUsedScanMode = NULL);

    /// Start scan in specific mode
    ///
    /// \param force            Force the core system to output scan data regardless whether the scanning motor is rotating or not.
    /// \param scanMode         The scan mode id (use getAllSupportedScanModes to get supported modes)
    /// \param options          Scan options (please use 0)
    /// \param outUsedScanMode  The scan mode selected by lidar
    u_result startScanExpress(bool force, _u16 scanMode, _u32 options = 0, RplidarScanMode* outUsedScanMode = NULL, _u32 timeout = DEFAULT_TIMEOUT);

    /// Retrieve the health status of the RPLIDAR
    /// The host system can use this operation to check whether RPLIDAR is in the self-protection mode.
    ///
    /// \param health        The health status info returned from the RPLIDAR
    ///
    /// \param timeout       The operation timeout value (in millisecond) for the serial port communication     
    u_result getHealth(rplidar_response_device_health_t & health, _u32 timeout = DEFAULT_TIMEOUT);

    /// Get the device information of the RPLIDAR include the serial number, firmware version, device model etc.
    /// 
    /// \param info          The device information returned from the RPLIDAR
    /// \param timeout       The operation timeout value (in millisecond) for the serial port communication  
    u_result getDeviceInfo(rplidar_response_device_info_t & info, _u32 timeout = DEFAULT_TIMEOUT);

    /// Set the RPLIDAR's motor pwm when using accessory board, currently valid for A2 only.
    /// 
    /// \param pwm           The motor pwm value would like to set 
    u_result setMotorPWM(_u16 pwm);

    /// Start RPLIDAR's motor when using accessory board
    u_result startMotor();

    /// Stop RPLIDAR's motor when using accessory board
    u_result stopMotor();

    /// Check whether the device support motor control.
    /// Note: this API will disable grab.
    /// 
    /// \param support       Return the result.
    /// \param timeout       The operation timeout value (in millisecond) for the serial port communication. 
    u_result checkMotorCtrlSupport(bool & support, _u32 timeout = DEFAULT_TIMEOUT);

	///Set LPX and S2E series lidar's static IP address
	///
	/// \param conf             Network parameter that LPX series lidar owned
	/// \param timeout          The operation timeout value (in millisecond) for the ethernet udp communication
	u_result  setLidarIpConf(const rplidar_ip_conf_t& conf, _u32 timeout = DEFAULT_TIMEOUT);

    ///Get LPX and S2E series lidar's static IP address
    ///
    /// \param conf             Network parameter that LPX series lidar owned
    /// \param timeout          The operation timeout value (in millisecond) for the ethernet udp communication
    u_result  getLidarIpConf(rplidar_ip_conf_t& conf, _u32 timeout = DEFAULT_TIMEOUT);

	///Get LPX and S2E series lidar's MAC address
	///
	/// \param macAddrArray         The device MAC information returned from the LPX series lidar
	u_result getDeviceMacAddr(_u8* macAddrArray, _u32 timeoutInMs = DEFAULT_TIMEOUT);

    /// Ask the RPLIDAR core system to stop the current scan operation and enter idle state. The background thread will be terminated
    ///
    /// \param timeout       The operation timeout value (in millisecond) for the serial port communication 
    u_result stop(_u32 timeout = DEFAULT_TIMEOUT);

    /// Wait and grab a complete 0-360 degree scan data previously received. 
    /// The grabbed scan data returned by this interface always has the following charactistics:
    ///
    /// 1) The first node of the grabbed data array (nodebuffer[0]) must be the first sample of a scan, i.e. the start_bit == 1
    /// 2) All data nodes are belong to exactly ONE complete 360-degrees's scan
    /// 3) Note, the angle data in one scan may not be ascending. You can use API ascendScanData to reorder the nodebuffer.
    ///
    /// \param nodebuffer     Buffer provided by the caller application to store the scan data
    ///
    /// \param count          The caller must initialize this parameter to set the max data count of the provided buffer (in unit of rplidar_response_measurement_node_t).
    ///                       Once the interface returns, this parameter will store the actual received data count.
    ///
    /// \param timeout        Max duration allowed to wait for a complete scan data, nothing will be stored to the nodebuffer if a complete 360-degrees' scan data cannot to be ready timely.
    ///
    /// The interface will return RESULT_OPERATION_TIMEOUT to indicate that no complete 360-degrees' scan can be retrieved withing the given timeout duration. 
    ///
    /// \The caller application can set the timeout value to Zero(0) to make this interface always returns immediately to achieve non-block operation.
    u_result grabScanDataHq(rplidar_response_measurement_node_hq_t * nodebuffer, size_t & count, _u32 timeout = DEFAULT_TIMEOUT);

    /// Ascending the scan data according to the angle value in the scan.
    ///
    /// \param nodebuffer     Buffer provided by the caller application to do the reorder. Should be retrived from the grabScanData
    ///
    /// \param count          The caller must initialize this parameter to set the max data count of the provided buffer (in unit of rplidar_response_measurement_node_t).
    ///                       Once the interface returns, this parameter will store the actual received data count.
    /// The interface will return RESULT_OPERATION_FAIL when all the scan data is invalid. 
    u_result ascendScanData(rplidar_response_measurement_node_hq_t * nodebuffer, size_t count);

    /// Return received scan points even if it's not complete scan
    ///
    /// \param nodebuffer     Buffer provided by the caller application to store the scan data
    ///
    /// \param count          Once the interface returns, this parameter will store the actual received data count.
    ///
    /// The interface will return RESULT_OPERATION_TIMEOUT to indicate that not even a single node can be retrieved since last call. 
    u_result getScanDataWithInterval(rplidar_response_measurement_node_t * nodebuffer, size_t & count);

    /// Return received scan points even if it's not complete scan
    ///
    /// \param nodebuffer     Buffer provided by the caller application to store the scan data
    ///
    /// \param count          Once the interface returns, this parameter will store the actual received data count.
    ///
    /// The interface will return RESULT_OPERATION_TIMEOUT to indicate that not even a single node can be retrieved since last call. 
    u_result getScanDataWithIntervalHq(rplidar_response_measurement_node_hq_t * nodebuffer, size_t & count);


    virtual ~RPlidarDriver();
protected:
    RPlidarDriver();

private:
    sl_u32 _channelType;
    IChannel* _channel;
    ILidarDriver* _lidarDrv;
    
};




}}}



================================================
File: src/rplidar_ros/sdk/include/rplidar_protocol.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once
#include "sl_lidar_protocol.h"
// RP-Lidar Input Packets

#define RPLIDAR_CMD_SYNC_BYTE        SL_LIDAR_CMD_SYNC_BYTE
#define RPLIDAR_CMDFLAG_HAS_PAYLOAD  SL_LIDAR_CMDFLAG_HAS_PAYLOAD


#define RPLIDAR_ANS_SYNC_BYTE1       SL_LIDAR_ANS_SYNC_BYTE1
#define RPLIDAR_ANS_SYNC_BYTE2       SL_LIDAR_ANS_SYNC_BYTE2

#define RPLIDAR_ANS_PKTFLAG_LOOP     SL_LIDAR_ANS_PKTFLAG_LOOP

#define RPLIDAR_ANS_HEADER_SIZE_MASK        SL_LIDAR_ANS_HEADER_SIZE_MASK
#define RPLIDAR_ANS_HEADER_SUBTYPE_SHIFT    SL_LIDAR_ANS_HEADER_SUBTYPE_SHIFT

#if defined(_WIN32)
#pragma pack(1)
#endif

typedef sl_lidar_cmd_packet_t rplidar_cmd_packet_t;
typedef sl_lidar_ans_header_t rplidar_ans_header_t;


#if defined(_WIN32)
#pragma pack()
#endif



================================================
File: src/rplidar_ros/sdk/include/rptypes.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2019 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once


#ifdef _WIN32

//fake stdint.h for VC only

typedef signed   char     int8_t;
typedef unsigned char     uint8_t;

typedef __int16           int16_t;
typedef unsigned __int16  uint16_t;

typedef __int32           int32_t;
typedef unsigned __int32  uint32_t;

typedef __int64           int64_t;
typedef unsigned __int64  uint64_t;

#else

#include <stdint.h>

#endif


//based on stdint.h
typedef int8_t         _s8;
typedef uint8_t        _u8;

typedef int16_t        _s16;
typedef uint16_t       _u16;

typedef int32_t        _s32;
typedef uint32_t       _u32;

typedef int64_t        _s64;
typedef uint64_t       _u64;

#define __small_endian

#ifndef __GNUC__
#define __attribute__(x)
#endif


// The _word_size_t uses actual data bus width of the current CPU
#ifdef _AVR_
typedef _u8            _word_size_t;
#define THREAD_PROC    
#elif defined (WIN64)
typedef _u64           _word_size_t;
#define THREAD_PROC    __stdcall
#elif defined (WIN32)
typedef _u32           _word_size_t;
#define THREAD_PROC    __stdcall
#elif defined (__GNUC__)
typedef unsigned long  _word_size_t;
#define THREAD_PROC   
#elif defined (__ICCARM__)
typedef _u32            _word_size_t;
#define THREAD_PROC  
#endif


typedef uint32_t u_result;

#define RESULT_OK              0
#define RESULT_FAIL_BIT        0x80000000
#define RESULT_ALREADY_DONE    0x20
#define RESULT_INVALID_DATA    (0x8000 | RESULT_FAIL_BIT)
#define RESULT_OPERATION_FAIL  (0x8001 | RESULT_FAIL_BIT)
#define RESULT_OPERATION_TIMEOUT  (0x8002 | RESULT_FAIL_BIT)
#define RESULT_OPERATION_STOP    (0x8003 | RESULT_FAIL_BIT)
#define RESULT_OPERATION_NOT_SUPPORT    (0x8004 | RESULT_FAIL_BIT)
#define RESULT_FORMAT_NOT_SUPPORT    (0x8005 | RESULT_FAIL_BIT)
#define RESULT_INSUFFICIENT_MEMORY   (0x8006 | RESULT_FAIL_BIT)

#define IS_OK(x)    ( ((x) & RESULT_FAIL_BIT) == 0 )
#define IS_FAIL(x)  ( ((x) & RESULT_FAIL_BIT) )

typedef _word_size_t (THREAD_PROC * thread_proc_t ) ( void * );



================================================
File: src/rplidar_ros/sdk/include/sl_crc.h
================================================
/*
* Slamtec LIDAR SDK
*
* sl_crc.h
*
* Copyright (c) 2020 Shanghai Slamtec Co., Ltd.
*/

/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

#include "sl_lidar_cmd.h"

namespace sl {namespace crc32 {
    sl_u32 bitrev(sl_u32 input, sl_u16 bw);//reflect
    void init(sl_u32 poly); // table init
    sl_u32 cal(sl_u32 crc, void* input, sl_u16 len);
    sl_result getResult(sl_u8 *ptr, sl_u32 len);
}}



================================================
File: src/rplidar_ros/sdk/include/sl_lidar.h
================================================
/*
* Slamtec LIDAR SDK
*
* sl_lidar.h
*
* Copyright (c) 2020 Shanghai Slamtec Co., Ltd.
*/

/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

#include "sl_lidar_driver.h"

#define SL_LIDAR_SDK_VERSION_MAJOR  2
#define SL_LIDAR_SDK_VERSION_MINOR  1
#define SL_LIDAR_SDK_VERSION_PATCH  0
#define SL_LIDAR_SDK_VERSION_SEQ    ((SL_LIDAR_SDK_VERSION_MAJOR << 16) | (SL_LIDAR_SDK_VERSION_MINOR << 8) | SL_LIDAR_SDK_VERSION_PATCH)


#define SL_LIDAR_SDK_VERSION_MK_STR_INDIR(x)  #x
#define SL_LIDAR_SDK_VERSION_MK_STR(x)        SL_LIDAR_SDK_VERSION_MK_STR_INDIR(x)

#define SL_LIDAR_SDK_VERSION        (SL_LIDAR_SDK_VERSION_MK_STR(SL_LIDAR_SDK_VERSION_MAJOR) "." SL_LIDAR_SDK_VERSION_MK_STR(SL_LIDAR_SDK_VERSION_MINOR) "." SL_LIDAR_SDK_VERSION_MK_STR(SL_LIDAR_SDK_VERSION_PATCH))



================================================
File: src/rplidar_ros/sdk/include/sl_lidar_cmd.h
================================================
/*
* Slamtec LIDAR SDK
*
* sl_lidar_cmd.h
*
* Copyright (c) 2020 Shanghai Slamtec Co., Ltd.
*/

/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4200)
#endif

#include "sl_lidar_protocol.h"

 // Commands
 //-----------------------------------------


#define SL_LIDAR_AUTOBAUD_MAGICBYTE         0x41

 // Commands without payload and response
#define SL_LIDAR_CMD_STOP                   0x25
#define SL_LIDAR_CMD_SCAN                   0x20
#define SL_LIDAR_CMD_FORCE_SCAN             0x21
#define SL_LIDAR_CMD_RESET                  0x40

// Commands with payload but no response
#define SL_LIDAR_CMD_NEW_BAUDRATE_CONFIRM   0x90 //added in fw 1.30

// Commands without payload but have response
#define SL_LIDAR_CMD_GET_DEVICE_INFO        0x50
#define SL_LIDAR_CMD_GET_DEVICE_HEALTH      0x52

#define SL_LIDAR_CMD_GET_SAMPLERATE         0x59 //added in fw 1.17

#define SL_LIDAR_CMD_HQ_MOTOR_SPEED_CTRL    0xA8


// Commands with payload and have response
#define SL_LIDAR_CMD_EXPRESS_SCAN           0x82 //added in fw 1.17
#define SL_LIDAR_CMD_HQ_SCAN                0x83 //added in fw 1.24
#define SL_LIDAR_CMD_GET_LIDAR_CONF         0x84 //added in fw 1.24
#define SL_LIDAR_CMD_SET_LIDAR_CONF         0x85 //added in fw 1.24
//add for A2 to set RPLIDAR motor pwm when using accessory board
#define SL_LIDAR_CMD_SET_MOTOR_PWM          0xF0
#define SL_LIDAR_CMD_GET_ACC_BOARD_FLAG     0xFF

#if defined(_WIN32)
#pragma pack(1)
#endif


// Payloads
// ------------------------------------------
#define SL_LIDAR_EXPRESS_SCAN_MODE_NORMAL      0 
#define SL_LIDAR_EXPRESS_SCAN_MODE_FIXANGLE    0  // won't been supported but keep to prevent build fail
//for express working flag(extending express scan protocol)
#define SL_LIDAR_EXPRESS_SCAN_FLAG_BOOST                 0x0001 
#define SL_LIDAR_EXPRESS_SCAN_FLAG_SUNLIGHT_REJECTION    0x0002

//for ultra express working flag
#define SL_LIDAR_ULTRAEXPRESS_SCAN_FLAG_STD                 0x0001 
#define SL_LIDAR_ULTRAEXPRESS_SCAN_FLAG_HIGH_SENSITIVITY    0x0002

typedef struct _sl_lidar_payload_express_scan_t
{
    sl_u8   working_mode;
    sl_u16  working_flags;
    sl_u16  param;
} __attribute__((packed)) sl_lidar_payload_express_scan_t;

typedef struct _sl_lidar_payload_hq_scan_t
{
    sl_u8  flag;
    sl_u8   reserved[32];
} __attribute__((packed)) sl_lidar_payload_hq_scan_t;

typedef struct _sl_lidar_payload_get_scan_conf_t
{
    sl_u32  type;
} __attribute__((packed)) sl_lidar_payload_get_scan_conf_t;

typedef struct _sl_payload_set_scan_conf_t {
    sl_u32  type;
} __attribute__((packed)) sl_lidar_payload_set_scan_conf_t;


#define DEFAULT_MOTOR_SPEED         (0xFFFFu)

typedef struct _sl_lidar_payload_motor_pwm_t
{
    sl_u16 pwm_value;
} __attribute__((packed)) sl_lidar_payload_motor_pwm_t;

typedef struct _sl_lidar_payload_acc_board_flag_t
{
    sl_u32 reserved;
} __attribute__((packed)) sl_lidar_payload_acc_board_flag_t;

typedef struct _sl_lidar_payload_hq_spd_ctrl_t {
    sl_u16  rpm;
} __attribute__((packed))sl_lidar_payload_hq_spd_ctrl_t;


typedef struct _sl_lidar_payload_new_bps_confirmation_t {
    sl_u16   flag; // reserved, must be 0x5F5F
    sl_u32  required_bps;
    sl_u16  param;
} __attribute__((packed)) sl_lidar_payload_new_bps_confirmation_t;

// Response
// ------------------------------------------
#define SL_LIDAR_ANS_TYPE_DEVINFO          0x4
#define SL_LIDAR_ANS_TYPE_DEVHEALTH        0x6

#define SL_LIDAR_ANS_TYPE_MEASUREMENT                       0x81
// Added in FW ver 1.17
#define SL_LIDAR_ANS_TYPE_MEASUREMENT_CAPSULED              0x82
#define SL_LIDAR_ANS_TYPE_MEASUREMENT_HQ                    0x83
//added in FW ver 1.23alpha
#define SL_LIDAR_ANS_TYPE_MEASUREMENT_CAPSULED_ULTRA        0x84
#define SL_LIDAR_ANS_TYPE_MEASUREMENT_DENSE_CAPSULED        0x85
#define SL_LIDAR_ANS_TYPE_MEASUREMENT_ULTRA_DENSE_CAPSULED  0x86


// Added in FW ver 1.17
#define SL_LIDAR_ANS_TYPE_SAMPLE_RATE      0x15

//added in FW ver 1.24
#define SL_LIDAR_ANS_TYPE_GET_LIDAR_CONF     0x20
#define SL_LIDAR_ANS_TYPE_SET_LIDAR_CONF     0x21


#define SL_LIDAR_ANS_TYPE_ACC_BOARD_FLAG   0xFF

#define SL_LIDAR_RESP_ACC_BOARD_FLAG_MOTOR_CTRL_SUPPORT_MASK      (0x1)
typedef struct _sl_lidar_response_acc_board_flag_t
{
    sl_u32 support_flag;
} __attribute__((packed)) sl_lidar_response_acc_board_flag_t;


#define SL_LIDAR_STATUS_OK                 0x0
#define SL_LIDAR_STATUS_WARNING            0x1
#define SL_LIDAR_STATUS_ERROR              0x2

#define SL_LIDAR_RESP_MEASUREMENT_SYNCBIT        (0x1<<0)
#define SL_LIDAR_RESP_MEASUREMENT_QUALITY_SHIFT  2

#define SL_LIDAR_RESP_HQ_FLAG_SYNCBIT               (0x1<<0)

#define SL_LIDAR_RESP_MEASUREMENT_CHECKBIT       (0x1<<0)
#define SL_LIDAR_RESP_MEASUREMENT_ANGLE_SHIFT    1

typedef struct _sl_lidar_response_sample_rate_t
{
    sl_u16  std_sample_duration_us;
    sl_u16  express_sample_duration_us;
} __attribute__((packed)) sl_lidar_response_sample_rate_t;

typedef struct _sl_lidar_response_measurement_node_t
{
    sl_u8    sync_quality;      // syncbit:1;syncbit_inverse:1;quality:6;
    sl_u16   angle_q6_checkbit; // check_bit:1;angle_q6:15;
    sl_u16   distance_q2;
} __attribute__((packed)) sl_lidar_response_measurement_node_t;

//[distance_sync flags]
#define SL_LIDAR_RESP_MEASUREMENT_EXP_ANGLE_MASK           (0x3)
#define SL_LIDAR_RESP_MEASUREMENT_EXP_DISTANCE_MASK        (0xFC)

typedef struct _sl_lidar_response_cabin_nodes_t
{
    sl_u16   distance_angle_1; // see [distance_sync flags]
    sl_u16   distance_angle_2; // see [distance_sync flags]
    sl_u8    offset_angles_q3;
} __attribute__((packed)) sl_lidar_response_cabin_nodes_t;


#define SL_LIDAR_RESP_MEASUREMENT_EXP_SYNC_1               0xA
#define SL_LIDAR_RESP_MEASUREMENT_EXP_SYNC_2               0x5

#define SL_LIDAR_RESP_MEASUREMENT_HQ_SYNC                  0xA5

#define SL_LIDAR_RESP_MEASUREMENT_EXP_SYNCBIT              (0x1<<15)

typedef struct _sl_lidar_response_capsule_measurement_nodes_t
{
    sl_u8                             s_checksum_1; // see [s_checksum_1]
    sl_u8                             s_checksum_2; // see [s_checksum_1]
    sl_u16                            start_angle_sync_q6;
    sl_lidar_response_cabin_nodes_t  cabins[16];
} __attribute__((packed)) sl_lidar_response_capsule_measurement_nodes_t;

typedef struct _sl_lidar_response_dense_cabin_nodes_t
{
    sl_u16   distance;
} __attribute__((packed)) sl_lidar_response_dense_cabin_nodes_t;

typedef struct _sl_lidar_response_dense_capsule_measurement_nodes_t
{
    sl_u8                             s_checksum_1; // see [s_checksum_1]
    sl_u8                             s_checksum_2; // see [s_checksum_1]
    sl_u16                            start_angle_sync_q6;
    sl_lidar_response_dense_cabin_nodes_t  cabins[40];
} __attribute__((packed)) sl_lidar_response_dense_capsule_measurement_nodes_t;


typedef struct _sl_lidar_response_ultra_dense_cabin_nodes_t {
    sl_u16  qualityl_distance_scale[2];
    sl_u8   qualityh_array;
} __attribute__((packed)) sl_lidar_response_ultra_dense_cabin_nodes_t;

typedef struct _sl_lidar_response_ultra_dense_capsule_measurement_nodes_t {
    sl_u8                             s_checksum_1; // see [s_checksum_1]
    sl_u8                             s_checksum_2; // see [s_checksum_1]
    sl_u32                            time_stamp;
    sl_u16                            dev_status;
    sl_u16                            start_angle_sync_q6;
    sl_lidar_response_ultra_dense_cabin_nodes_t  cabins[32];
} __attribute__((packed)) sl_lidar_response_ultra_dense_capsule_measurement_nodes_t;


// ext1 : x2 boost mode

#define SL_LIDAR_RESP_MEASUREMENT_EXP_ULTRA_MAJOR_BITS     12
#define SL_LIDAR_RESP_MEASUREMENT_EXP_ULTRA_PREDICT_BITS   10

typedef struct _sl_lidar_response_ultra_cabin_nodes_t
{
    // 31                                              0
    // | predict2 10bit | predict1 10bit | major 12bit |
    sl_u32 combined_x3;
} __attribute__((packed)) sl_lidar_response_ultra_cabin_nodes_t;

typedef struct _sl_lidar_response_ultra_capsule_measurement_nodes_t
{
    sl_u8                             s_checksum_1; // see [s_checksum_1]
    sl_u8                             s_checksum_2; // see [s_checksum_1]
    sl_u16                            start_angle_sync_q6;
    sl_lidar_response_ultra_cabin_nodes_t  ultra_cabins[32];
} __attribute__((packed)) sl_lidar_response_ultra_capsule_measurement_nodes_t;

typedef struct sl_lidar_response_measurement_node_hq_t
{
    sl_u16   angle_z_q14;
    sl_u32   dist_mm_q2;
    sl_u8    quality;
    sl_u8    flag;
} __attribute__((packed)) sl_lidar_response_measurement_node_hq_t;

typedef struct _sl_lidar_response_hq_capsule_measurement_nodes_t
{
    sl_u8 sync_byte;
    sl_u64 time_stamp;
    sl_lidar_response_measurement_node_hq_t node_hq[96];
    sl_u32  crc32;
}__attribute__((packed)) sl_lidar_response_hq_capsule_measurement_nodes_t;


#   define SL_LIDAR_CONF_SCAN_COMMAND_STD            0
#   define SL_LIDAR_CONF_SCAN_COMMAND_EXPRESS        1
#   define SL_LIDAR_CONF_SCAN_COMMAND_HQ             2
#   define SL_LIDAR_CONF_SCAN_COMMAND_BOOST          3
#   define SL_LIDAR_CONF_SCAN_COMMAND_STABILITY      4
#   define SL_LIDAR_CONF_SCAN_COMMAND_SENSITIVITY    5

#define SL_LIDAR_CONF_ANGLE_RANGE                    0x00000000
#define SL_LIDAR_CONF_DESIRED_ROT_FREQ               0x00000001
#define SL_LIDAR_CONF_SCAN_COMMAND_BITMAP            0x00000002
#define SL_LIDAR_CONF_MIN_ROT_FREQ                   0x00000004
#define SL_LIDAR_CONF_MAX_ROT_FREQ                   0x00000005
#define SL_LIDAR_CONF_MAX_DISTANCE                   0x00000060

#define SL_LIDAR_CONF_SCAN_MODE_COUNT                0x00000070
#define SL_LIDAR_CONF_SCAN_MODE_US_PER_SAMPLE        0x00000071
#define SL_LIDAR_CONF_SCAN_MODE_MAX_DISTANCE         0x00000074
#define SL_LIDAR_CONF_SCAN_MODE_ANS_TYPE             0x00000075
#define SL_LIDAR_CONF_LIDAR_MAC_ADDR                 0x00000079
#define SL_LIDAR_CONF_SCAN_MODE_TYPICAL              0x0000007C
#define SL_LIDAR_CONF_SCAN_MODE_NAME                 0x0000007F


#define SL_LIDAR_CONF_MODEL_REVISION_ID              0x00000080
#define SL_LIDAR_CONF_MODEL_NAME_ALIAS               0x00000081

#define SL_LIDAR_CONF_DETECTED_SERIAL_BPS            0x000000A1

#define SL_LIDAR_CONF_LIDAR_STATIC_IP_ADDR           0x0001CCC0
#define SL_LIDAR_EXPRESS_SCAN_STABILITY_BITMAP                 4
#define SL_LIDAR_EXPRESS_SCAN_SENSITIVITY_BITMAP               5

typedef struct _sl_lidar_response_get_lidar_conf
{
    sl_u32 type;
    sl_u8  payload[0];
}__attribute__((packed)) sl_lidar_response_get_lidar_conf_t;

typedef struct _sl_lidar_response_set_lidar_conf
{
    sl_u32 type;
    sl_u32 result;
}__attribute__((packed)) sl_lidar_response_set_lidar_conf_t;


typedef struct _sl_lidar_response_device_info_t
{
    sl_u8   model;
    sl_u16  firmware_version;
    sl_u8   hardware_version;
    sl_u8   serialnum[16];
} __attribute__((packed)) sl_lidar_response_device_info_t;

typedef struct _sl_lidar_response_device_health_t
{
    sl_u8   status;
    sl_u16  error_code;
} __attribute__((packed)) sl_lidar_response_device_health_t;

typedef struct _sl_lidar_ip_conf_t {
    sl_u8 ip_addr[4];
    sl_u8 net_mask[4];
    sl_u8 gw[4];
}__attribute__((packed)) sl_lidar_ip_conf_t;

typedef struct _sl_lidar_response_device_macaddr_info_t {
    sl_u8   macaddr[6];
} __attribute__((packed)) sl_lidar_response_device_macaddr_info_t;

typedef struct  _sl_lidar_response_desired_rot_speed_t{
    sl_u16 rpm;
    sl_u16 pwm_ref;
}__attribute__((packed)) sl_lidar_response_desired_rot_speed_t;

// Definition of the variable bit scale encoding mechanism
#define SL_LIDAR_VARBITSCALE_X2_SRC_BIT  9
#define SL_LIDAR_VARBITSCALE_X4_SRC_BIT  11
#define SL_LIDAR_VARBITSCALE_X8_SRC_BIT  12
#define SL_LIDAR_VARBITSCALE_X16_SRC_BIT 14

#define SL_LIDAR_VARBITSCALE_X2_DEST_VAL 512
#define SL_LIDAR_VARBITSCALE_X4_DEST_VAL 1280
#define SL_LIDAR_VARBITSCALE_X8_DEST_VAL 1792
#define SL_LIDAR_VARBITSCALE_X16_DEST_VAL 3328

#define SL_LIDAR_VARBITSCALE_GET_SRC_MAX_VAL_BY_BITS(_BITS_) \
    (  (((0x1<<(_BITS_)) - SL_LIDAR_VARBITSCALE_X16_DEST_VAL)<<4) + \
       ((SL_LIDAR_VARBITSCALE_X16_DEST_VAL - SL_LIDAR_VARBITSCALE_X8_DEST_VAL)<<3) + \
       ((SL_LIDAR_VARBITSCALE_X8_DEST_VAL - SL_LIDAR_VARBITSCALE_X4_DEST_VAL)<<2) + \
       ((SL_LIDAR_VARBITSCALE_X4_DEST_VAL - SL_LIDAR_VARBITSCALE_X2_DEST_VAL)<<1) + \
       SL_LIDAR_VARBITSCALE_X2_DEST_VAL - 1)


#if defined(_WIN32)
#pragma pack()
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif


================================================
File: src/rplidar_ros/sdk/include/sl_lidar_driver.h
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 */
 /*
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice,
  *    this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */

#pragma once

#ifndef __cplusplus
#error "The Slamtec LIDAR SDK requires a C++ compiler to be built"
#endif

#include <vector>
#include <map>
#include <string>

#ifndef DEPRECATED
    #ifdef __GNUC__
        #define DEPRECATED(func) func __attribute__ ((deprecated))
    #elif defined(_MSC_VER)
        #define DEPRECATED(func) __declspec(deprecated) func
    #else
        #pragma message("WARNING: You need to implement DEPRECATED for this compiler")
        #define DEPRECATED(func) func
    #endif
#endif


#include "sl_lidar_cmd.h"

#include <string>

namespace sl {

#ifdef DEPRECATED
#define DEPRECATED_WARN(fn, replacement) do { \
        static bool __shown__ = false; \
        if (!__shown__) { \
            printDeprecationWarn(fn, replacement); \
            __shown__ = true; \
        } \
    } while (0)
#endif

    /**
    * Lidar scan mode
    */
    struct LidarScanMode
    {
        // Mode id
        sl_u16  id;

        // Time cost for one measurement (in microseconds)
        float   us_per_sample;

        // Max distance in this scan mode (in meters)
        float   max_distance;

        // The answer command code for this scan mode
        sl_u8   ans_type;

        // The name of scan mode (padding with 0 if less than 64 characters)
        char    scan_mode[64];
    };

    template <typename T>
    struct Result
    {
        sl_result err;
        T value;
        Result(const T& value)
            : err(SL_RESULT_OK)
            , value(value)
        {
        }

        Result(sl_result err)
            : err(err)
            , value()
        {
        }

        operator sl_result() const
        {
            return err;
        }

        operator bool() const
        {
            return SL_IS_OK(err);
        }

        T& operator* ()
        {
            return value;
        }

        T* operator-> ()
        {
            return &value;
        }
    };

    enum LIDARTechnologyType {
        LIDAR_TECHNOLOGY_UNKNOWN = 0,
        LIDAR_TECHNOLOGY_TRIANGULATION = 1,
        LIDAR_TECHNOLOGY_DTOF = 2,
        LIDAR_TECHNOLOGY_ETOF = 3,
        LIDAR_TECHNOLOGY_FMCW = 4,
    };

    enum LIDARMajorType {
        LIDAR_MAJOR_TYPE_UNKNOWN = 0,
        LIDAR_MAJOR_TYPE_A_SERIES = 1,
        LIDAR_MAJOR_TYPE_S_SERIES = 2,
        LIDAR_MAJOR_TYPE_T_SERIES = 3,
        LIDAR_MAJOR_TYPE_M_SERIES = 4,
        LIDAR_MAJOR_TYPE_C_SERIES = 6,
    };

    enum LIDARInterfaceType {
        LIDAR_INTERFACE_UART = 0,
        LIDAR_INTERFACE_ETHERNET = 1,
        LIDAR_INTERFACE_USB = 2,
        LIDAR_INTERFACE_CANBUS = 5,


        LIDAR_INTERFACE_UNKNOWN = 0xFFFF,
    };

    struct SlamtecLidarTimingDesc {

        sl_u32  sample_duration_uS;
        sl_u32  native_baudrate;
        
        sl_u32  linkage_delay_uS;

        LIDARInterfaceType native_interface_type;

        bool    native_timestamp_support;
    };

    /**
    * Abstract interface of communication channel
    */
    class IChannel
    {
    public:
        virtual ~IChannel() {}

    public:
        /**
        * Open communication channel (return true if succeed)
        */
        virtual bool open() = 0;

        /**
        * Close communication channel
        */
        virtual void close() = 0;

        /**
        * Flush all written data to remote endpoint
        */
        virtual void flush() = 0;

        /**
        * Wait for some data
        * \param size Bytes to wait
        * \param timeoutInMs Wait timeout (in microseconds, -1 for forever)
        * \param actualReady [out] actual ready bytes
        * \return true for data ready
        */
        virtual bool waitForData(size_t size, sl_u32 timeoutInMs = -1, size_t* actualReady = nullptr) = 0;


        /**
        * Wait for some data
        * \param size_hint Byte count may available to retrieve without beening blocked 
        * \param timeoutInMs Wait timeout (in microseconds, -1 for forever)
        * \return RESULT_OK if there is data available for receiving
        *         RESULT_OPERATION_TIMEOUT if the given timeout duration is exceed
        *         RESULT_OPERATION_FAIL if there is something wrong with the channel
        */
        virtual sl_result waitForDataExt(size_t& size_hint, sl_u32 timeoutInMs = 1000) = 0;


        /**
        * Send data to remote endpoint
        * \param data The data buffer
        * \param size The size of data buffer (in bytes)
        * \return Bytes written (negative for write failure)
        */
        virtual int write(const void* data, size_t size) = 0;

        /**
        * Read data from the chanel
        * \param buffer The buffer to receive data
        * \param size The size of the read buffer
        * \return Bytes read (negative for read failure)
        */
        virtual int read(void* buffer, size_t size) = 0;

        /**
        * Clear read cache
        */
        virtual void clearReadCache() = 0;

        virtual int getChannelType() = 0;

    private:

    };

    /**
    * Abstract interface of serial port channel
    */
    class ISerialPortChannel : public IChannel
    {
    public:
        virtual ~ISerialPortChannel() {}

    public:
        virtual void setDTR(bool dtr) = 0;
    };

    /**
    * Create a serial channel
    * \param device Serial port device
    *                   e.g. on Windows, it may be com3 or \\.\com10
    *                   on Unix-Like OS, it may be /dev/ttyS1, /dev/ttyUSB2, etc
    * \param baudrate Baudrate
    *                   Please refer to the datasheet for the baudrate (maybe 115200 or 256000)
    */
    Result<IChannel*> createSerialPortChannel(const std::string& device, int baudrate);

    /**
    * Create a TCP channel
    * \param ip IP address of the device
    * \param port TCP port
    */
    Result<IChannel*> createTcpChannel(const std::string& ip, int port);

    /**
    * Create a UDP channel
    * \param ip IP address of the device
    * \param port UDP port
    */
    Result<IChannel*> createUdpChannel(const std::string& ip, int port);

    enum MotorCtrlSupport
    {
        MotorCtrlSupportNone = 0,
        MotorCtrlSupportPwm = 1,
        MotorCtrlSupportRpm = 2,
    };

    enum ChannelType{
        CHANNEL_TYPE_SERIALPORT = 0x0,
        CHANNEL_TYPE_TCP = 0x1,
        CHANNEL_TYPE_UDP = 0x2,
    };

        /**
    * Lidar motor info
    */
    struct LidarMotorInfo
    {
        MotorCtrlSupport motorCtrlSupport;

        // Desire speed
        sl_u16 desired_speed;

        // Max speed 
        sl_u16 max_speed;

        // Min speed
        sl_u16 min_speed;
    };

    class ILidarDriver
    {
    public:
        virtual ~ILidarDriver() {}

    public:
        /**
        * Connect to LIDAR via channel
        * \param channel The communication channel
        *                    Note: you should manage the lifecycle of the channel object, make sure it is alive during lidar driver's lifecycle
        */
        virtual sl_result connect(IChannel* channel) = 0;

        /**
        * Disconnect from the LIDAR
        */
        virtual void disconnect() = 0;
        
        /**
        * Check if the connection is established
        */
        virtual bool isConnected() = 0;

    public:
        enum
        {
            DEFAULT_TIMEOUT = 2000
        };

    public:
        /// Ask the LIDAR core system to reset it self
        /// The host system can use the Reset operation to help LIDAR escape the self-protection mode.
        ///
        ///  \param timeout       The operation timeout value (in millisecond)
        virtual sl_result reset(sl_u32 timeoutInMs = DEFAULT_TIMEOUT) = 0;

        /// Get all scan modes that supported by lidar
        virtual sl_result getAllSupportedScanModes(std::vector<LidarScanMode>& outModes, sl_u32 timeoutInMs = DEFAULT_TIMEOUT) = 0;

        /// Get typical scan mode of lidar
        virtual sl_result getTypicalScanMode(sl_u16& outMode, sl_u32 timeoutInMs = DEFAULT_TIMEOUT) = 0;

        /// Start scan
        ///
        /// \param force            Force the core system to output scan data regardless whether the scanning motor is rotating or not.
        /// \param useTypicalScan   Use lidar's typical scan mode or use the compatibility mode (2k sps)
        /// \param options          Scan options (please use 0)
        /// \param outUsedScanMode  The scan mode selected by lidar
        virtual sl_result startScan(bool force, bool useTypicalScan, sl_u32 options = 0, LidarScanMode* outUsedScanMode = nullptr) = 0;

        /// Start scan in specific mode
        ///
        /// \param force            Force the core system to output scan data regardless whether the scanning motor is rotating or not.
        /// \param scanMode         The scan mode id (use getAllSupportedScanModes to get supported modes)
        /// \param options          Scan options (please use 0)
        /// \param outUsedScanMode  The scan mode selected by lidar
        virtual sl_result startScanExpress(bool force, sl_u16 scanMode, sl_u32 options = 0, LidarScanMode* outUsedScanMode = nullptr, sl_u32 timeout = DEFAULT_TIMEOUT) = 0;

        /// Retrieve the health status of the RPLIDAR
        /// The host system can use this operation to check whether RPLIDAR is in the self-protection mode.
        ///
        /// \param health        The health status info returned from the RPLIDAR
        ///
        /// \param timeout       The operation timeout value (in millisecond) for the serial port communication     
        virtual sl_result getHealth(sl_lidar_response_device_health_t& health, sl_u32 timeout = DEFAULT_TIMEOUT) = 0;

        /// Get the device information of the RPLIDAR include the serial number, firmware version, device model etc.
        /// 
        /// \param info          The device information returned from the RPLIDAR
        /// \param timeout       The operation timeout value (in millisecond) for the serial port communication  
        virtual sl_result getDeviceInfo(sl_lidar_response_device_info_t& info, sl_u32 timeout = DEFAULT_TIMEOUT) = 0;

        /// Check whether the device support motor control
        /// Note: this API will disable grab.
        /// 
        /// \param motorCtrlSupport Return the result.
        /// \param timeout          The operation timeout value (in millisecond) for the serial port communication. 
        virtual sl_result checkMotorCtrlSupport(MotorCtrlSupport& motorCtrlSupport, sl_u32 timeout = DEFAULT_TIMEOUT) = 0;

        /// Calculate LIDAR's current scanning frequency from the given scan data
        /// Please refer to the application note doc for details
        /// Remark: the calcuation will be incorrect if the specified scan data doesn't contains enough data
        ///
        /// \param scanMode      Lidar's current scan mode
        /// \param nodes         Current scan's measurements
        /// \param count         The number of sample nodes inside the given buffer
        virtual sl_result getFrequency(const LidarScanMode& scanMode, const sl_lidar_response_measurement_node_hq_t* nodes, size_t count, float& frequency) = 0;

		///Set LPX and S2E series lidar's static IP address
		///
		/// \param conf             Network parameter that LPX series lidar owned
		/// \param timeout          The operation timeout value (in millisecond) for the ethernet udp communication
		virtual sl_result setLidarIpConf(const sl_lidar_ip_conf_t& conf, sl_u32 timeout = DEFAULT_TIMEOUT) = 0;
       
        ///Get LPX and S2E series lidar's static IP address
        ///
        /// \param conf             Network parameter that LPX series lidar owned
        /// \param timeout          The operation timeout value (in millisecond) for the ethernet udp communication
        virtual sl_result getLidarIpConf( sl_lidar_ip_conf_t& conf, sl_u32 timeout = DEFAULT_TIMEOUT) = 0;
  // 
		/////Get LPX series lidar's MAC address
		///
		/// \param macAddrArray         The device MAC information returned from the LPX series lidar
        ///                             Notice: the macAddrArray must point to a valid buffer with at least 6 bytes length
        ///                                     Otherwise, buffer overwrite will occur
		virtual sl_result getDeviceMacAddr(sl_u8* macAddrArray, sl_u32 timeoutInMs = DEFAULT_TIMEOUT) = 0;

        /// Ask the LIDAR core system to stop the current scan operation and enter idle state. The background thread will be terminated
        ///
        /// \param timeout       The operation timeout value (in millisecond) for the serial port communication 
        virtual sl_result stop(sl_u32 timeout = DEFAULT_TIMEOUT) = 0;

        /// Wait and grab a complete 0-360 degree scan data previously received. 
        /// The grabbed scan data returned by this interface always has the following charactistics:
        ///
        /// 1) The first node of the grabbed data array (nodebuffer[0]) must be the first sample of a scan, i.e. the start_bit == 1
        /// 2) All data nodes are belong to exactly ONE complete 360-degrees's scan
        /// 3) Note, the angle data in one scan may not be ascending. You can use API ascendScanData to reorder the nodebuffer.
        ///
        /// \param nodebuffer     Buffer provided by the caller application to store the scan data
        ///
        /// \param count          The caller must initialize this parameter to set the max data count of the provided buffer (in unit of rplidar_response_measurement_node_t).
        ///                       Once the interface returns, this parameter will store the actual received data count.
        ///
        /// \param timeout        Max duration allowed to wait for a complete scan data, nothing will be stored to the nodebuffer if a complete 360-degrees' scan data cannot to be ready timely.
        ///
        /// The interface will return SL_RESULT_OPERATION_TIMEOUT to indicate that no complete 360-degrees' scan can be retrieved withing the given timeout duration. 
        ///
        /// \The caller application can set the timeout value to Zero(0) to make this interface always returns immediately to achieve non-block operation.
        virtual sl_result grabScanDataHq(sl_lidar_response_measurement_node_hq_t* nodebuffer, size_t& count, sl_u32 timeout = DEFAULT_TIMEOUT) = 0;



        /// Wait and grab a complete 0-360 degree scan data previously received with timestamp support.
        /// 
        /// The returned timestamp belongs to the first data point of the scan data (begining of the scan).
        /// Its value is represented based on the current machine's time domain with the unit of microseconds (uS).
        /// 
        /// If the currently connected LIDAR supports hardware timestamp mechanism, this timestamp will use 
        /// the actual data emitted by the LIDAR device and remap it to the current machine's time domain. 
        /// 
        /// For other models that do not support hardware timestamps, this data will be deducted through estimation, 
        /// and there may be a slight deviation from the actual situation. 
        ///
        /// The grabbed scan data returned by this interface always has the following charactistics:
        ///
        /// 1) The first node of the grabbed data array (nodebuffer[0]) must be the first sample of a scan, i.e. the start_bit == 1
        /// 2) All data nodes are belong to exactly ONE complete 360-degrees's scan
        /// 3) Note, the angle data in one scan may not be ascending. You can use API ascendScanData to reorder the nodebuffer.
        ///
        /// \param nodebuffer     Buffer provided by the caller application to store the scan data
        ///
        /// \param count          The caller must initialize this parameter to set the max data count of the provided buffer (in unit of rplidar_response_measurement_node_t).
        ///                       Once the interface returns, this parameter will store the actual received data count.
        ///
        /// \param timestamp_uS   The reference used to store the timestamp value.
        /// \param timeout        Max duration allowed to wait for a complete scan data, nothing will be stored to the nodebuffer if a complete 360-degrees' scan data cannot to be ready timely.
        ///
        /// The interface will return SL_RESULT_OPERATION_TIMEOUT to indicate that no complete 360-degrees' scan can be retrieved withing the given timeout duration. 
        ///
        /// \The caller application can set the timeout value to Zero(0) to make this interface always returns immediately to achieve non-block operation.
        virtual sl_result grabScanDataHqWithTimeStamp(sl_lidar_response_measurement_node_hq_t* nodebuffer, size_t& count, sl_u64 & timestamp_uS, sl_u32 timeout = DEFAULT_TIMEOUT) = 0;


        /// Ascending the scan data according to the angle value in the scan.
        ///
        /// \param nodebuffer     Buffer provided by the caller application to do the reorder. Should be retrived from the grabScanData
        ///
        /// \param count          The caller must initialize this parameter to set the max data count of the provided buffer (in unit of rplidar_response_measurement_node_t).
        ///                       Once the interface returns, this parameter will store the actual received data count.
        /// The interface will return SL_RESULT_OPERATION_FAIL when all the scan data is invalid. 
        virtual sl_result ascendScanData(sl_lidar_response_measurement_node_hq_t* nodebuffer, size_t count) = 0;

        /// Return received scan points even if it's not complete scan
        ///
        /// \param nodebuffer     Buffer provided by the caller application to store the scan data
        ///
        /// \param count          Once the interface returns, this parameter will store the actual received data count.
        ///
        /// The interface will return SL_RESULT_OPERATION_TIMEOUT to indicate that not even a single node can be retrieved since last call. 
        virtual sl_result getScanDataWithIntervalHq(sl_lidar_response_measurement_node_hq_t* nodebuffer, size_t& count) = 0;
        /// Set lidar motor speed
        /// The host system can use this operation to set lidar motor speed.
        ///
        /// \param speed        The speed value set to lidar
        ///
        ///Note: The function will stop scan if speed is DEFAULT_MOTOR_SPEED.
        virtual sl_result setMotorSpeed(sl_u16 speed = DEFAULT_MOTOR_SPEED) = 0;
        
        /// Get the motor information of the RPLIDAR include the max speed, min speed, desired speed.
        /// 
        /// \param motorInfo          The motor information returned from the RPLIDAR
        virtual sl_result getMotorInfo(LidarMotorInfo &motorInfo, sl_u32 timeoutInMs = DEFAULT_TIMEOUT) = 0;
    

        /// Ask the LIDAR to use a new baudrate for serial communication
        /// The target LIDAR system must support such feature to work.
        /// This function does NOT check whether the target LIDAR works with the requiredBaudRate or not.
        /// In order to verifiy the result, use getDeviceInfo or other getXXXX functions instead.
        /// 
        /// \param requiredBaudRate   The new baudrate required to be used. It MUST matches with the baudrate of the binded channel.
        /// \param baudRateDetected   The actual baudrate detected by the LIDAR system
        virtual sl_result negotiateSerialBaudRate(sl_u32 requiredBaudRate, sl_u32* baudRateDetected = NULL) = 0;



        /// Get the technology of the LIDAR's measurement system
        /// 
        /// 
        /// \param devInfo   The device info used to deduct the result
        ///                  If NULL is specified, a driver cached version of the connected LIDAR will be used
        virtual LIDARTechnologyType getLIDARTechnologyType(const sl_lidar_response_device_info_t* devInfo = nullptr) = 0;
        
        
        /// Get the Major Type (Series Info) of the LIDAR
        /// 
        /// 
        /// \param devInfo   The device info used to deduct the result
        ///                  If NULL is specified, a driver cached version of the connected LIDAR will be used
        virtual LIDARMajorType getLIDARMajorType(const sl_lidar_response_device_info_t* devInfo = nullptr) = 0;


        /// Get the Model Name of the LIDAR
        /// The result will be somthing like: "A1M8" or "S1M1" or "A3M1-R1"
        /// 
        /// \param out_description   The output string that contains the generated model name
        ///                          
        /// \param fetchAliasName    If set to true, a communication will be taken to ask if there is any Alias name availabe
        /// \param devInfo           The device info used to deduct the result
        ///                          If NULL is specified, a driver cached version of the connected LIDAR will be used
        /// \param timeout           The timeout value used by potential data communication
        virtual sl_result getModelNameDescriptionString(std::string& out_description, bool fetchAliasName = true, const sl_lidar_response_device_info_t* devInfo = nullptr, sl_u32 timeout = DEFAULT_TIMEOUT) = 0;

};

    /**
    * Create a LIDAR driver instance
    *
    * Example
    * Result<ISerialChannel*> channel = createSerialPortChannel("/dev/ttyUSB0", 115200);
    * assert((bool)channel);
    * assert(*channel);
    *
    * auto lidar = createLidarDriver();
    * assert((bool)lidar);
    * assert(*lidar);
    *
    * auto res = (*lidar)->connect(*channel);
    * assert(SL_IS_OK(res));
    *
    * sl_lidar_response_device_info_t deviceInfo;
    * res = (*lidar)->getDeviceInfo(deviceInfo);
    * assert(SL_IS_OK(res));
    *
    * printf("Model: %d, Firmware Version: %d.%d, Hardware Version: %d\n",
    *        deviceInfo.model,
    *        deviceInfo.firmware_version >> 8, deviceInfo.firmware_version & 0xffu,
    *        deviceInfo.hardware_version);
    *
    * delete *lidar;
    * delete *channel;
    */
    Result<ILidarDriver*> createLidarDriver();
}



================================================
File: src/rplidar_ros/sdk/include/sl_lidar_driver_impl.h
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 */
 /*
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice,
  *    this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */

#pragma once
#include "sl_lidar_driver.h"

namespace sl {
	class SL_LidarDriver :public ILidarDriver
	{
		public:
			enum {
				LEGACY_SAMPLE_DURATION = 476,
			};

			enum
			{
					NORMAL_CAPSULE = 0,
					DENSE_CAPSULE = 1,
			};

			enum {
				A2A3_LIDAR_MINUM_MAJOR_ID  = 2,
				TOF_LIDAR_MINUM_MAJOR_ID = 6,
			};
		public:
			SL_LidarDriver()
				:_channel(NULL)
				, _isConnected(false)
				, _isScanning(false)
				, _isSupportingMotorCtrl(MotorCtrlSupportNone)
				, _cached_sampleduration_std(LEGACY_SAMPLE_DURATION)
				,_cached_sampleduration_express(LEGACY_SAMPLE_DURATION)
				, _cached_scan_node_hq_count(0)
				, _cached_scan_node_hq_count_for_interval_retrieve(0)
			{}

			sl_result connect(IChannel* channel);
			void disconnect();
			bool isConnected();
			sl_result reset(sl_u32 timeoutInMs = DEFAULT_TIMEOUT);
			sl_result getAllSupportedScanModes(std::vector<LidarScanMode>& outModes, sl_u32 timeoutInMs = DEFAULT_TIMEOUT);
			sl_result getTypicalScanMode(sl_u16& outMode, sl_u32 timeoutInMs = DEFAULT_TIMEOUT);
			sl_result startScan(bool force, bool useTypicalScan, sl_u32 options = 0, LidarScanMode* outUsedScanMode = nullptr);
			sl_result startScanNormal(bool force, sl_u32 timeout = DEFAULT_TIMEOUT);
			sl_result startScanExpress(bool force, sl_u16 scanMode, sl_u32 options = 0, LidarScanMode* outUsedScanMode = nullptr, sl_u32 timeout = DEFAULT_TIMEOUT);
			sl_result stop(sl_u32 timeout = DEFAULT_TIMEOUT);
			DEPRECATED(sl_result grabScanData(sl_lidar_response_measurement_node_t * nodebuffer, size_t& count, sl_u32 timeout = DEFAULT_TIMEOUT));
			sl_result grabScanDataHq(sl_lidar_response_measurement_node_hq_t* nodebuffer, size_t& count, sl_u32 timeout = DEFAULT_TIMEOUT);
			sl_result getDeviceInfo(sl_lidar_response_device_info_t& info, sl_u32 timeout = DEFAULT_TIMEOUT);
			sl_result checkMotorCtrlSupport(MotorCtrlSupport & support, sl_u32 timeout = DEFAULT_TIMEOUT);
			sl_result getFrequency(const LidarScanMode& scanMode, const sl_lidar_response_measurement_node_hq_t* nodes, size_t count, float& frequency);
			sl_result setLidarIpConf(const sl_lidar_ip_conf_t& conf, sl_u32 timeout);
			sl_result getLidarIpConf(sl_lidar_ip_conf_t& conf, sl_u32 timeout);
			sl_result getHealth(sl_lidar_response_device_health_t& health, sl_u32 timeout = DEFAULT_TIMEOUT);
			sl_result getDeviceMacAddr(sl_u8* macAddrArray, sl_u32 timeoutInMs);
			sl_result ascendScanData(sl_lidar_response_measurement_node_t * nodebuffer, size_t count);
			sl_result ascendScanData(sl_lidar_response_measurement_node_hq_t * nodebuffer, size_t count);
			sl_result getScanDataWithIntervalHq(sl_lidar_response_measurement_node_hq_t * nodebuffer, size_t & count);
			sl_result setMotorSpeed(sl_u16 speed = DEFAULT_MOTOR_PWM);//
			sl_result negotiateSerialBaudRate(sl_u32 requiredBaudRate, sl_u32* baudRateDetected = NULL);
	
	protected:
			sl_result startMotor();
			sl_result checkSupportConfigCommands(bool& outSupport, sl_u32 timeoutInMs = DEFAULT_TIMEOUT);
			sl_result getScanModeCount(sl_u16& modeCount, sl_u32 timeoutInMs = DEFAULT_TIMEOUT);
			sl_result setLidarConf(sl_u32 type, const void* payload, size_t payloadSize, sl_u32 timeout);
			sl_result getLidarConf(sl_u32 type, std::vector<sl_u8> &outputBuf, const std::vector<sl_u8> &reserve = std::vector<sl_u8>(), sl_u32 timeout = DEFAULT_TIMEOUT);
			sl_result getLidarSampleDuration(float& sampleDurationRes, sl_u16 scanModeID, sl_u32 timeoutInMs = DEFAULT_TIMEOUT);
			sl_result getMaxDistance(float &maxDistance, sl_u16 scanModeID, sl_u32 timeoutInMs = DEFAULT_TIMEOUT);
			sl_result getScanModeAnsType(sl_u8 &ansType, sl_u16 scanModeID, sl_u32 timeoutInMs = DEFAULT_TIMEOUT);
			sl_result getScanModeName(char* modeName, sl_u16 scanModeID, sl_u32 timeoutInMs = DEFAULT_TIMEOUT);
			//DEPRECATED(sl_result getSampleDuration_uS(sl_lidar_response_sample_rate_t & rateInfo, sl_u32 timeout = DEFAULT_TIMEOUT));
			//DEPRECATED (sl_result checkExpressScanSupported(bool & support, sl_u32 timeout = DEFAULT_TIMEOUT));
			//DEPRECATED(sl_result getFrequency(bool inExpressMode, size_t count, float & frequency, bool & is4kmode));
		private:
			sl_result  _sendCommand(sl_u16 cmd, const void * payload = NULL, size_t payloadsize = 0 );
			sl_result _waitResponseHeader(sl_lidar_ans_header_t * header, sl_u32 timeout = DEFAULT_TIMEOUT);
			template <typename T>
			sl_result _waitResponse(T &payload ,sl_u8 ansType, sl_u32 timeout = DEFAULT_TIMEOUT);
			void _disableDataGrabbing();
			sl_result _waitNode(sl_lidar_response_measurement_node_t * node, sl_u32 timeout = DEFAULT_TIMEOUT);
			sl_result _waitScanData(sl_lidar_response_measurement_node_t * nodebuffer, size_t & count, sl_u32 timeout = DEFAULT_TIMEOUT);
			sl_result _cacheScanData();
			void _ultraCapsuleToNormal(const sl_lidar_response_ultra_capsule_measurement_nodes_t & capsule, sl_lidar_response_measurement_node_hq_t *nodebuffer, size_t &nodeCount);
			sl_result _waitCapsuledNode(sl_lidar_response_capsule_measurement_nodes_t & node, sl_u32 timeout = DEFAULT_TIMEOUT);
			void _capsuleToNormal(const sl_lidar_response_capsule_measurement_nodes_t & capsule, sl_lidar_response_measurement_node_hq_t *nodebuffer, size_t &nodeCount);
			void _dense_capsuleToNormal(const sl_lidar_response_capsule_measurement_nodes_t & capsule, sl_lidar_response_measurement_node_hq_t *nodebuffer, size_t &nodeCount);
			sl_result _cacheCapsuledScanData();

			void _ultra_dense_capsuleToNormal(const sl_lidar_response_ultra_dense_capsule_measurement_nodes_t& capslue, sl_lidar_response_measurement_node_hq_t* nodebuffer, size_t& nodeCount);
			sl_result _waitUltraDenseCapsuledNode(sl_lidar_response_ultra_dense_capsule_measurement_nodes_t& node, sl_u32 timeout = DEFAULT_TIMEOUT);
			sl_result _cacheUltraDenseCapsuledScanData();
			

			sl_result _waitHqNode(sl_lidar_response_hq_capsule_measurement_nodes_t & node, sl_u32 timeout = DEFAULT_TIMEOUT);
			void _HqToNormal(const sl_lidar_response_hq_capsule_measurement_nodes_t & node_hq, sl_lidar_response_measurement_node_hq_t *nodebuffer, size_t &nodeCount);
			sl_result _cacheHqScanData();
			sl_result _waitUltraCapsuledNode(sl_lidar_response_ultra_capsule_measurement_nodes_t & node, sl_u32 timeout = DEFAULT_TIMEOUT);
			sl_result _cacheUltraCapsuledScanData();
			sl_result _clearRxDataCache();

		private:
			IChannel *_channel;
			bool _isConnected;
			bool _isScanning;
			MotorCtrlSupport _isSupportingMotorCtrl;

			rp::hal::Locker         _lock;
			rp::hal::Event          _dataEvt;
			rp::hal::Thread         _cachethread;
			sl_u16                    _cached_sampleduration_std;
			sl_u16                    _cached_sampleduration_express;

			sl_lidar_response_measurement_node_hq_t   _cached_scan_node_hq_buf[8192];
			size_t                                   _cached_scan_node_hq_count;
			sl_u8                                    _cached_capsule_flag;

			sl_lidar_response_measurement_node_hq_t   _cached_scan_node_hq_buf_for_interval_retrieve[8192];
			size_t                                   _cached_scan_node_hq_count_for_interval_retrieve;

			sl_lidar_response_capsule_measurement_nodes_t       _cached_previous_capsuledata;
			sl_lidar_response_dense_capsule_measurement_nodes_t _cached_previous_dense_capsuledata;
			sl_lidar_response_ultra_capsule_measurement_nodes_t _cached_previous_ultracapsuledata;
			sl_lidar_response_hq_capsule_measurement_nodes_t _cached_previous_Hqdata;
			bool                                         _is_previous_capsuledataRdy;
			bool                                         _is_previous_HqdataRdy;
	};

}



================================================
File: src/rplidar_ros/sdk/include/sl_lidar_protocol.h
================================================
/*
* Slamtec LIDAR SDK
*
* sl_lidar_protocol.h
*
* Copyright (c) 2020 Shanghai Slamtec Co., Ltd.
*/

/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once


#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4200)
#endif

#include "sl_types.h"

#define SL_LIDAR_CMD_SYNC_BYTE              0xA5
#define SL_LIDAR_CMDFLAG_HAS_PAYLOAD        0x80

#define SL_LIDAR_ANS_SYNC_BYTE1             0xA5
#define SL_LIDAR_ANS_SYNC_BYTE2             0x5A

#define SL_LIDAR_ANS_PKTFLAG_LOOP           0x1

#define SL_LIDAR_ANS_HEADER_SIZE_MASK       0x3FFFFFFF
#define SL_LIDAR_ANS_HEADER_SUBTYPE_SHIFT   (30)

#if defined(_WIN32)
#pragma pack(1)
#endif



typedef struct sl_lidar_cmd_packet_t
{
    sl_u8 syncByte; //must be SL_LIDAR_CMD_SYNC_BYTE
    sl_u8 cmd_flag;
    sl_u8 size;
    sl_u8 data[0];
} __attribute__((packed)) sl_lidar_cmd_packet_t;


typedef struct sl_lidar_ans_header_t
{
    sl_u8  syncByte1; // must be SL_LIDAR_ANS_SYNC_BYTE1
    sl_u8  syncByte2; // must be SL_LIDAR_ANS_SYNC_BYTE2
    sl_u32 size_q30_subtype; // see _u32 size:30; _u32 subType:2;
    sl_u8  type;
} __attribute__((packed)) sl_lidar_ans_header_t;

#if defined(_WIN32)
#pragma pack()
#endif


#if defined(_MSC_VER)
#pragma warning(pop)
#endif


================================================
File: src/rplidar_ros/sdk/include/sl_types.h
================================================
/*
* Slamtec LIDAR SDK
*
* sl_types.h
*
* Copyright (c) 2020 Shanghai Slamtec Co., Ltd. 
*/

/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

#ifdef __cplusplus
#include <cstdint>

#define SL_DEFINE_TYPE(IntType, NewType)    typedef std::IntType NewType
#else
#include <stdint.h>

#define SL_DEFINE_TYPE(IntType, NewType)    typedef IntType NewType
#endif

#define SL_DEFINE_INT_TYPE(Bits) \
    SL_DEFINE_TYPE(int ## Bits ## _t, sl_s ## Bits); \
    SL_DEFINE_TYPE(uint ## Bits ## _t, sl_u ## Bits); \

SL_DEFINE_INT_TYPE(8)
SL_DEFINE_INT_TYPE(16)
SL_DEFINE_INT_TYPE(32)
SL_DEFINE_INT_TYPE(64)

#if !defined(__GNUC__) && !defined(__attribute__)
#   define __attribute__(x)
#endif

#ifdef WIN64
typedef sl_u64          sl_word_size_t;
#elif defined(WIN32)
typedef sl_u32          sl_word_size_t;
#elif defined(__GNUC__)
typedef unsigned long   sl_word_size_t;
#elif defined(__ICCARM__)
typedef sl_u32          sl_word_size_t;
#endif

typedef uint32_t sl_result;

#define SL_RESULT_OK                     (sl_result)0
#define SL_RESULT_FAIL_BIT               (sl_result)0x80000000
#define SL_RESULT_ALREADY_DONE           (sl_result)0x20
#define SL_RESULT_INVALID_DATA           (sl_result)(0x8000 | SL_RESULT_FAIL_BIT)
#define SL_RESULT_OPERATION_FAIL         (sl_result)(0x8001 | SL_RESULT_FAIL_BIT)
#define SL_RESULT_OPERATION_TIMEOUT      (sl_result)(0x8002 | SL_RESULT_FAIL_BIT)
#define SL_RESULT_OPERATION_STOP         (sl_result)(0x8003 | SL_RESULT_FAIL_BIT)
#define SL_RESULT_OPERATION_NOT_SUPPORT  (sl_result)(0x8004 | SL_RESULT_FAIL_BIT)
#define SL_RESULT_FORMAT_NOT_SUPPORT     (sl_result)(0x8005 | SL_RESULT_FAIL_BIT)
#define SL_RESULT_INSUFFICIENT_MEMORY    (sl_result)(0x8006 | SL_RESULT_FAIL_BIT)

#define SL_IS_OK(x)    ( ((x) & SL_RESULT_FAIL_BIT) == 0 )
#define SL_IS_FAIL(x)  ( ((x) & SL_RESULT_FAIL_BIT) )



================================================
File: src/rplidar_ros/sdk/src/rplidar_driver.cpp
================================================
/*
 * Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
 /*
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice,
  *    this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */

#include "sdkcommon.h"
#include "hal/abs_rxtx.h"
#include "hal/thread.h"
#include "hal/types.h"
#include "hal/assert.h"
#include "hal/locker.h"
#include "hal/socket.h"
#include "hal/event.h"
#include "rplidar_driver.h"
#include "sl_crc.h" 
#include <algorithm>

namespace rp { namespace standalone{ namespace rplidar {

    RPlidarDriver::RPlidarDriver(){}

    RPlidarDriver::RPlidarDriver(sl_u32 channelType) 
        :_channelType(channelType)
    {
    }

    RPlidarDriver::~RPlidarDriver() {}

    RPlidarDriver * RPlidarDriver::CreateDriver(_u32 drivertype)
    {
        //_channelType = drivertype;
        return  new RPlidarDriver(drivertype);
    }

    void RPlidarDriver::DisposeDriver(RPlidarDriver * drv)
    {
        delete drv;
    }

    u_result RPlidarDriver::connect(const char *path, _u32 portOrBaud, _u32 flag)
    {
        switch (_channelType)
        {
        case CHANNEL_TYPE_SERIALPORT:
            _channel = (*createSerialPortChannel(path, portOrBaud));
            break;
        case CHANNEL_TYPE_TCP:
            _channel = *createTcpChannel(path, portOrBaud);
            break;
        case CHANNEL_TYPE_UDP:
            _channel = *createUdpChannel(path, portOrBaud);
            break;
        }
        if (!(bool)_channel) return SL_RESULT_OPERATION_FAIL;
        
        _lidarDrv = *createLidarDriver();

        if (!(bool)_lidarDrv) return SL_RESULT_OPERATION_FAIL;

        sl_result ans =(_lidarDrv)->connect(_channel);
        return ans;
    }

    void RPlidarDriver::disconnect()
    {
        (_lidarDrv)->disconnect();
    }

    bool RPlidarDriver::isConnected() 
    { 
        return (_lidarDrv)->isConnected();
    }
     
    u_result RPlidarDriver::reset(_u32 timeout)
    {
        return (_lidarDrv)->reset();
    }

    u_result RPlidarDriver::getAllSupportedScanModes(std::vector<RplidarScanMode>& outModes, _u32 timeoutInMs)
    {
        return (_lidarDrv)->getAllSupportedScanModes(outModes, timeoutInMs);
    }

    u_result RPlidarDriver::getTypicalScanMode(_u16& outMode, _u32 timeoutInMs)
    {
        return (_lidarDrv)->getTypicalScanMode(outMode, timeoutInMs);
    }

    u_result RPlidarDriver::startScan(bool force, bool useTypicalScan, _u32 options, RplidarScanMode* outUsedScanMode)
    {
        return (_lidarDrv)->startScan(force, useTypicalScan, options, outUsedScanMode);
    }

    u_result RPlidarDriver::startScanExpress(bool force, _u16 scanMode, _u32 options, RplidarScanMode* outUsedScanMode, _u32 timeout)
    {
        return (_lidarDrv)->startScanExpress(force, scanMode, options, outUsedScanMode, timeout);
    }
    
    u_result RPlidarDriver::getHealth(rplidar_response_device_health_t & health, _u32 timeout)
    {
        return (_lidarDrv)->getHealth(health, timeout);
    }

    u_result RPlidarDriver::getDeviceInfo(rplidar_response_device_info_t & info, _u32 timeout)
    {
        return (_lidarDrv)->getDeviceInfo(info, timeout);
    }

    u_result RPlidarDriver::setMotorPWM(_u16 pwm)
    {
        return (_lidarDrv)->setMotorSpeed(pwm);
    }   
    
    u_result RPlidarDriver::checkMotorCtrlSupport(bool & support, _u32 timeout)
    {
        MotorCtrlSupport motorSupport;
        u_result ans = (_lidarDrv)->checkMotorCtrlSupport(motorSupport, timeout);
        if (motorSupport == MotorCtrlSupportNone)
            support = false;
        return ans;
    }

    u_result RPlidarDriver::setLidarIpConf(const rplidar_ip_conf_t& conf, _u32 timeout)
	{
		return (_lidarDrv)->setLidarIpConf(conf, timeout);
	}

    u_result RPlidarDriver::getLidarIpConf(rplidar_ip_conf_t& conf, _u32 timeout)
    {
        return (_lidarDrv)->getLidarIpConf(conf, timeout);
    }

    u_result RPlidarDriver::getDeviceMacAddr(_u8* macAddrArray, _u32 timeoutInMs)
	{
		return (_lidarDrv)->getDeviceMacAddr(macAddrArray, timeoutInMs);
	}

    u_result RPlidarDriver::stop(_u32 timeout) 
    { 
        return (_lidarDrv)->stop(timeout);
    }

    u_result RPlidarDriver::grabScanDataHq(rplidar_response_measurement_node_hq_t * nodebuffer, size_t & count, _u32 timeout)
    {
        return (_lidarDrv)->grabScanDataHq(nodebuffer, count, timeout);
    }

    u_result RPlidarDriver::ascendScanData(rplidar_response_measurement_node_hq_t * nodebuffer, size_t count)
    {
        return (_lidarDrv)->ascendScanData(nodebuffer, count);
    }
    
    u_result RPlidarDriver::getScanDataWithInterval(rplidar_response_measurement_node_t * nodebuffer, size_t & count)
    {
        return RESULT_OPERATION_NOT_SUPPORT;
    }

    u_result RPlidarDriver::getScanDataWithIntervalHq(rplidar_response_measurement_node_hq_t * nodebuffer, size_t & count)
    {
        return (_lidarDrv)->getScanDataWithIntervalHq(nodebuffer, count);
    }

    u_result RPlidarDriver::startMotor()
    {
        return (_lidarDrv)->setMotorSpeed(DEFAULT_MOTOR_SPEED);
    }
    u_result RPlidarDriver::stopMotor()
    {
        return (_lidarDrv)->setMotorSpeed(0);
    }

}}}



================================================
File: src/rplidar_ros/sdk/src/sdkcommon.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#if defined(_WIN32)

#include "arch/win32/arch_win32.h"
#elif defined(_MACOS)
#include "arch/macOS/arch_macOS.h"
#elif defined(__GNUC__)
#include "arch/linux/arch_linux.h"
#else
#error "unsupported target"
#endif

#include "hal/types.h"
#include "hal/assert.h"

#include "rplidar.h"

#include "hal/util.h"


================================================
File: src/rplidar_ros/sdk/src/sl_async_transceiver.cpp
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
 /*
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice,
  *    this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */



#include "sdkcommon.h"
#include "hal/abs_rxtx.h"
#include "hal/thread.h"
#include "hal/types.h"
#include "hal/assert.h"
#include "hal/locker.h"
#include "hal/socket.h"
#include "hal/event.h"

#include "sl_async_transceiver.h"



namespace sl { namespace internal {




ProtocolMessage::ProtocolMessage()
        : len(0)
        , cmd(0)
        , data(NULL)
        , _databufsize(0)
		, _usingOutterData(false)
{
    _changeBufSize();
}

ProtocolMessage::ProtocolMessage(_u8 cmd, const void* buffer, size_t size)
	: len(size)
	, cmd(cmd)
	, data(NULL)
    , _databufsize(0)
	, _usingOutterData(false)
{
    _changeBufSize();
	if (buffer)
	{
		memcpy(data, buffer, size);
	}
}

ProtocolMessage::ProtocolMessage(const ProtocolMessage& srcMsg)
	: len(srcMsg.len)
	, cmd(srcMsg.cmd)
	, data(NULL)
    , _databufsize(0)
	, _usingOutterData(false)
{
    _changeBufSize( true );
	if (srcMsg.data && len)
	{
		memcpy(data, srcMsg.data, len);
	}
}

ProtocolMessage::~ProtocolMessage()
{
	this->cleanData();
}

ProtocolMessage& ProtocolMessage::operator =(const ProtocolMessage& srcMessage)
{
	this->cleanData();


	this->len = srcMessage.len;
	this->cmd = srcMessage.cmd;

    _changeBufSize( true );
	if (srcMessage.data && len)
	{
		memcpy(data, srcMessage.data, len);
	}

	return *this;
}

void ProtocolMessage::setDataBuf(_u8 *buffer, size_t size)
{
	this->cleanData();

	len = size;
	data = buffer;
    _databufsize = size;
	_usingOutterData = true;
}

void ProtocolMessage::fillData(const void * buffer, size_t size)
{
	len = size;
    _changeBufSize();
    if (buffer)
	    memcpy(data, buffer, size);
}

void ProtocolMessage::cleanData()
{
	if (data) 
	{
		if (!_usingOutterData)
		{
			delete [] data;
		}
		data = NULL;
		len = 1;
        _databufsize = 0;
	}
}

void ProtocolMessage::_changeBufSize( bool force_compact)
{
    size_t actual_size  = getPayloadSize();

    size_t new_buf_size = actual_size;


    if (!_usingOutterData)
    {
        // nothing to do
        if ( new_buf_size == _databufsize ) return;

        if ( new_buf_size < _databufsize){

            if ( (_databufsize >> 1) < new_buf_size)
            {
                // reuse the current buffer
                if (!force_compact) return;
            }else
            {
                // the current buffer size is much bigger, we need to release it to save memory
            }
        }
    }

    // we need to change the buffer
    cleanData();
    // the cleanData() will reset the length info, so we need to restore it
    len = actual_size;
    data = new _u8[new_buf_size];
    _databufsize = new_buf_size;
}


AsyncTransceiver::AsyncTransceiver(IAsyncProtocolCodec& codec)
	: _bindedChannel(NULL)
	, _codec(codec)
	, _isWorking(false)
    , _workingFlag(0)
{

}

AsyncTransceiver::~AsyncTransceiver()
{
    unbindAndClose();
}

u_result AsyncTransceiver::openChannelAndBind(IChannel* channel)
{
    if (!channel) return RESULT_INVALID_DATA;

    unbindAndClose();
	u_result ans = RESULT_OK;
	do 
	{
		rp::hal::AutoLocker l(_opLocker);

        // try to open the channel ...
        Result<nullptr_t> ans = SL_RESULT_OK;

        if (!channel->open()) {
            ans= RESULT_OPERATION_FAIL;
            break;
        }


        // force a flush to clear any pending data
        channel->flush();

		_dataEvt.set(false);

		_isWorking = true;
        _workingFlag = 0;
        _bindedChannel = channel;


		_decoderThread = CLASS_THREAD(AsyncTransceiver, _proc_decoderThread);
		_rxThread = CLASS_THREAD(AsyncTransceiver, _proc_rxThread);

        


	} while (0);

	return ans;
}

void AsyncTransceiver::unbindAndClose()
{
	rp::hal::AutoLocker l(_opLocker);
	if (!_isWorking) return;

    assert(_bindedChannel);

    
	_isWorking = false;
	_dataEvt.set(); // set signal to wake up threads

	_decoderThread.join();
	_rxThread.join();


    _bindedChannel->close();

    _bindedChannel = NULL;


    for (std::list< Buffer* >::iterator itr = _rxQueue.begin(); itr != _rxQueue.end(); ++itr)
    {
        delete [] *itr;
    }
    _rxQueue.clear();

}

u_result AsyncTransceiver::sendMessage(message_autoptr_t& msg)
{
    assert(msg);

    if (!_isWorking) return RESULT_OPERATION_NOT_SUPPORT;

    rp::hal::AutoLocker l(_opLocker);

    size_t requiredBufferSize = _codec.estimateLength(msg);

    if (requiredBufferSize == 0) {
        // nothing to send
        return RESULT_OK;
    }

    u_result ans = RESULT_OK;

    _u8* txBuffer = new _u8[requiredBufferSize];

    do {
  
        if (!txBuffer) {
            return RESULT_INSUFFICIENT_MEMORY;
        }

        _codec.onEncodeData(msg, txBuffer, &requiredBufferSize);

        int txSize = _bindedChannel->write(txBuffer, requiredBufferSize);

        if (txSize < 0) ans = RESULT_OPERATION_FAIL;

    } while (0);


    delete[] txBuffer;
    return ans;
}

sl_result AsyncTransceiver::_proc_rxThread()
{
    assert(_bindedChannel);

    rp::hal::Thread::SetSelfPriority(rp::hal::Thread::PRIORITY_HIGH);

    u_result result;
    size_t hintedSize = 0;
    while (_isWorking)
    {
        result = _bindedChannel->waitForDataExt(hintedSize, 1000);

        if (IS_FAIL(result))
        {
            // timeout is allowed
            if (result == RESULT_OPERATION_TIMEOUT) {
                continue;
            }
            if (_isWorking) {
                _workingFlag |= WORKING_FLAG_ERROR;
                _codec.onChannelError(result);
                break;
            }
        }

        // no data in buffer, sleep and wait for the next round
        if (!hintedSize)
        {
            continue;
        }


        Buffer* decodeBuffer = new Buffer();
        
        decodeBuffer->data = new _u8[hintedSize];

        decodeBuffer->size = _bindedChannel->read(decodeBuffer->data, hintedSize);
#ifdef _DEBUG_DUMP_PACKET
        printf("Revc: %d\n", decodeBuffer->size);
#endif
         
        if  (!decodeBuffer->size) {
            delete decodeBuffer;

            
            _workingFlag |= WORKING_FLAG_ERROR;
            _codec.onChannelError(RESULT_OPERATION_ABORTED);
            break;
        }

        assert(hintedSize >= decodeBuffer->size);


#ifdef _DEBUG_DUMP_PACKET
        printf("=== Dump RX Packet, size = %d ===\n", decodeBuffer->size);
        for (int pos = 0; pos < decodeBuffer->size; pos++)
        {
            printf("%02x ", decodeBuffer->data[pos]);
        }
        printf("\n=== END ===\n");
#endif

        _rxLocker.lock();
        _rxQueue.push_back(decodeBuffer);
        _dataEvt.set();
        _rxLocker.unlock();


    }
    _workingFlag |= WORKING_FLAG_RX_DISABLED;
    return RESULT_OK;
}

sl_result AsyncTransceiver::_proc_decoderThread()
{

    assert(_bindedChannel);
    rp::hal::Thread::SetSelfPriority(rp::hal::Thread::PRIORITY_HIGH);
    _codec.onDecodeReset();
    

    while (_isWorking)
    {
        _rxLocker.lock();

        if (_rxQueue.empty())
        {
            _rxLocker.unlock();

            if (_dataEvt.wait(1000))
                continue;

            _rxLocker.lock();
        }
        assert(!_rxQueue.empty());

        Buffer * bufferToDecode = _rxQueue.front();
        _rxQueue.pop_front();

        _rxLocker.unlock();

        //cout<<"decoding "<< bufferToDecode->size <<" bytes of data"<<endl;
        _codec.onDecodeData(bufferToDecode->data, bufferToDecode->size);


        delete bufferToDecode;
    }

    return RESULT_OK;

}


}}


================================================
File: src/rplidar_ros/sdk/src/sl_async_transceiver.h
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
 /*
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice,
  *    this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */

#pragma once

#include <list>
#include <memory>

namespace sl { namespace internal {


class _single_thread ProtocolMessage {

public:
	size_t len;			
	_u8 cmd;
protected:
	_u8* data;
	size_t _databufsize;

public:
	ProtocolMessage();
	ProtocolMessage(_u8 cmd, const void* buffer, size_t size);
	ProtocolMessage(const ProtocolMessage& srcMsg);
	virtual ~ProtocolMessage();

	ProtocolMessage& operator=(const ProtocolMessage& srcMessage);

	// avoid use this method, pls. use fillData instead
	void setDataBuf(_u8* buffer, size_t size);

	_u8* getDataBuf() { return data; }

	void fillData(const void* buffer, size_t size);
	void cleanData();

	size_t getPayloadSize() const
	{
		return len;
	}

protected:

	// change the data buffer to fix the new payload size
	// the existing buffer will be reused if possible.
	// all the existing payload data will lose
	void _changeBufSize(bool force_compact = false);
	bool _usingOutterData;
};



typedef std::shared_ptr<ProtocolMessage> message_autoptr_t;


class IAsyncProtocolCodec {
public:
	IAsyncProtocolCodec() {}
	virtual ~IAsyncProtocolCodec()  {}

	virtual void   onChannelError(u_result errCode) {}

	virtual void   onDecodeReset() {}
	virtual void   onDecodeData(const void* buffer, size_t size) = 0;


	virtual size_t estimateLength(message_autoptr_t& message) = 0;
	virtual void   onEncodeData(message_autoptr_t& message, _u8* txbuffer, size_t* size) = 0;

};

class AsyncTransceiver {
public:

	enum working_flag_t
	{
		WORKING_FLAG_RX_DISABLED = 0x1L << 0,
		WORKING_FLAG_TX_DISABLED = 0x1L << 1,

		WORKING_FLAG_ERROR = 0x1L << 31,
	};


	AsyncTransceiver(IAsyncProtocolCodec& codec);
	~AsyncTransceiver();



	u_result openChannelAndBind(IChannel* channel);
	void     unbindAndClose();

	IChannel* getBindedChannel() const {
		return _bindedChannel;
	}
	
	u_result sendMessage(message_autoptr_t& msg);

protected:

	sl_result _proc_rxThread();
	sl_result _proc_decoderThread();

protected:


	rp::hal::Locker _opLocker;
	rp::hal::Locker _rxLocker;
	rp::hal::Event  _dataEvt;

	IChannel* _bindedChannel;
	IAsyncProtocolCodec& _codec;


	bool _isWorking;
	_u32 _workingFlag;

	rp::hal::Thread _rxThread;
	rp::hal::Thread _decoderThread;

	struct Buffer {
		size_t size;
		_u8* data;


		Buffer() : size(0), data(NULL){}

		~Buffer() {
			if (data) {
				delete[] data;
				data = NULL;
			}
		}
	};
	std::list< Buffer * > _rxQueue;
};


}}



================================================
File: src/rplidar_ros/sdk/src/sl_crc.cpp
================================================
/*
 * Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
 /*
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice,
  *    this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */

#include "sl_crc.h"  

namespace sl {namespace crc32 {
    
    static sl_u32 table[256];//crc32_table
    sl_u32 bitrev(sl_u32 input, sl_u16 bw)
    {
        sl_u16 i;
        sl_u32 var;
        var = 0;
        for (i = 0; i < bw; i++) {
            if (input & 0x01) {
                var |= 1 << (bw - 1 - i);
            }
            input >>= 1;
        }
        return var;
    }

    void init(sl_u32 poly)
    {
        sl_u16 i;
        sl_u16 j;
        sl_u32 c;

        poly = bitrev(poly, 32);
        for (i = 0; i < 256; i++) {
            c = i;
            for (j = 0; j < 8; j++) {
                if (c & 1)
                    c = poly ^ (c >> 1);
                else
                    c = c >> 1;
            }
            table[i] = c;
        }
    }

    sl_u32 cal(sl_u32 crc, void* input, sl_u16 len)
    {
        sl_u16 i;
        sl_u8 index;
        sl_u8* pch;
        pch = (unsigned char*)input;
        sl_u8 leftBytes = 4 - (len & 0x3);

        for (i = 0; i < len; i++) {
            index = (unsigned char)(crc^*pch);
            crc = (crc >> 8) ^ table[index];
            pch++;
        }

        for (i = 0; i < leftBytes; i++) {//zero padding
            index = (unsigned char)(crc ^ 0);
            crc = (crc >> 8) ^ table[index];
        }
        return crc ^ 0xffffffff;
    }

    sl_result getResult(sl_u8 *ptr, sl_u32 len) 
    {
        static sl_u8 tmp;
        if (tmp != 1) {
            init(0x4C11DB7);
            tmp = 1;
        }

        return cal(0xFFFFFFFF, ptr, len);
    }
}}


================================================
File: src/rplidar_ros/sdk/src/sl_lidar_driver.cpp
================================================
/*
 * Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
 /*
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice,
  *    this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */

#include "sdkcommon.h"
#include "hal/abs_rxtx.h"
#include "hal/thread.h"
#include "hal/types.h"
#include "hal/assert.h"
#include "hal/locker.h"
#include "hal/socket.h"
#include "hal/event.h"
#include "hal/waiter.h"
#include "hal/byteorder.h"
#include "sl_lidar_driver.h"
#include "sl_crc.h" 
#include <algorithm>
#include <memory>
#include <atomic>
#include <deque>

#include "dataunpacker/dataunpacker.h"
#include "sl_async_transceiver.h"
#include "sl_lidarprotocol_codec.h"



#ifdef _WIN32
#define NOMINMAX
#undef min
#undef max
#endif

#if defined(__cplusplus) && __cplusplus >= 201103L
#ifndef _GXX_NULLPTR_T
#define _GXX_NULLPTR_T
typedef decltype(nullptr) nullptr_t;
#endif
#endif /* C++11.  */

namespace sl {
    static void printDeprecationWarn(const char* fn, const char* replacement)
    {
        fprintf(stderr, "*WARN* YOU ARE USING DEPRECATED API: %s, PLEASE MOVE TO %s\n", fn, replacement);
    }

    static void convert(const sl_lidar_response_measurement_node_t& from, sl_lidar_response_measurement_node_hq_t& to)
    {
        to.angle_z_q14 = (((from.angle_q6_checkbit) >> SL_LIDAR_RESP_MEASUREMENT_ANGLE_SHIFT) << 8) / 90;  //transfer to q14 Z-angle
        to.dist_mm_q2 = from.distance_q2;
        to.flag = (from.sync_quality & SL_LIDAR_RESP_MEASUREMENT_SYNCBIT);  // trasfer syncbit to HQ flag field
        to.quality = (from.sync_quality >> SL_LIDAR_RESP_MEASUREMENT_QUALITY_SHIFT) << SL_LIDAR_RESP_MEASUREMENT_QUALITY_SHIFT;  //remove the last two bits and then make quality from 0-63 to 0-255
    }

    static void convert(const sl_lidar_response_measurement_node_hq_t& from, sl_lidar_response_measurement_node_t& to)
    {
        to.sync_quality = (from.flag & SL_LIDAR_RESP_MEASUREMENT_SYNCBIT) | ((from.quality >> SL_LIDAR_RESP_MEASUREMENT_QUALITY_SHIFT) << SL_LIDAR_RESP_MEASUREMENT_QUALITY_SHIFT);
        to.angle_q6_checkbit = 1 | (((from.angle_z_q14 * 90) >> 8) << SL_LIDAR_RESP_MEASUREMENT_ANGLE_SHIFT);
        to.distance_q2 = from.dist_mm_q2 > sl_u16(-1) ? sl_u16(0) : sl_u16(from.dist_mm_q2);
    }


    static inline float getAngle(const sl_lidar_response_measurement_node_t& node)
    {
        return (node.angle_q6_checkbit >> SL_LIDAR_RESP_MEASUREMENT_ANGLE_SHIFT) / 64.f;
    }

    static inline void setAngle(sl_lidar_response_measurement_node_t& node, float v)
    {
        sl_u16 checkbit = node.angle_q6_checkbit & SL_LIDAR_RESP_MEASUREMENT_CHECKBIT;
        node.angle_q6_checkbit = (((sl_u16)(v * 64.0f)) << SL_LIDAR_RESP_MEASUREMENT_ANGLE_SHIFT) | checkbit;
    }

    static inline float getAngle(const sl_lidar_response_measurement_node_hq_t& node)
    {
        return node.angle_z_q14 * 90.f / 16384.f;
    }

    static inline void setAngle(sl_lidar_response_measurement_node_hq_t& node, float v)
    {
        node.angle_z_q14 = sl_u32(v * 16384.f / 90.f);
    }

    static inline sl_u16 getDistanceQ2(const sl_lidar_response_measurement_node_t& node)
    {
        return node.distance_q2;
    }

    static inline sl_u32 getDistanceQ2(const sl_lidar_response_measurement_node_hq_t& node)
    {
        return node.dist_mm_q2;
    }
   
    template <class TNode>
    static bool angleLessThan(const TNode& a, const TNode& b)
    {
        return getAngle(a) < getAngle(b);
    }

    template < class TNode >
    static sl_result ascendScanData_(TNode * nodebuffer, size_t count)
    {
        float inc_origin_angle = 360.f / count;
        size_t i = 0;

        //Tune head
        for (i = 0; i < count; i++) {
            if (getDistanceQ2(nodebuffer[i]) == 0) {
                continue;
            }
            else {
                while (i != 0) {
                    i--;
                    float expect_angle = getAngle(nodebuffer[i + 1]) - inc_origin_angle;
                    if (expect_angle < 0.0f) expect_angle = 0.0f;
                    setAngle(nodebuffer[i], expect_angle);
                }
                break;
            }
        }

        // all the data is invalid
        if (i == count) return SL_RESULT_OPERATION_FAIL;

        //Tune tail
        for (i = count - 1; i < count; i--) {
            // To avoid array overruns, use the i < count condition
            if (getDistanceQ2(nodebuffer[i]) == 0) {
                continue;
            }
            else {
                while (i != (count - 1)) {
                    i++;
                    float expect_angle = getAngle(nodebuffer[i - 1]) + inc_origin_angle;
                    if (expect_angle > 360.0f) expect_angle -= 360.0f;
                    setAngle(nodebuffer[i], expect_angle);
                }
                break;
            }
        }

        //Fill invalid angle in the scan
        float frontAngle = getAngle(nodebuffer[0]);
        for (i = 1; i < count; i++) {
            if (getDistanceQ2(nodebuffer[i]) == 0) {
                float expect_angle = frontAngle + i * inc_origin_angle;
                if (expect_angle > 360.0f) expect_angle -= 360.0f;
                setAngle(nodebuffer[i], expect_angle);
            }
        }

        // Reorder the scan according to the angle value
        std::sort(nodebuffer, nodebuffer + count, &angleLessThan<TNode>);

        return SL_RESULT_OK;
    }

    template<typename T>
    class RawSampleNodeHolder
    {
    public:
        RawSampleNodeHolder(size_t maxcount = 8192)
            : _max_count(maxcount)
        {
           
        }
        void clear()
        {
            rp::hal::AutoLocker l(_locker);
            _data_waiter.set(false);
            _data_queue.clear();
        }

        void pushNode(_u64 timestamp_uS, const T* node)
        {
            rp::hal::AutoLocker l(_locker);
            _data_queue.push_back(*node);
            if (_data_queue.size() > _max_count) {
                _data_queue.pop_front();
            }
            _data_waiter.set();
        }

        size_t waitAndFetch(T* node, size_t maxcount, _u32 timeout)
        {
            if (_data_waiter.wait(timeout) == rp::hal::Event::EVENT_OK)
            {
                rp::hal::AutoLocker l(_locker);

                size_t copiedCount = 0;

                while (maxcount--) {
                    node[copiedCount++] = _data_queue.front();
                    _data_queue.pop_front();
                }

                return copiedCount;
            }
            return 0;
        }
    protected:
        size_t          _max_count;
        rp::hal::Locker _locker;
        rp::hal::Event  _data_waiter;
        std::deque<T>   _data_queue;
        
    };

    template<typename T>
    class ScanDataHolder
    {
    public:
        ScanDataHolder(size_t maxcount = 8192) 
            : _scan_node_buffer_size(maxcount)
            , _scan_node_available_id(-1)
            , _new_scan_ready(false)
        {
            _scanbuffer[0].reserve(_scan_node_buffer_size);
            _scanbuffer[1].reserve(_scan_node_buffer_size);

            memset(_scan_begin_timestamp_uS, 0, sizeof(_scan_begin_timestamp_uS));
        }

        size_t getMaxCacheCount() const {
            return _scan_node_buffer_size;
        }


        void reset() {
            rp::hal::AutoLocker l(_locker);
            _scan_node_available_id = -1;
            _new_scan_ready = false;
            _scanbuffer[0].clear();
            _scanbuffer[1].clear();
            _data_waiter.set(false);
            memset(_scan_begin_timestamp_uS, 0, sizeof(_scan_begin_timestamp_uS));
        }

        bool checkNewScanSignalAndReset()
        {
            return _new_scan_ready.exchange(false);
        }

        void pushScanNodeData(_u64 currentSampleTsUs, const T* hqNode)
        {
            rp::hal::AutoLocker l(_locker);

            int  operationBufID = _getOperationBufferID_locked();
            auto operationalBuf = &_scanbuffer[operationBufID];
            
            if (hqNode->flag & RPLIDAR_RESP_HQ_FLAG_SYNCBIT) {
                if (operationalBuf->size()) {
                    operationBufID = _finishCurrentScanAndSwap_locked();
                    operationalBuf = &_scanbuffer[operationBufID];

                    // publish the available scan
                    _new_scan_ready = true;
                    _data_waiter.set();

                }
                
                assert(operationalBuf->size() == 0);

                //store the timestamp info
                _scan_begin_timestamp_uS[operationBufID] = currentSampleTsUs;
            }
            else {
                if (operationalBuf->size() == 0) {
                    //discard the data, do not form partial scan
                    return;
                }
            }

            if (operationalBuf->size() >= _scan_node_buffer_size) {
                //replace the last entry if buffer is full
                operationalBuf->at(operationalBuf->size() - 1) = *hqNode;
            }
            else {
                operationalBuf->push_back(*hqNode);
            }

        }

        void rewindCurrentScanData() {
            rp::hal::AutoLocker l(_locker);
            _getOperationalBuffer_locked().clear();
        }

        std::vector<T>* waitAndLockAvailableScan(_u32 timeout, _u64 * out_timestamp_uS = nullptr)
        {
            if (_data_waiter.wait(timeout) == rp::hal::Event::EVENT_OK)
            {
                _locker.lock();
                assert(_scan_node_available_id >= 0);
                _new_scan_ready = false;
                if (out_timestamp_uS) {
                    *out_timestamp_uS = _scan_begin_timestamp_uS[_scan_node_available_id];
                }
                return &_scanbuffer[_scan_node_available_id];
            }
            else {
                return nullptr;
            }
        }

        void unlockScan(std::vector<T>* scan) {
            if (scan) {
                _locker.unlock();
            }
        }

    protected:
        int _finishCurrentScanAndSwap_locked() {
            _scan_node_available_id = _getOperationBufferID_locked();
            int newOperationalID  =  1 - _scan_node_available_id;

            _scanbuffer[newOperationalID].clear();
            return newOperationalID;
        }

        int _getOperationBufferID_locked() {
            if (_scan_node_available_id < 0) return 0;
            return 1 - _scan_node_available_id;
        }

        std::vector<T>& _getOperationalBuffer_locked()
        {
            return _scanbuffer[_getOperationBufferID_locked()];
        }


        rp::hal::Locker _locker;
        rp::hal::Event  _data_waiter;

        

        _u64   _scan_begin_timestamp_uS[2];
        size_t _scan_node_buffer_size;
        int    _scan_node_available_id;
        std::atomic<bool>   _new_scan_ready;

        std::vector<T> _scanbuffer[2];
    };

    class SlamtecLidarDriver : 
        public ILidarDriver, internal::IProtocolMessageListener, internal::LIDARSampleDataListener
    {
    public:
        enum {
            MAX_SCANNODE_CACHE_COUNT = 8192,
        };

        enum {
            A2A3_LIDAR_MINUM_MAJOR_ID  = 2,
            BUILTIN_MOTORCTL_MINUM_MAJOR_ID = 6,
        };


        enum {
            TOF_C_SERIAL_MINUM_MAJOR_ID = 4,
            TOF_S_SERIAL_MINUM_MAJOR_ID = 6,
            TOF_T_SERIAL_MINUM_MAJOR_ID = 9,
            TOF_M_SERIAL_MINUM_MAJOR_ID = 12,


            NEWDESIGN_MINUM_MAJOR_ID = TOF_C_SERIAL_MINUM_MAJOR_ID,
        };

    public:
        SlamtecLidarDriver()
            : _isConnected(false)
            , _isSupportingMotorCtrl(MotorCtrlSupportNone)
            , _op_locker(true)
            , _scanHolder(MAX_SCANNODE_CACHE_COUNT)
            , _rawSampleNodeHolder(MAX_SCANNODE_CACHE_COUNT)
            , _waiting_packet_type(0)
        {
            _protocolHandler = std::make_shared< internal::RPLidarProtocolCodec>();
            _transeiver = std::make_shared< internal::AsyncTransceiver>(*_protocolHandler);
            _dataunpacker.reset(internal::LIDARSampleDataUnpacker::CreateInstance(*this));

            _protocolHandler->setMessageListener(this);

            memset(&_cached_DevInfo, 0, sizeof(_cached_DevInfo));
        }


        virtual ~SlamtecLidarDriver()
        {
            disconnect();
            _protocolHandler->setMessageListener(nullptr);
        }


        LIDARTechnologyType getLIDARTechnologyType(const sl_lidar_response_device_info_t* devInfo)
        {
            rp::hal::AutoLocker l(_op_locker);
            if (!devInfo) {
                devInfo = &_cached_DevInfo;
            }

            return ParseLIDARTechnologyTypeByModelID(devInfo->model);
        }

        LIDARMajorType getLIDARMajorType(const sl_lidar_response_device_info_t* devInfo)
        {
            rp::hal::AutoLocker l(_op_locker);
            if (!devInfo) {
                devInfo = &_cached_DevInfo;
            }

            return ParseLIDARMajorTypeByModelID(devInfo->model);

        }

        sl_result getModelNameDescriptionString(std::string& out_description, bool fetchAliasName, const sl_lidar_response_device_info_t* devInfo, sl_u32 timeout)
        {
            rp::hal::AutoLocker l(_op_locker);
            u_result ans;
            // fetch alias (commerical) name if asked:
            if (fetchAliasName) {
                std::vector<_u8> replyData;
                ans = getLidarConf(SL_LIDAR_CONF_MODEL_NAME_ALIAS, replyData, nullptr, 0, timeout);
                if (IS_OK(ans) && replyData.size()) {
                    out_description.resize(replyData.size() + 1);
                    memcpy(&out_description[0], &replyData[0], replyData.size());
                    out_description[replyData.size()] = '\0';
                    if (out_description != "") {
                        return SL_RESULT_OK;
                    }
                }
            }


            if (!devInfo) {
                devInfo = &_cached_DevInfo;
            }


            out_description = GetModelNameStringByModelID(devInfo->model);

            return SL_RESULT_OK;
        }

        sl_result connect(IChannel* channel)
        {
            rp::hal::AutoLocker l(_op_locker);
            if (!channel) return SL_RESULT_OPERATION_FAIL;
            if (isConnected()) return SL_RESULT_ALREADY_DONE;

            _rawSampleNodeHolder.clear();

            sl_result ans;
            
       
            ans = (sl_result)_transeiver->openChannelAndBind(channel);

            if (IS_OK(ans)) {
                _isConnected = true;
                // the first dev info local cache will be taken here
                checkMotorCtrlSupport(_isSupportingMotorCtrl, 500);
            }
            
            return ans;
        }

        void disconnect()
        {
            rp::hal::AutoLocker l(_op_locker);
            if (_isConnected) {
                _disableDataGrabbing();

                _transeiver->unbindAndClose();
                _isConnected = false;
            }
        }

        bool isConnected()
        {
            return _isConnected;
        }

        sl_result reset(sl_u32 timeoutInMs = DEFAULT_TIMEOUT)
        {
            rp::hal::AutoLocker l(_op_locker);
            // send reset message 
            return (sl_result)_sendCommandWithoutResponse(SL_LIDAR_CMD_RESET);
        }

        sl_result getAllSupportedScanModes(std::vector<LidarScanMode>& outModes, sl_u32 timeoutInMs = DEFAULT_TIMEOUT)
        {
            rp::hal::AutoLocker l(_op_locker);

            if (!isConnected()) return SL_RESULT_OPERATION_NOT_SUPPORT;

            Result<nullptr_t> ans = SL_RESULT_OK;
            bool confProtocolSupported = false;
            ans = checkSupportConfigCommands(confProtocolSupported, timeoutInMs);
            if (!ans) return SL_RESULT_INVALID_DATA;

            if (confProtocolSupported) {
                // 1. get scan mode count
                sl_u16 modeCount;
                ans = getScanModeCount(modeCount, timeoutInMs);
                if (!ans) return ans;
                // 2. for loop to get all fields of each scan mode
                for (sl_u16 i = 0; i < modeCount; i++) {
                    LidarScanMode scanModeInfoTmp;
                    memset(&scanModeInfoTmp, 0, sizeof(scanModeInfoTmp));
                    scanModeInfoTmp.id = i;
                    ans = getLidarSampleDuration(scanModeInfoTmp.us_per_sample, i, timeoutInMs);
                    if (!ans) return ans;
                    ans = getMaxDistance(scanModeInfoTmp.max_distance, i, timeoutInMs);
                    if (!ans) return ans;
                    ans = getScanModeAnsType(scanModeInfoTmp.ans_type, i, timeoutInMs);
                    if (!ans) return ans;
                    ans = getScanModeName(scanModeInfoTmp.scan_mode, sizeof(scanModeInfoTmp.scan_mode), i, timeoutInMs);
                    if (!ans) return ans;
                    outModes.push_back(scanModeInfoTmp);

                }
                return ans;
            }

            return ans;        
        }

        sl_result getTypicalScanMode(sl_u16& outMode, sl_u32 timeoutInMs = DEFAULT_TIMEOUT)
        {
            rp::hal::AutoLocker l(_op_locker);
            if (!isConnected()) return SL_RESULT_OPERATION_NOT_SUPPORT;

            Result<nullptr_t> ans = SL_RESULT_OK;
            std::vector<sl_u8> answer;
            bool lidarSupportConfigCmds = false;
            ans = checkSupportConfigCommands(lidarSupportConfigCmds);
            if (!ans) return ans;

            if (lidarSupportConfigCmds) {
                ans = getLidarConf(SL_LIDAR_CONF_SCAN_MODE_TYPICAL, answer, nullptr, 0, timeoutInMs);
                if (!ans) return ans;
                if (answer.size() < sizeof(sl_u16)) {
                    return SL_RESULT_INVALID_DATA;
                }
                const sl_u16 *p_answer = reinterpret_cast<const sl_u16*>(&answer[0]);
                outMode = *p_answer;
                return ans;
            }
            //old version of triangle lidar
            else {
                outMode = SL_LIDAR_CONF_SCAN_COMMAND_EXPRESS;
                return ans;
            }
            return ans;
    
        }

        sl_result startScan(bool force, bool useTypicalScan, sl_u32 options = 0, LidarScanMode* outUsedScanMode = nullptr)
        {
            rp::hal::AutoLocker l(_op_locker);
            if (!isConnected()) return SL_RESULT_OPERATION_NOT_SUPPORT;

            Result<nullptr_t> ans = SL_RESULT_OK;
            bool ifSupportLidarConf = false;
            LidarScanMode localMode;

            if (!isConnected()) return SL_RESULT_OPERATION_FAIL;
            stop();

            if (!outUsedScanMode) outUsedScanMode = &localMode;


            ans = checkSupportConfigCommands(ifSupportLidarConf);
            if (!ans) return ans;
            if (useTypicalScan){
                sl_u16 typicalMode;
                ans = getTypicalScanMode(typicalMode);
                if (!ans) return ans;

                //call startScanExpress to do the job
                return startScanExpress(false, typicalMode, 0, outUsedScanMode);
            }

            // 'useTypicalScan' is false, just use normal scan mode


            return startScanNormal_commonpath(force, ifSupportLidarConf , *outUsedScanMode, DEFAULT_TIMEOUT);
        }


        // this path make sure the working mode has always been retrieved
        sl_result startScanNormal_commonpath(bool force, bool ifSupportLidarConf, LidarScanMode& outUsedScanMode, sl_u32 timeout)
        {

            Result<nullptr_t> ans = SL_RESULT_OK;

            if (ifSupportLidarConf) {

                outUsedScanMode.id = SL_LIDAR_CONF_SCAN_COMMAND_STD;
                ans = getLidarSampleDuration(outUsedScanMode.us_per_sample, outUsedScanMode.id);
                if (!ans) return ans;
                ans = getMaxDistance(outUsedScanMode.max_distance, outUsedScanMode.id);
                if (!ans) return ans;
                ans = getScanModeAnsType(outUsedScanMode.ans_type, outUsedScanMode.id);
                if (!ans) return ans;
                ans = getScanModeName(outUsedScanMode.scan_mode, sizeof(outUsedScanMode.scan_mode), outUsedScanMode.id);
                if (!ans) return ans;

            }
            else {
                // a legacy device
                rplidar_response_sample_rate_t sampleRateTmp;
                ans = _getLegacySampleDuration_uS(sampleRateTmp, timeout);

                if (!ans) return SL_RESULT_INVALID_DATA;
                outUsedScanMode.us_per_sample = sampleRateTmp.std_sample_duration_us;
                outUsedScanMode.max_distance = 16;
                outUsedScanMode.ans_type = SL_LIDAR_ANS_TYPE_MEASUREMENT;
                strcpy(outUsedScanMode.scan_mode, "Standard");
            }


            _updateTimingDesc(_cached_DevInfo, outUsedScanMode.us_per_sample);

            startMotor();

            _scanHolder.reset();
            _dataunpacker->enable();

            ans = _sendCommandWithoutResponse(force ? SL_LIDAR_CMD_FORCE_SCAN : SL_LIDAR_CMD_SCAN, nullptr, 0, true);
            if (ans) delay(10); // wait rplidar to handle it
            return ans;
        }


        sl_result startScanNormal(bool force, sl_u32 timeout = DEFAULT_TIMEOUT)
        {
            rp::hal::AutoLocker l(_op_locker);
            if (!isConnected()) return SL_RESULT_OPERATION_NOT_SUPPORT;


            LidarScanMode localMode;
            bool ifSupportLidarConf;

            if (!isConnected()) return SL_RESULT_OPERATION_FAIL;
            stop();

            Result<nullptr_t> ans = checkSupportConfigCommands(ifSupportLidarConf);
            if (!ans) return ans;

            return startScanNormal_commonpath(force, ifSupportLidarConf, localMode, timeout);
        }

        sl_result startScanExpress(bool force, sl_u16 scanMode, sl_u32 options = 0, LidarScanMode* outUsedScanMode = nullptr, sl_u32 timeout = DEFAULT_TIMEOUT)
        {
            rp::hal::AutoLocker l(_op_locker);
            if (!isConnected()) return SL_RESULT_OPERATION_NOT_SUPPORT;


            Result<nullptr_t> ans = SL_RESULT_OK;
            if (!isConnected()) return SL_RESULT_OPERATION_FAIL;
            stop(); //force the previous operation to stop

            LidarScanMode localMode;

            if (!outUsedScanMode) outUsedScanMode = &localMode;

            bool ifSupportLidarConf = false;
            ans = checkSupportConfigCommands(ifSupportLidarConf);
            if (!ans) return SL_RESULT_INVALID_DATA;


            
            outUsedScanMode->id = scanMode;
            if (ifSupportLidarConf) {
                ans = getLidarSampleDuration(outUsedScanMode->us_per_sample, outUsedScanMode->id);
                if (!ans) return SL_RESULT_INVALID_DATA;

                ans = getMaxDistance(outUsedScanMode->max_distance, outUsedScanMode->id);
                if (!ans) return SL_RESULT_INVALID_DATA;

                ans = getScanModeAnsType(outUsedScanMode->ans_type, outUsedScanMode->id);
                if (!ans) return SL_RESULT_INVALID_DATA;

                ans = getScanModeName(outUsedScanMode->scan_mode, sizeof(outUsedScanMode->scan_mode), outUsedScanMode->id);
                if (!ans) return SL_RESULT_INVALID_DATA;
            }
            else {
                // legacy device support
                if (scanMode != RPLIDAR_CONF_SCAN_COMMAND_STD) {
                    rplidar_response_sample_rate_t sampleRateTmp;
                    ans = _getLegacySampleDuration_uS(sampleRateTmp, timeout);
                    if (!ans) return RESULT_INVALID_DATA;

                    outUsedScanMode->us_per_sample = sampleRateTmp.express_sample_duration_us;
                    outUsedScanMode->max_distance = 16;
                    outUsedScanMode->ans_type = SL_LIDAR_ANS_TYPE_MEASUREMENT_CAPSULED;
                    strcpy(outUsedScanMode->scan_mode, "Express");
                }
                else {
                    outUsedScanMode->ans_type = SL_LIDAR_ANS_TYPE_MEASUREMENT;
                }
            }

            if (outUsedScanMode->ans_type == SL_LIDAR_ANS_TYPE_MEASUREMENT)
            {
                // redirect to the correct function...
                return startScanNormal(force, timeout);
            }
            
            _updateTimingDesc(_cached_DevInfo, outUsedScanMode->us_per_sample);
            startMotor();

            _scanHolder.reset();
            _dataunpacker->enable();

            sl_lidar_payload_express_scan_t scanReq;
            memset(&scanReq, 0, sizeof(scanReq));

            if (!ifSupportLidarConf) {
                if (scanMode != SL_LIDAR_CONF_SCAN_COMMAND_STD && scanMode != SL_LIDAR_CONF_SCAN_COMMAND_EXPRESS)
                    scanReq.working_mode = sl_u8(scanMode);
            }
            else
                scanReq.working_mode = sl_u8(scanMode);

            scanReq.working_flags = options;

            ans = _sendCommandWithoutResponse(SL_LIDAR_CMD_EXPRESS_SCAN, &scanReq, sizeof(scanReq), true);
            if (ans) delay(10); // wait rplidar to handle it
            return ans;

        }

        sl_result stop(sl_u32 timeout = DEFAULT_TIMEOUT)
        {
            rp::hal::AutoLocker l(_op_locker);


            u_result ans = SL_RESULT_OK;
            ans = _sendCommandWithoutResponse(SL_LIDAR_CMD_STOP);
            _disableDataGrabbing();

            if (IS_FAIL(ans)) return ans;
            

            delay(100);

            if(_isSupportingMotorCtrl == MotorCtrlSupportPwm)
                setMotorSpeed(0);
  
            return SL_RESULT_OK;
        }

        sl_result grabScanDataHqWithTimeStamp(sl_lidar_response_measurement_node_hq_t* nodebuffer, size_t& count, sl_u64& timestamp_uS, sl_u32 timeout = DEFAULT_TIMEOUT)
        {
            rp::hal::AutoLocker l(_op_locker);

            if (!nodebuffer)
                return SL_RESULT_INVALID_DATA;

            auto availBuffer = _scanHolder.waitAndLockAvailableScan(timeout, &timestamp_uS);
            if (!availBuffer) return SL_RESULT_OPERATION_TIMEOUT;

            count = std::min<size_t>(count, availBuffer->size());

            std::copy(availBuffer->begin(), availBuffer->begin() + count, nodebuffer);

            _scanHolder.unlockScan(availBuffer);

            return RESULT_OK;
        }

        sl_result grabScanDataHq(sl_lidar_response_measurement_node_hq_t* nodebuffer, size_t& count, sl_u32 timeout = DEFAULT_TIMEOUT)
        {
            _u64 localTS;
            return grabScanDataHqWithTimeStamp(nodebuffer, count, localTS, timeout);
        }

        sl_result getDeviceInfo(sl_lidar_response_device_info_t& info, sl_u32 timeout = DEFAULT_TIMEOUT)
        {
            rp::hal::AutoLocker l(_op_locker);
            if (!isConnected()) return SL_RESULT_OPERATION_NOT_SUPPORT;


            u_result ans;
            internal::message_autoptr_t ans_frame;

            ans = _sendCommandWithResponse(SL_LIDAR_CMD_GET_DEVICE_INFO, SL_LIDAR_ANS_TYPE_DEVINFO, ans_frame, timeout);

            if (IS_FAIL(ans)) return ans;
            if (ans_frame->getPayloadSize() < sizeof(rplidar_response_device_info_t))
            {
                return RESULT_INVALID_DATA;
            }
            info = *(rplidar_response_device_info_t*)ans_frame->getDataBuf();
#ifdef _CPU_ENDIAN_BIG
            info.firmware_version = le16_to_cpu(info.firmware_version);
#endif

            _cached_DevInfo = info;
            return (sl_result)ans;
        }

        sl_result checkMotorCtrlSupport(MotorCtrlSupport & support, sl_u32 timeout = DEFAULT_TIMEOUT)
        {
            rp::hal::AutoLocker l(_op_locker);
            if (!isConnected()) return SL_RESULT_OPERATION_NOT_SUPPORT;

            Result<nullptr_t> ans = SL_RESULT_OK;
            support = MotorCtrlSupportNone;
            _disableDataGrabbing();

            {
                sl_lidar_response_device_info_t devInfo;
                ans = getDeviceInfo(devInfo, 500);
                if (!ans) return ans;
                sl_u8 majorId = devInfo.model >> 4;
                if (majorId >= BUILTIN_MOTORCTL_MINUM_MAJOR_ID) {
                        support = MotorCtrlSupportRpm;
                        return ans;
                }
                else if(majorId >= A2A3_LIDAR_MINUM_MAJOR_ID){

                    rp::hal::AutoLocker l(_op_locker);
                    sl_lidar_payload_acc_board_flag_t flag;
                    flag.reserved = 0;
                    internal::message_autoptr_t ans_frame;

                    ans = _sendCommandWithResponse(SL_LIDAR_CMD_GET_ACC_BOARD_FLAG, SL_LIDAR_ANS_TYPE_ACC_BOARD_FLAG, ans_frame, timeout, &flag, sizeof(flag));
                    if (!ans) return ans;

                    if (ans_frame->getPayloadSize() < sizeof(rplidar_response_acc_board_flag_t))
                    {
                        return RESULT_INVALID_DATA;
                    }

                    const sl_lidar_response_acc_board_flag_t* acc_board_flag
                        = reinterpret_cast<const sl_lidar_response_acc_board_flag_t*>(ans_frame->getDataBuf());

                    if (acc_board_flag->support_flag & SL_LIDAR_RESP_ACC_BOARD_FLAG_MOTOR_CTRL_SUPPORT_MASK) {
                        support = MotorCtrlSupportPwm;
                    }
                    return ans;
                }

            }
            return SL_RESULT_OK;

        }

        sl_result getFrequency(const LidarScanMode& scanMode, const sl_lidar_response_measurement_node_hq_t* nodes, size_t count, float& frequency)
        {
            float sample_duration = scanMode.us_per_sample;
            frequency = 1000000.0f / (count * sample_duration);
            return SL_RESULT_OK;
        }

		sl_result setLidarIpConf(const sl_lidar_ip_conf_t& conf, sl_u32 timeout)
		{
            rp::hal::AutoLocker l(_op_locker);
            if (!isConnected()) return SL_RESULT_OPERATION_NOT_SUPPORT;

			sl_result ans = setLidarConf(SL_LIDAR_CONF_LIDAR_STATIC_IP_ADDR, &conf, sizeof(sl_lidar_ip_conf_t), timeout);
			return ans;
		}

        sl_result getLidarIpConf(sl_lidar_ip_conf_t& conf, sl_u32 timeout)
        {
            rp::hal::AutoLocker l(_op_locker);
            if (!isConnected()) return SL_RESULT_OPERATION_NOT_SUPPORT;


            Result<nullptr_t> ans = SL_RESULT_OK;
            std::vector<sl_u8> reserve(2); //keep backward compatibility

            std::vector<sl_u8> answer;
            ans = getLidarConf(SL_LIDAR_CONF_LIDAR_STATIC_IP_ADDR, answer, &reserve[0], 2, timeout);
            size_t len = answer.size();
            if (0 == len) return SL_RESULT_INVALID_DATA;
            memcpy(&conf, &answer[0], len);
            return ans;
        }
       
        sl_result getHealth(sl_lidar_response_device_health_t& health, sl_u32 timeout = DEFAULT_TIMEOUT)
        {
            rp::hal::AutoLocker l(_op_locker);
            if (!isConnected()) return SL_RESULT_OPERATION_NOT_SUPPORT;


            u_result ans;
            internal::message_autoptr_t ans_frame;

            ans = _sendCommandWithResponse(SL_LIDAR_CMD_GET_DEVICE_HEALTH, SL_LIDAR_ANS_TYPE_DEVHEALTH, ans_frame, timeout);

            if (IS_FAIL(ans)) return ans;
            if (ans_frame->getPayloadSize() < sizeof(rplidar_response_device_health_t))
            {
                return SL_RESULT_INVALID_DATA;
            }
            health = *(rplidar_response_device_health_t*)ans_frame->getDataBuf();
#ifdef _CPU_ENDIAN_BIG
            health.error_code = le16_to_cpu(health.error_code);
#endif

            return ans;
        }

		sl_result getDeviceMacAddr(sl_u8* macAddrArray, sl_u32 timeoutInMs)
		{
            rp::hal::AutoLocker l(_op_locker);
            if (!isConnected()) return SL_RESULT_OPERATION_NOT_SUPPORT;


            u_result ans;

            std::vector<_u8> answer(6, 0);
            ans = getLidarConf(SL_LIDAR_CONF_LIDAR_MAC_ADDR, answer, NULL, 0, timeoutInMs);
            if (IS_FAIL(ans))
            {
                return ans;
            }
            size_t len = answer.size();
            if (0 == len) return SL_RESULT_INVALID_DATA;
            memcpy(macAddrArray, &answer[0], len);
            return ans;
		}

        sl_result ascendScanData(sl_lidar_response_measurement_node_hq_t * nodebuffer, size_t count)
        {
            return ascendScanData_<sl_lidar_response_measurement_node_hq_t>(nodebuffer, count);
        }

        sl_result getScanDataWithIntervalHq(sl_lidar_response_measurement_node_hq_t * nodebuffer, size_t & count)
        {
            count = _rawSampleNodeHolder.waitAndFetch(nodebuffer, count, 0);
            return SL_RESULT_OK;
        }

        sl_result setMotorSpeed(sl_u16 speed = DEFAULT_MOTOR_SPEED)
        {
            rp::hal::AutoLocker l(_op_locker);
            if (!isConnected()) return SL_RESULT_OPERATION_NOT_SUPPORT;


            Result<nullptr_t> ans = SL_RESULT_OK;
            
            if(speed == DEFAULT_MOTOR_SPEED){
                sl_lidar_response_desired_rot_speed_t desired_speed;
                ans = getDesiredSpeed(desired_speed);
                if (ans) {
                    if (_isSupportingMotorCtrl == MotorCtrlSupportPwm)
                        speed = desired_speed.pwm_ref;
                    else
                        speed = desired_speed.rpm;
                }
                else {
                    //set a dummy default value
                    speed = 600;
                }
            }
            switch (_isSupportingMotorCtrl)
            {
            case MotorCtrlSupportNone:
                if (_transeiver->getBindedChannel()->getChannelType() == CHANNEL_TYPE_SERIALPORT) {
                    ISerialPortChannel* serialChanel = (ISerialPortChannel*)_transeiver->getBindedChannel();
                    if (!speed) {
                        serialChanel->setDTR(true);
                    }else{
                        serialChanel->setDTR(false);
                    }
                }
                break;
            case MotorCtrlSupportPwm:
                sl_lidar_payload_motor_pwm_t motor_pwm;
                motor_pwm.pwm_value = speed;


                ans = _sendCommandWithoutResponse(SL_LIDAR_CMD_SET_MOTOR_PWM, &motor_pwm, sizeof(motor_pwm), true);
                if (!ans) return ans;
                delay(10);
                break;
            case MotorCtrlSupportRpm:
                sl_lidar_payload_motor_pwm_t motor_rpm;
                motor_rpm.pwm_value = speed;

                ans = _sendCommandWithoutResponse(SL_LIDAR_CMD_HQ_MOTOR_SPEED_CTRL, &motor_rpm, sizeof(motor_rpm), true);
                if (!ans) return ans;
                delay(10);
                break;
            }
            return SL_RESULT_OK;
        }

        sl_result getMotorInfo(LidarMotorInfo &motorInfo, sl_u32 timeoutInMs)
        {
            Result<nullptr_t> ans = SL_RESULT_OK;
            rp::hal::AutoLocker l(_op_locker);
            if (!isConnected()) return SL_RESULT_OPERATION_NOT_SUPPORT;


            {
                std::vector<sl_u8> answer;

			    ans = getLidarConf(SL_LIDAR_CONF_MIN_ROT_FREQ, answer);
			    if (!ans) return ans;

			    const sl_u16 *min_answer = reinterpret_cast<const sl_u16*>(&answer[0]);
                motorInfo.min_speed = *min_answer;


                ans = getLidarConf(SL_LIDAR_CONF_MAX_ROT_FREQ, answer);
			    if (!ans) return ans;

			    const sl_u16 *max_answer = reinterpret_cast<const sl_u16*>(&answer[0]);
                motorInfo.max_speed = *max_answer;

                sl_lidar_response_desired_rot_speed_t desired_speed;
                ans = getDesiredSpeed(desired_speed);
                if (!ans) return ans;
                if(motorInfo.motorCtrlSupport == MotorCtrlSupportPwm)
                    motorInfo.desired_speed = desired_speed.pwm_ref;
                else
                    motorInfo.desired_speed = desired_speed.rpm;

            }
            return SL_RESULT_OK;
        }

        sl_result negotiateSerialBaudRate(sl_u32 requiredBaudRate, sl_u32* baudRateDetected)
        {
            // ask the LIDAR to stop working first...
            stop();

            rp::hal::AutoLocker l(_op_locker);

            IChannel* cachedChannel = _transeiver->getBindedChannel();
            if (!cachedChannel) return SL_RESULT_OPERATION_FAIL;
            if (cachedChannel->getChannelType() != CHANNEL_TYPE_SERIALPORT)
            {
                // only works for UART connection
                return RESULT_OPERATION_NOT_SUPPORT;
            }

            // disable the transeiver as it may interrupt the operation...
            _transeiver->unbindAndClose();

            sl_result ans = SL_RESULT_OK;

            do {
                // reopen the channel...

                if (!cachedChannel->open()) {
                    // failed to reopen
                    // try to revert back...
                    ans = SL_RESULT_OPERATION_FAIL;
                    break;
                }

                cachedChannel->flush();

                // wait for a while
                delay(10);
                cachedChannel->clearReadCache();

                // sending magic byte to let the target LIDAR start baudrate measurement
                // More than 100 bytes per second datarate is required to trigger the measurements
                {


                    sl_u8 magicByteSeq[16];

                    memset(magicByteSeq, SL_LIDAR_AUTOBAUD_MAGICBYTE, sizeof(magicByteSeq));

                    sl_u64 startTS = getms();

                    while (getms() - startTS < 1500) //lasting for 1.5sec
                    {
                        if (cachedChannel->write(magicByteSeq, sizeof(magicByteSeq)) < 0)
                        {
                            ans = SL_RESULT_OPERATION_FAIL;
                            break;
                        }

                        size_t dataCountGot;
                        if (cachedChannel->waitForData(1, 1, &dataCountGot)) {
                            //got reply, stop
                            ans = SL_RESULT_OK;
                            break;
                        }
                    }
                }

                if (IS_FAIL(ans)) break;

                // getback the bps measured
                _u32 bpsDetected = 0;
                size_t dataCountGot;
                if (cachedChannel->waitForData(4, 500, &dataCountGot)) {
                    //got reply, stop
                    cachedChannel->read(&bpsDetected, 4);
                    if (baudRateDetected) *baudRateDetected = bpsDetected;


                    cachedChannel->close();
                    // restart the transiever 
                    ans = _transeiver->openChannelAndBind(cachedChannel);
                    if (IS_FAIL(ans)) return ans;


                    // send a confirmation to the LIDAR, otherwise, the previous baudrate will be reverted back
                    sl_lidar_payload_new_bps_confirmation_t confirmation;
                    confirmation.flag = 0x5F5F;
                    confirmation.required_bps = requiredBaudRate;
                    confirmation.param = 0;


                    ans = _sendCommandWithoutResponse(SL_LIDAR_CMD_NEW_BAUDRATE_CONFIRM, &confirmation, sizeof(confirmation));

                    return ans;
                }
            } while (0);

            _transeiver->openChannelAndBind(cachedChannel);

            return ans;
        }

    protected:
        sl_result startMotor()
        {
            return setMotorSpeed(DEFAULT_MOTOR_SPEED);
        }

        u_result getDesiredSpeed(sl_lidar_response_desired_rot_speed_t & motorSpeed, sl_u32 timeoutInMs = DEFAULT_TIMEOUT)
        {
            u_result ans;
            std::vector<sl_u8> answer;
            ans = getLidarConf(SL_LIDAR_CONF_DESIRED_ROT_FREQ, answer, nullptr, 0, timeoutInMs);

            if (IS_FAIL(ans)) return ans;

            const sl_lidar_response_desired_rot_speed_t *p_answer = reinterpret_cast<const sl_lidar_response_desired_rot_speed_t*>(&answer[0]);
            motorSpeed = *p_answer;
            return RESULT_OK;
        }

        u_result checkSupportConfigCommands(bool& outSupport, sl_u32 timeoutInMs = DEFAULT_TIMEOUT)
        {
            u_result ans;
            rplidar_response_device_info_t devinfo;
            ans = getDeviceInfo(devinfo, timeoutInMs);
            if (IS_FAIL(ans)) {
                outSupport = false;
                return ans;
            }


            if (_checkNDMagicNumber(devinfo.model)) {

                outSupport = true;
            }
            else {
                // if lidar firmware >= 1.24
                outSupport = (devinfo.firmware_version >= ((0x1 << 8) | 24));
            }
            return RESULT_OK;
        }


        u_result getScanModeCount(sl_u16& modeCount, sl_u32 timeoutInMs = DEFAULT_TIMEOUT)
        {
            u_result ans;
            std::vector<_u8> answer;
            ans = getLidarConf(SL_LIDAR_CONF_SCAN_MODE_COUNT, answer);
            if (IS_FAIL(ans)) {
                return ans;
            }
            if (answer.size() < sizeof(_u16)) {
                return RESULT_INVALID_DATA;
            }
            const _u16* p_answer = reinterpret_cast<const _u16*>(&answer[0]);
            modeCount = *p_answer;
            return ans;
        }

        u_result setLidarConf(_u32 type, const void* payload, size_t payloadSize, _u32 timeout)
		{
			if (type < 0x00010000 || type >0x0001FFFF)
				return SL_RESULT_INVALID_DATA;


			std::vector<sl_u8> requestPkt;
			requestPkt.resize(sizeof(sl_lidar_payload_set_scan_conf_t) + payloadSize);
			if (!payload) payloadSize = 0;
			sl_lidar_payload_set_scan_conf_t* query = reinterpret_cast<sl_lidar_payload_set_scan_conf_t*>(&requestPkt[0]);

			query->type = type;

			if (payloadSize)
				memcpy(&query[1], payload, payloadSize);

			sl_result ans;
            internal::message_autoptr_t ans_frame;
            ans = _sendCommandWithResponse(SL_LIDAR_CMD_SET_LIDAR_CONF, SL_LIDAR_ANS_TYPE_SET_LIDAR_CONF, ans_frame, timeout, &requestPkt[0], requestPkt.size());

            if (IS_FAIL(ans)) {
                return ans;
            }

            //check if returned size is even less than sizeof(type) 
            if (ans_frame->getPayloadSize() < sizeof(rplidar_response_set_lidar_conf_t)) {
                return RESULT_INVALID_DATA;
            }

            const rplidar_response_set_lidar_conf_t* response =
                reinterpret_cast<const rplidar_response_set_lidar_conf_t*>(ans_frame->getDataBuf());


            if (ans_frame->getPayloadSize() == 4) {
                // legacy device?
                return *(const u_result*)(ans_frame->getDataBuf());
            }
            else {
                if (response->type != type) {
                    return RESULT_INVALID_DATA;
                }

                return (u_result)response->result;
            }
		}

        u_result getLidarConf(_u32 type, std::vector<_u8>& outputBuf, const void* payload = NULL, size_t payloadSize = 0, _u32 timeout = DEFAULT_TIMEOUT)
        {
            std::vector<_u8> requestPkt;

            if (!payload) payloadSize = 0;
            requestPkt.resize(sizeof(rplidar_payload_get_scan_conf_t) + payloadSize);
            rplidar_payload_get_scan_conf_t* query = reinterpret_cast<rplidar_payload_get_scan_conf_t*>(&requestPkt[0]);

            query->type = type;

            if (payloadSize)
                memcpy(&query[1], payload, payloadSize);

            u_result ans;
            internal::message_autoptr_t ans_frame;
            ans = _sendCommandWithResponse(SL_LIDAR_CMD_GET_LIDAR_CONF, SL_LIDAR_ANS_TYPE_GET_LIDAR_CONF, ans_frame, timeout, &requestPkt[0], requestPkt.size());
            if (IS_FAIL(ans)) {
                return ans;
            }
            //check if returned size is even less than sizeof(type) 
            if (ans_frame->getPayloadSize() < offsetof(rplidar_response_get_lidar_conf_t, payload)) {
                return SL_RESULT_INVALID_DATA;
            }

            //check if returned type is same as asked type
            const rplidar_response_get_lidar_conf_t* replied =
                reinterpret_cast<const rplidar_response_get_lidar_conf_t*>(ans_frame->getDataBuf());


            if (replied->type != type) {
                return SL_RESULT_INVALID_DATA;
            }
            //copy all the payload into &outputBuf
            int payLoadLen = (int)ans_frame->getPayloadSize() - (int)offsetof(rplidar_response_get_lidar_conf_t, payload);
            //do consistency check
            if (payLoadLen < 0) {
                return SL_RESULT_INVALID_DATA;
            }
            //copy all payLoadLen bytes to outputBuf
            outputBuf.resize(payLoadLen);
            if (payLoadLen)
                memcpy(&outputBuf[0], replied->payload, payLoadLen);
            return ans;
        }

        u_result getLidarSampleDuration(float& sampleDurationRes, sl_u16 scanModeID, sl_u32 timeoutInMs = DEFAULT_TIMEOUT)
        {
            u_result ans;

            std::vector<_u8> answer;
            ans = getLidarConf(SL_LIDAR_CONF_SCAN_MODE_US_PER_SAMPLE, answer, &scanModeID, sizeof(_u16), timeoutInMs);
            if (IS_FAIL(ans))
            {
                return ans;
            }
            if (answer.size() < sizeof(_u32))
            {
                return SL_RESULT_INVALID_DATA;
            }
            const _u32* result = reinterpret_cast<const _u32*>(&answer[0]);
            sampleDurationRes = (float)(*result / 256.0);
            return ans;
        }

        u_result getMaxDistance(float &maxDistance, sl_u16 scanModeID, sl_u32 timeoutInMs = DEFAULT_TIMEOUT)
        {
            u_result ans;


            std::vector<_u8> answer;
            ans = getLidarConf(SL_LIDAR_CONF_SCAN_MODE_MAX_DISTANCE, answer, &scanModeID, sizeof(_u16), timeoutInMs);
            if (IS_FAIL(ans))
            {
                return ans;
            }
            if (answer.size() < sizeof(_u32))
            {
                return SL_RESULT_INVALID_DATA;
            }
            const _u32* result = reinterpret_cast<const _u32*>(&answer[0]);
            maxDistance = (float)(*result >> 8);
            return ans;
        }

        u_result getScanModeAnsType(sl_u8 &ansType, sl_u16 scanModeID, sl_u32 timeoutInMs = DEFAULT_TIMEOUT)
        {
            u_result ans;

            std::vector<_u8> answer;
            ans = getLidarConf(SL_LIDAR_CONF_SCAN_MODE_ANS_TYPE, answer, &scanModeID, sizeof(_u16), timeoutInMs);
            if (IS_FAIL(ans))
            {
                return ans;
            }
            if (answer.size() < sizeof(_u8))
            {
                return SL_RESULT_INVALID_DATA;
            }
            const _u8* result = reinterpret_cast<const _u8*>(&answer[0]);
            ansType = *result;
            return ans;
        }

        u_result getScanModeName(char* modeName, size_t stringSize, _u16 scanModeID, _u32 timeoutInMs = DEFAULT_TIMEOUT)
        {
            u_result ans;

            std::vector<_u8> answer;
            ans = getLidarConf(SL_LIDAR_CONF_SCAN_MODE_NAME, answer, &scanModeID, sizeof(_u16), timeoutInMs);
            if (IS_FAIL(ans))
            {
                return ans;
            }
            size_t len = std::min<size_t>(answer.size(), stringSize);
            if (0 == len) return SL_RESULT_INVALID_DATA;

            memcpy(modeName, &answer[0], len);
            return ans;
        }


        static LIDARTechnologyType ParseLIDARTechnologyTypeByModelID(_u8 modelID)
        {
            _u8 majorModelID = (modelID >> 4);
            // FIXME: stupid implementation here
            if (majorModelID < NEWDESIGN_MINUM_MAJOR_ID) {
                return LIDAR_TECHNOLOGY_TRIANGULATION;
            }
            else {
                return LIDAR_TECHNOLOGY_DTOF;
            }
        }

        static LIDARMajorType ParseLIDARMajorTypeByModelID(_u8 modelID)
        {
            _u8 majorModelID = (modelID >> 4);


            if (majorModelID >= TOF_M_SERIAL_MINUM_MAJOR_ID) {
                return LIDAR_MAJOR_TYPE_M_SERIES;
            }
            else if (majorModelID >= TOF_T_SERIAL_MINUM_MAJOR_ID) {
                return LIDAR_MAJOR_TYPE_T_SERIES;
            }
            else if (majorModelID >= TOF_S_SERIAL_MINUM_MAJOR_ID) {
                return LIDAR_MAJOR_TYPE_S_SERIES;
            }
            else if (majorModelID >= TOF_C_SERIAL_MINUM_MAJOR_ID) {
                return LIDAR_MAJOR_TYPE_C_SERIES;
            }
            else {
                return LIDAR_MAJOR_TYPE_A_SERIES;
            }
        }

        static std::string         GetModelNameStringByModelID(_u8 modelID)
        {

            char stringBuffer[100];
            auto majorType = ParseLIDARMajorTypeByModelID(modelID);


            switch (majorType) {
            case LIDAR_MAJOR_TYPE_A_SERIES:
                sprintf(stringBuffer, "A%dM%d", (modelID >> 4), (modelID & 0xF));

                break;

            case LIDAR_MAJOR_TYPE_S_SERIES:
                sprintf(stringBuffer, "S%dM%d", (modelID >> 4) - (TOF_S_SERIAL_MINUM_MAJOR_ID)+1, (modelID & 0xF));

                break;

            case LIDAR_MAJOR_TYPE_T_SERIES:
                sprintf(stringBuffer, "T%dM%d", (modelID >> 4) - (TOF_T_SERIAL_MINUM_MAJOR_ID)+1, (modelID & 0xF));

                break;

            case LIDAR_MAJOR_TYPE_M_SERIES:
                sprintf(stringBuffer, "M%dM%d", (modelID >> 4) - (TOF_M_SERIAL_MINUM_MAJOR_ID)+1, (modelID & 0xF));

                break;

            case LIDAR_MAJOR_TYPE_C_SERIES:
                sprintf(stringBuffer, "C%dM%d", (modelID >> 4) - (TOF_C_SERIAL_MINUM_MAJOR_ID)+1, (modelID & 0xF));

                break;


            default:
                sprintf(stringBuffer, "unknown(%x)", modelID);
            }

            return std::string(stringBuffer);
        }

    protected:
        
        void _disableDataGrabbing()
        {
            _dataunpacker->disable();
            _protocolHandler->exitLoopMode(); // exit loop mode
        }
        

   
        bool _checkNDMagicNumber(_u8 model)
        {
            return ((model >> 4) >= NEWDESIGN_MINUM_MAJOR_ID);
        }




        u_result _detectLIDARNativeInterfaceType(LIDARInterfaceType & outputType, const rplidar_response_device_info_t& devInfo, sl_u32 timeout = DEFAULT_TIMEOUT)
        {
            
            LIDARMajorType majorType = ParseLIDARMajorTypeByModelID(devInfo.model);
            
            switch (majorType) {
            case LIDAR_MAJOR_TYPE_A_SERIES:
            case LIDAR_MAJOR_TYPE_M_SERIES:
            case LIDAR_MAJOR_TYPE_C_SERIES:
          
                outputType = LIDAR_INTERFACE_UART;
                return SL_RESULT_OK;


            case LIDAR_MAJOR_TYPE_T_SERIES:
                outputType = LIDAR_INTERFACE_ETHERNET;
                return SL_RESULT_OK;

            case LIDAR_MAJOR_TYPE_S_SERIES:
            {
                // ethernet version exists, check whether it is
                _u8 macAddr[6];
                u_result ans = getDeviceMacAddr(macAddr, timeout);
                if (IS_FAIL(ans)) {
                    // cannot retrieve the device mac address, consider a UART interface version
                    outputType = LIDAR_INTERFACE_UART;
                }
                else {
                    outputType = LIDAR_INTERFACE_ETHERNET;
                }
                return SL_RESULT_OK;
            }


            case LIDAR_MAJOR_TYPE_UNKNOWN:
            default:
                outputType = LIDAR_INTERFACE_UNKNOWN;
                return SL_RESULT_OK;
            }
        }

        _u32 _getNativeBaudRate(const rplidar_response_device_info_t & devInfo)
        {
            _u8 majorModelID = (devInfo.model >> 4);
            switch (majorModelID)
            {
            case 1:
            case 2:
            case 3: //A1..A3 series
                return (devInfo.hardware_version >= 6) ? 256000 : 115200;
            case 4: //C series
                return 460800;
            case 6: //model ID of S1
                return 256000;
            case 7: //model ID of S2
            case 8: //model ID of S3
                if (devInfo.model == (0x82)) return 460800; 
                return 1000000;
            default:
                return 0; //0 as unknown
            }
        }

        bool _updateTimingDesc(const rplidar_response_device_info_t& devInfo, float selectedSampleDuration)
        {
            _timing_desc.native_baudrate = _getNativeBaudRate(devInfo);
            _detectLIDARNativeInterfaceType(_timing_desc.native_interface_type, devInfo, 500);
            
            _timing_desc.sample_duration_uS = (_u64)(selectedSampleDuration + 0.5f);

            //FIXME: will be changed in future releases
            _timing_desc.native_timestamp_support = false; 
            _timing_desc.linkage_delay_uS = 0;


            // notify the data unpacker
            _dataunpacker->updateUnpackerContext(internal::LIDARSampleDataUnpacker::UNPACKER_CONTEXT_TYPE_LIDAR_TIMING ,&_timing_desc, sizeof(_timing_desc));
            return true;

        }

        u_result _getLegacySampleDuration_uS(rplidar_response_sample_rate_t& rateInfo, _u32 timeout)
        {
            
            static const _u32 LEGACY_SAMPLE_DURATION = 476;

            rplidar_response_device_info_t devinfo;
            // 1. fetch the device version first...
            u_result ans = getDeviceInfo(devinfo, timeout);

            rateInfo.express_sample_duration_us = LEGACY_SAMPLE_DURATION;
            rateInfo.std_sample_duration_us = LEGACY_SAMPLE_DURATION;

            if (IS_FAIL(ans)) {
                return ans;
            }

            if (getLIDARMajorType(&devinfo) == LIDAR_MAJOR_TYPE_A_SERIES) {
                if (devinfo.firmware_version < ((0x1 << 8) | 17)) {
                    // very very rare and old model found!!
                    return SL_RESULT_OK;
                }
            }


            internal::message_autoptr_t ans_frame;

            ans = _sendCommandWithResponse(SL_LIDAR_CMD_GET_SAMPLERATE, SL_LIDAR_ANS_TYPE_SAMPLE_RATE, ans_frame, timeout);

            if (IS_FAIL(ans)) return ans;
            if (ans_frame->getPayloadSize() < sizeof(rplidar_response_sample_rate_t))
            {
                return RESULT_INVALID_DATA;
            }
            memcpy(&rateInfo, ans_frame->getDataBuf(), sizeof(rateInfo));

#ifdef _CPU_ENDIAN_BIG
            rateInfo.express_sample_duration_us = le16_to_cpu(rateInfo.express_sample_duration_us);
            rateInfo.std_sample_duration_us = le16_to_cpu(rateInfo.std_sample_duration_us);
#endif

            return ans;
        }


        u_result _sendCommandWithoutResponse(_u8 cmd, const void* payload = NULL, size_t payloadsize = 0, bool noForceStop = false)
        {
            if (!noForceStop) {
                _disableDataGrabbing();
            }
            _response_waiter.set(false);

            internal::message_autoptr_t message(new internal::ProtocolMessage(cmd, (const _u8*)payload, payloadsize));
            return _transeiver->sendMessage(message);

        }

        u_result _sendCommandWithResponse(_u8 cmd, _u8 responseType, internal::message_autoptr_t& ansPkt, _u32 timeout = DEFAULT_TIMEOUT, const void* payload = NULL, size_t payloadsize = 0)
        {
            u_result ans;

            _data_locker.lock();

            internal::message_autoptr_t message(new internal::ProtocolMessage(cmd, (const _u8*)payload, payloadsize));
            _disableDataGrabbing();
            _waiting_packet_type = responseType;
            _response_waiter.set(false);
            _data_locker.unlock();

            ans = _transeiver->sendMessage(message);

            if (IS_FAIL(ans)) return ans;

            do {
                switch (_response_waiter.wait(timeout)) {
                case rp::hal::Event::EVENT_TIMEOUT:
                    return RESULT_OPERATION_TIMEOUT;
                case rp::hal::Event::EVENT_OK:
                    _data_locker.lock();
                    ansPkt = _lastAnsPkt;
                    _data_locker.unlock();
                    return RESULT_OK;
                default:
                    return RESULT_OPERATION_FAIL;
                }
            } while (1);
        }
        
    public:

        virtual void onHQNodeDecoded(_u64 timestamp_uS, const rplidar_response_measurement_node_hq_t* node)
        {
            _scanHolder.pushScanNodeData(timestamp_uS, node);
            _rawSampleNodeHolder.pushNode(timestamp_uS, node);
        }

        virtual void onHQNodeScanResetReq() {
            _scanHolder.rewindCurrentScanData();
        }

        virtual void onProtocolMessageDecoded(const internal::ProtocolMessage& msg)
        {
            internal::message_autoptr_t message = std::make_shared<internal::ProtocolMessage>(msg);

            if (_dataunpacker->onSampleData(message->cmd, message->getDataBuf(), message->getPayloadSize()))
            {
                return;
            }

            if (message->cmd == _waiting_packet_type) {
                _data_locker.lock();
                _lastAnsPkt = message;
                _response_waiter.setResult(message->cmd);
                _data_locker.unlock();
            }

            
        }
    private:

        std::shared_ptr<internal::RPLidarProtocolCodec> _protocolHandler;
        std::shared_ptr<internal::AsyncTransceiver> _transeiver;
        std::shared_ptr<internal::LIDARSampleDataUnpacker> _dataunpacker;

        bool _isConnected;

        MotorCtrlSupport          _isSupportingMotorCtrl;


        rp::hal::Locker           _op_locker;
        rp::hal::Locker           _data_locker;
        rp::hal::Waiter<_u32>     _response_waiter;

        ScanDataHolder<sl_lidar_response_measurement_node_hq_t> _scanHolder;
        RawSampleNodeHolder<sl_lidar_response_measurement_node_hq_t> _rawSampleNodeHolder;
        _u32                          _waiting_packet_type;
        internal::message_autoptr_t   _lastAnsPkt;

        sl_lidar_response_device_info_t _cached_DevInfo;
        SlamtecLidarTimingDesc         _timing_desc;

    };

    Result<ILidarDriver*> createLidarDriver()
    {
        return new SlamtecLidarDriver();
    }
}


================================================
File: src/rplidar_ros/sdk/src/sl_lidarprotocol_codec.cpp
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
 /*
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice,
  *    this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */



#include "sdkcommon.h"
#include "hal/byteorder.h"
#include "hal/abs_rxtx.h"
#include "hal/thread.h"
#include "hal/types.h"
#include "hal/assert.h"
#include "hal/locker.h"
#include "hal/socket.h"
#include "hal/event.h"

#include "sl_lidar_driver.h"
#include "sl_crc.h" 
#include <algorithm>

#include "sl_async_transceiver.h"
#include "sl_lidarprotocol_codec.h"



namespace sl { namespace internal {



RPLidarProtocolCodec::RPLidarProtocolCodec()
    : IAsyncProtocolCodec()
    , _listener(NULL)
    , _op_locker(true)
{
    onDecodeReset();
}

void RPLidarProtocolCodec::exitLoopMode() {
    onDecodeReset();
}



void RPLidarProtocolCodec::setMessageListener(IProtocolMessageListener* listener)
{
    rp::hal::AutoLocker l(_op_locker);
    _listener = listener;
}

size_t RPLidarProtocolCodec::estimateLength(message_autoptr_t& message)
{
    size_t actualSize = 2; //1-byte's sync byte, 1-byte's cmd byte

    if (message->cmd & RPLIDAR_CMDFLAG_HAS_PAYLOAD) {
        actualSize += (message->getPayloadSize() & 0xFF);
        actualSize += 2; //1-byte for size field, 1-byte for checksum
    }

    return actualSize;
}


void RPLidarProtocolCodec::onEncodeData(message_autoptr_t& message, _u8* buffer, size_t* size)
{
    _u8 checksum = 0;
    size_t writeSize = std::min<size_t>(*size, estimateLength(message));
    size_t currentPos = 0;

    while (currentPos < writeSize) {
        _u8 currentTxByte;
        switch (currentPos) {
        case 0: // sync byte
            currentTxByte = RPLIDAR_CMD_SYNC_BYTE;
            break;
        case 1: // cmd byte
            currentTxByte = message->cmd;
            break;
        case 2: // size byte
            currentTxByte = (_u8)message->getPayloadSize();
            break;
        default:
        {
            size_t payloadPos = currentPos - 3;
            if (payloadPos == message->getPayloadSize()) {
                // checksum byte
                currentTxByte = checksum;
                assert(currentPos + 1 == writeSize);
            }
            else {
                // payload
                currentTxByte = message->getDataBuf()[payloadPos];
            }
        }
        }


        checksum ^= currentTxByte;
        buffer[currentPos++] = currentTxByte;
    } while (0);

    *size = currentPos;
}

void   RPLidarProtocolCodec::onDecodeReset() {
    rp::hal::AutoLocker autolock(_op_locker);
    // flush the pending data
    _decodingMessage.cleanData();
    // reset to initial state
    _rx_pos = 0;
    _working_states = STATUS_WAIT_SYNC1;
}


void RPLidarProtocolCodec::onDecodeData(const void* buffer, size_t size)
{
    rp::hal::AutoLocker autolock(_op_locker);

    const _u8* data = reinterpret_cast<const _u8*>(buffer);
    const _u8* dataEnd = data + size;


    while (data != dataEnd) {
        _u8 currentByte = *data;
        ++data;

        switch (_working_states & ((_u32)STATUS_LOOP_MODE_FLAG - 1)) {
        case STATUS_WAIT_SYNC1:
            if (currentByte == RPLIDAR_ANS_SYNC_BYTE1) {
                _working_states = STATUS_WAIT_SYNC2;
            }
            break;
        case STATUS_WAIT_SYNC2:
            if (currentByte == RPLIDAR_ANS_SYNC_BYTE2) {
                _working_states = STATUS_WAIT_SIZE_FLAG;
                _rx_pos = 0; // init rx pos for recv size and flag
            }
            else {
                // reset to the initial state
                _working_states = STATUS_WAIT_SYNC1;
            }
            break;
        case STATUS_WAIT_SIZE_FLAG:
        {
            assert(sizeof(_decodingMessage.len) >= 4);
            _u8* byteArr = reinterpret_cast<_u8*>(&_decodingMessage.len);
            byteArr[_rx_pos++] = currentByte;

            if (_rx_pos == 4) {
                _working_states = STATUS_WAIT_TYPE;
                _decodingMessage.len = le32_to_cpu(_decodingMessage.len);

                // 30bit size + 2bit flag has been received
                _u32 flagbits = (_u32)(_decodingMessage.len >> RPLIDAR_ANS_HEADER_SUBTYPE_SHIFT);
                if (flagbits & RPLIDAR_ANS_PKTFLAG_LOOP) {
                    _working_states |= STATUS_LOOP_MODE_FLAG;
                }
                _decodingMessage.len = (_decodingMessage.len & RPLIDAR_ANS_HEADER_SIZE_MASK);
                // alloc buffer
                _decodingMessage.fillData(NULL, _decodingMessage.getPayloadSize());
                _rx_pos = 0;
            }
        }
        break;
        case STATUS_WAIT_TYPE:
            // save the type field as a cmd 
            _decodingMessage.cmd = currentByte;

            // recv payload...
            _working_states = (_working_states & STATUS_LOOP_MODE_FLAG)
                | STATUS_RECV_PAYLOAD;

            if (!_decodingMessage.getPayloadSize()) {
                // zero payload packet? 
                _working_states = STATUS_WAIT_SYNC1;
            }
            break;
        case STATUS_RECV_PAYLOAD:
            _decodingMessage.getDataBuf()[_rx_pos++] = currentByte;

            if ((size_t)_rx_pos == _decodingMessage.getPayloadSize()) {
                if (_working_states & STATUS_LOOP_MODE_FLAG) {
                    // rewind to the payload recv status in loop mode
                    _rx_pos = 0;
                }
                else {
                    // reset the decoder
                    _working_states = STATUS_WAIT_SYNC1;
                }

                IProtocolMessageListener* cachedLister = _listener;

                autolock.forceUnlock(); //unlock the oplock to prevent deadlock


                if (cachedLister) {
                    cachedLister->onProtocolMessageDecoded(_decodingMessage);
                }

                _op_locker.lock(); // relock it
            }
            break;
        }

    }
}




}}


================================================
File: src/rplidar_ros/sdk/src/sl_lidarprotocol_codec.h
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
 /*
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice,
  *    this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */


#pragma once

#include "sl_async_transceiver.h"

namespace sl { namespace internal {


class IProtocolMessageListener {
public:
    virtual void onProtocolMessageDecoded(const ProtocolMessage&) = 0;
};


class RPLidarProtocolCodec : public IAsyncProtocolCodec
{
public:

    enum {
        STATUS_WAIT_SYNC1 = 0x0,
        STATUS_WAIT_SYNC2 = 0x1,
        STATUS_WAIT_SIZE_FLAG = 0x2,
        STATUS_WAIT_TYPE = 0x3,
        STATUS_RECV_PAYLOAD = 0x4,
        STATUS_LOOP_MODE_FLAG = 0x80000000,
    };

    RPLidarProtocolCodec();

    void exitLoopMode();


    virtual size_t estimateLength(message_autoptr_t& message);


    virtual void onEncodeData(message_autoptr_t& message, _u8* txbuffer, size_t* size);

    virtual void   onDecodeReset();
    virtual void   onDecodeData(const void* buffer, size_t size);
    
    void setMessageListener(IProtocolMessageListener* l);

protected:

    IProtocolMessageListener* _listener;
    ProtocolMessage          _decodingMessage;
    rp::hal::Locker          _op_locker;
                            
    _u32                     _working_states;
    int                      _rx_pos;
};

}}






================================================
File: src/rplidar_ros/sdk/src/sl_serial_channel.cpp
================================================
/*
 * Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
 /*
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice,
  *    this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */

#include "sl_lidar_driver.h"
#include "hal/abs_rxtx.h"
#include "hal/socket.h"


namespace sl {
    
    class SerialPortChannel : public ISerialPortChannel
    {
    public:
        SerialPortChannel(const std::string& device, int baudrate) :_rxtxSerial(rp::hal::serial_rxtx::CreateRxTx())
        {
            _device = device;
            _baudrate = baudrate;
        }

        ~SerialPortChannel()
        {
            if (_rxtxSerial)
                delete _rxtxSerial;
        }

        bool bind(const std::string& device, sl_s32 baudrate)
        {
            _closePending = false;
            return _rxtxSerial->bind(device.c_str(), baudrate);
        }

        bool open()
        {
            if(!bind(_device, _baudrate))
                return false;
            return _rxtxSerial->open();
        }

        void close()
        {
            _closePending = true;
            _rxtxSerial->cancelOperation();
            _rxtxSerial->close();
        }
        void flush()
        {
            _rxtxSerial->flush(0);
        }

        sl_result waitForDataExt(size_t& size_hint, sl_u32 timeoutInMs)
        {
            _word_size_t result;
            size_t size_holder;
            size_hint = 0;

            if (_closePending) return  RESULT_OPERATION_TIMEOUT;

            if (!_rxtxSerial->isOpened()) {
                return RESULT_OPERATION_FAIL;
            }

            result = _rxtxSerial->waitfordata(1, timeoutInMs, &size_holder);
            size_hint = size_holder;
            if (result == (_word_size_t)rp::hal::serial_rxtx::ANS_DEV_ERR)
                return RESULT_OPERATION_FAIL;
            if (result == (_word_size_t)rp::hal::serial_rxtx::ANS_TIMEOUT)
                return RESULT_OPERATION_TIMEOUT;

            return RESULT_OK;
        }

        bool waitForData(size_t size, sl_u32 timeoutInMs, size_t* actualReady)
        {
            if (_closePending) return false;
            return (_rxtxSerial->waitfordata(size, timeoutInMs, actualReady) == rp::hal::serial_rxtx::ANS_OK);
        }

        int write(const void* data, size_t size)
        {
           return _rxtxSerial->senddata((const sl_u8 * )data, size);
        }

        int read(void* buffer, size_t size)
        {
            size_t lenRec = 0;
            lenRec = _rxtxSerial->recvdata((sl_u8 *)buffer, size);
            return (int)lenRec;
        }

        void clearReadCache()
        {
           
        }

        void setDTR(bool dtr)
        {
            dtr ? _rxtxSerial->setDTR() : _rxtxSerial->clearDTR();
        }

        int getChannelType() {
            return CHANNEL_TYPE_SERIALPORT;
        }

    private:
        rp::hal::serial_rxtx  * _rxtxSerial;
        bool _closePending;
        std::string _device;
        int _baudrate;

    };

    Result<IChannel*> createSerialPortChannel(const std::string& device, int baudrate)
    {
        return new  SerialPortChannel(device, baudrate);
    }

}


================================================
File: src/rplidar_ros/sdk/src/sl_tcp_channel.cpp
================================================
/*
 * Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
 /*
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice,
  *    this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */

#include "sl_lidar_driver.h"
#include "hal/abs_rxtx.h"
#include "hal/socket.h"


namespace sl {
    
    class TcpChannel : public IChannel
    {
    public:
        TcpChannel(const std::string& ip, int port) : _binded_socket(rp::net::StreamSocket::CreateSocket()) {
            _ip = ip;
            _port = port;
        }

        bool bind(const std::string & ip, sl_s32 port)
        {
            _socket = rp::net::SocketAddress(ip.c_str(), port);
            return true;
        }

        bool open()
        {
            if(!bind(_ip, _port))
                return false;
            return IS_OK(_binded_socket->connect(_socket));
            
        }

        void close()
        {
            _binded_socket->dispose();
            _binded_socket = NULL;
        }
        void flush()
        {
        
        }

        sl_result waitForDataExt(size_t& size_hint, sl_u32 timeoutInMs)
        {
            u_result ans;
            size_hint = 0;
            ans = _binded_socket->waitforData(timeoutInMs);

            switch (ans) {
            case RESULT_OK:
                size_hint = 1024; //dummy value
                break;
            }

            return ans;
        }

        bool waitForData(size_t size, sl_u32 timeoutInMs, size_t* actualReady)
        {
            if (actualReady)
                *actualReady = size;
            return (_binded_socket->waitforData(timeoutInMs) == RESULT_OK);

        }

        int write(const void* data, size_t size)
        {
            return _binded_socket->send(data, size);
        }

        int read(void* buffer, size_t size)
        {
            size_t lenRec = 0;
            _binded_socket->recv(buffer, size, lenRec);
            return (int)lenRec;
        }

        void clearReadCache() {}

        void setStatus(_u32 flag){}

        int getChannelType() {
            return CHANNEL_TYPE_TCP;
        }
    private:
        rp::net::StreamSocket * _binded_socket;
        rp::net::SocketAddress _socket;
        std::string _ip;
        int _port;
    };
    Result<IChannel*> createTcpChannel(const std::string& ip, int port)
    {
        return new  TcpChannel(ip, port);
    }
}


================================================
File: src/rplidar_ros/sdk/src/sl_udp_channel.cpp
================================================
/*
 * Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
 /*
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice,
  *    this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */

#include "sl_lidar_driver.h"
#include "hal/abs_rxtx.h"
#include "hal/socket.h"


namespace sl {
	class UdpChannel : public IChannel
	{
	public:
		UdpChannel(const std::string& ip, int port) : _binded_socket(rp::net::DGramSocket::CreateSocket()) {
            _ip = ip;
            _port = port;
        }

		bool bind(const std::string & ip, sl_s32 port)
        {
            _socket = rp::net::SocketAddress(ip.c_str(), port);
            return true;
        }

        bool open()
        {
            if(!bind(_ip, _port))
                return false;
            return SL_IS_OK(_binded_socket->setPairAddress(&_socket));         
        }

        void close()
        {
            _binded_socket->dispose();
            _binded_socket = NULL;
        }
        void flush()
        {
            clearReadCache();
        }

        sl_result waitForDataExt(size_t& size_hint, sl_u32 timeoutInMs)
        {
            u_result ans;
            size_hint = 0;
            ans = _binded_socket->waitforData(timeoutInMs);

            switch (ans) {
            case RESULT_OK:
                size_hint = 1024; //dummy value
                break;
            }

            return ans;
        }

        bool waitForData(size_t size, sl_u32 timeoutInMs, size_t* actualReady)
        {
            if (actualReady)
                *actualReady = size;
            return (_binded_socket->waitforData(timeoutInMs) == RESULT_OK);

        }

        int write(const void* data, size_t size)
        {
            return _binded_socket->sendTo(nullptr, data, size);
        }

        int read(void* buffer, size_t size)
        {
            size_t actualGet;

            u_result ans = _binded_socket->recvFrom(buffer, size, actualGet);
            if (IS_FAIL(ans)) return 0;
            return actualGet;
        
        }

        void clearReadCache() {
            _binded_socket->clearRxCache();
        }

        void setStatus(_u32 flag){}
        
        int getChannelType() {
            return CHANNEL_TYPE_UDP;
        }

	private:
		rp::net::DGramSocket * _binded_socket;
		rp::net::SocketAddress _socket;
        std::string _ip;
        int _port;
	};

    Result<IChannel*> createUdpChannel(const std::string& ip, int port)
    {
        return new  UdpChannel(ip, port);
    }
}


================================================
File: src/rplidar_ros/sdk/src/arch/linux/arch_linux.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2018 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

// libc dep
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include <time.h>
#include <stdarg.h>

// libc++ dep
#include <iostream>
#include <string>

// linux specific
#include <unistd.h>
#include <errno.h>
#include <pthread.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <time.h>

#include "timer.h"




================================================
File: src/rplidar_ros/sdk/src/arch/linux/net_serial.cpp
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2018 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "arch/linux/arch_linux.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <assert.h>
// linux specific

#include <errno.h>
#include <fcntl.h>

#include <time.h>
#include "hal/types.h"
#include "arch/linux/net_serial.h"
#include <sys/select.h>

#include <algorithm>
//__GNUC__
#if defined(__GNUC__)
// for Linux extension
#include <asm/ioctls.h>
#include <asm/termbits.h>
#include <sys/ioctl.h>
extern "C" int tcflush(int fildes, int queue_selector);
#else
// for other standard UNIX
#include <termios.h>
#include <sys/ioctl.h>

#endif


namespace rp{ namespace arch{ namespace net{

raw_serial::raw_serial()
    : rp::hal::serial_rxtx()
    , _baudrate(0)
    , _flags(0)
    , serial_fd(-1)
{
    _init();
}

raw_serial::~raw_serial()
{
    close();

}

bool raw_serial::open()
{
    return open(_portName, _baudrate, _flags);
}

bool raw_serial::bind(const char * portname, uint32_t baudrate, uint32_t flags)
{   
    strncpy(_portName, portname, sizeof(_portName));
    _baudrate = baudrate;
    _flags    = flags;
    return true;
}

bool raw_serial::open(const char * portname, uint32_t baudrate, uint32_t flags)
{
    if (isOpened()) close();
    
    serial_fd = ::open(portname, O_RDWR | O_NOCTTY | O_NDELAY);

    if (serial_fd == -1) return false;

    

#if !defined(__GNUC__)
    // for standard UNIX
    struct termios options, oldopt;
    tcgetattr(serial_fd, &oldopt);
    bzero(&options,sizeof(struct termios));

    // enable rx and tx
    options.c_cflag |= (CLOCAL | CREAD);

    _u32 termbaud = getTermBaudBitmap(baudrate);

    if (termbaud == (_u32)-1) {
        close();
        return false;
    }
    cfsetispeed(&options, termbaud);
    cfsetospeed(&options, termbaud);

    options.c_cflag &= ~PARENB; //no checkbit
    options.c_cflag &= ~CSTOPB; //1bit stop bit
    options.c_cflag &= ~CRTSCTS; //no flow control

    options.c_cflag &= ~CSIZE;
    options.c_cflag |= CS8; /* Select 8 data bits */

#ifdef CNEW_RTSCTS
    options.c_cflag &= ~CNEW_RTSCTS; // no hw flow control
#endif

    options.c_iflag &= ~(IXON | IXOFF | IXANY); // no sw flow control

    // raw input mode   
    options.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
    // raw output mode   
    options.c_oflag &= ~OPOST;



    if (tcsetattr(serial_fd, TCSANOW, &options))
    {
        close();
        return false;
    }

#else

    // using Linux extension ...
    struct termios2 tio;

    ioctl(serial_fd, TCGETS2, &tio);
    bzero(&tio, sizeof(struct termios2));

    tio.c_cflag = BOTHER;
    tio.c_cflag |= (CLOCAL | CREAD | CS8); //8 bit no hardware handshake

    tio.c_cflag &= ~CSTOPB;   //1 stop bit
    tio.c_cflag &= ~CRTSCTS;  //No CTS
    tio.c_cflag &= ~PARENB;   //No Parity

#ifdef CNEW_RTSCTS
    tio.c_cflag &= ~CNEW_RTSCTS; // no hw flow control
#endif

    tio.c_iflag &= ~(IXON | IXOFF | IXANY); // no sw flow control


    tio.c_cc[VMIN] = 0;         //min chars to read
    tio.c_cc[VTIME] = 0;        //time in 1/10th sec wait

    tio.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
    // raw output mode   
    tio.c_oflag &= ~OPOST;

    tio.c_ispeed = baudrate;
    tio.c_ospeed = baudrate;


    ioctl(serial_fd, TCSETS2, &tio);

#endif


    tcflush(serial_fd, TCIFLUSH);

    if (fcntl(serial_fd, F_SETFL, FNDELAY))
    {
        close();
        return false;
    }


    _is_serial_opened = true;
    _operation_aborted = false;

    //Clear the DTR bit to let the motor spin
    clearDTR();
    do {
        // create self pipeline for wait cancellation
        if (pipe(_selfpipe) == -1) break;

        int flags = fcntl(_selfpipe[0], F_GETFL);
        if (flags == -1)
            break;

        flags |= O_NONBLOCK;                /* Make read end nonblocking */
        if (fcntl(_selfpipe[0], F_SETFL, flags) == -1)
            break;

        flags = fcntl(_selfpipe[1], F_GETFL);
        if (flags == -1)
            break;

        flags |= O_NONBLOCK;                /* Make write end nonblocking */
        if (fcntl(_selfpipe[1], F_SETFL, flags) == -1)
            break;

    } while (0);
    
    return true;
}

void raw_serial::close()
{
    if (serial_fd != -1)
        ::close(serial_fd);
    serial_fd = -1;
    
    if (_selfpipe[0] != -1)
        ::close(_selfpipe[0]);

    if (_selfpipe[1] != -1)
        ::close(_selfpipe[1]);

    _selfpipe[0] = _selfpipe[1] = -1;

    _operation_aborted = false;
    _is_serial_opened = false;
}

int raw_serial::senddata(const unsigned char * data, size_t size)
{
// FIXME: non-block io should be used
    if (!isOpened()) return 0;

    if (data == NULL || size ==0) return 0;
    
    size_t tx_len = 0;
    required_tx_cnt = 0;
    do {
        int ans = ::write(serial_fd, data + tx_len, size-tx_len);
        
        if (ans == -1) return tx_len;
        
        tx_len += ans;
        required_tx_cnt = tx_len;
    }while (tx_len<size);
    
    
    return tx_len;
}


int raw_serial::recvdata(unsigned char * data, size_t size)
{
    if (!isOpened()) return 0;
    
    int ans = ::read(serial_fd, data, size);
    
    if (ans == -1) ans=0;
    required_rx_cnt = ans;
    return ans;
}


void raw_serial::flush( _u32 flags)
{
    tcflush(serial_fd,TCIFLUSH); 
}

int raw_serial::waitforsent(_u32 timeout, size_t * returned_size)
{
    if (returned_size) *returned_size = required_tx_cnt;
    return 0;
}

int raw_serial::waitforrecv(_u32 timeout, size_t * returned_size)
{
    if (!isOpened() ) return -1;
   
    if (returned_size) *returned_size = required_rx_cnt;
    return 0;
}

int raw_serial::waitfordata(size_t data_count, _u32 timeout, size_t * returned_size)
{
    size_t length = 0;
    if (returned_size==NULL) returned_size=(size_t *)&length;
    *returned_size = 0;

    int max_fd;
    fd_set input_set;
    struct timeval timeout_val;

    /* Initialize the input set */
    FD_ZERO(&input_set);
    FD_SET(serial_fd, &input_set);

    if (_selfpipe[0] != -1)
        FD_SET(_selfpipe[0], &input_set);

    max_fd =  std::max<int>(serial_fd, _selfpipe[0]) + 1;

    /* Initialize the timeout structure */
    timeout_val.tv_sec = timeout / 1000;
    timeout_val.tv_usec = (timeout % 1000) * 1000;

    if ( isOpened() )
    {
        int nread;

        if ( ioctl(serial_fd, FIONREAD, &nread) == -1) return ANS_DEV_ERR;

        *returned_size = nread;

        if (*returned_size >= data_count)
        {
            return 0;
        }
    }

    while ( isOpened() )
    {
        /* Do the select */
        int n = ::select(max_fd, &input_set, NULL, NULL, &timeout_val);

        if (n < 0)
        {
            // select error
            *returned_size =  0;
            return ANS_DEV_ERR;
        }
        else if (n == 0)
        {
            // time out
            *returned_size =0;
            return ANS_TIMEOUT;
        }
        else
        {
            if (FD_ISSET(_selfpipe[0], &input_set)) {   
                // require aborting the current operation
                int ch;
                for (;;) {                    
                    if (::read(_selfpipe[0], &ch, 1) == -1) {
                        break;
                    }
                    
                }

                // treat as  timeout
                *returned_size = 0;
                return ANS_TIMEOUT;
            }

            // data avaliable
            assert (FD_ISSET(serial_fd, &input_set));


            if ( ioctl(serial_fd, FIONREAD, returned_size) == -1) return ANS_DEV_ERR;
            if (*returned_size >= data_count)
            {
                return 0;
            }
        }
        
    }

    *returned_size=0;
    return ANS_DEV_ERR;
}

size_t raw_serial::rxqueue_count()
{
    if  ( !isOpened() ) return 0;
    size_t remaining;
    
    if (::ioctl(serial_fd, FIONREAD, &remaining) == -1) return 0;
    return remaining;
}

void raw_serial::setDTR()
{
    if ( !isOpened() ) return;

    uint32_t dtr_bit = TIOCM_DTR;
    ioctl(serial_fd, TIOCMBIS, &dtr_bit);
}

void raw_serial::clearDTR()
{
    if ( !isOpened() ) return;

    uint32_t dtr_bit = TIOCM_DTR;
    ioctl(serial_fd, TIOCMBIC, &dtr_bit);
}

void raw_serial::_init()
{
    serial_fd = -1;  
    _portName[0] = 0;
    required_tx_cnt = required_rx_cnt = 0;
    _operation_aborted = false;
    _selfpipe[0] = _selfpipe[1] = -1;
}

void raw_serial::cancelOperation()
{
    _operation_aborted = true;
    if (_selfpipe[1] == -1) return;

    (int)::write(_selfpipe[1], "x", 1);
}

_u32 raw_serial::getTermBaudBitmap(_u32 baud)
{
#define BAUD_CONV( _baud_) case _baud_:  return B##_baud_ 
switch (baud) {
        BAUD_CONV(1200);
        BAUD_CONV(1800);
        BAUD_CONV(2400);
        BAUD_CONV(4800);
        BAUD_CONV(9600);
        BAUD_CONV(19200);
        BAUD_CONV(38400);
        BAUD_CONV(57600);
        BAUD_CONV(115200);
        BAUD_CONV(230400);
        BAUD_CONV(460800);
        BAUD_CONV(500000);
        BAUD_CONV(576000);
        BAUD_CONV(921600);
        BAUD_CONV(1000000);
        BAUD_CONV(1152000);
        BAUD_CONV(1500000);
        BAUD_CONV(2000000);
        BAUD_CONV(2500000);
        BAUD_CONV(3000000);
        BAUD_CONV(3500000);
        BAUD_CONV(4000000);
    }
    return -1;
}

}}} //end rp::arch::net

//begin rp::hal
namespace rp{ namespace hal{

serial_rxtx * serial_rxtx::CreateRxTx()
{
    return new rp::arch::net::raw_serial();
}

void serial_rxtx::ReleaseRxTx(serial_rxtx *rxtx)
{
    delete rxtx;
}

}} //end rp::hal



================================================
File: src/rplidar_ros/sdk/src/arch/linux/net_serial.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2018 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

#include "hal/abs_rxtx.h"

namespace rp{ namespace arch{ namespace net{

class raw_serial : public rp::hal::serial_rxtx
{
public:
    enum{
        SERIAL_RX_BUFFER_SIZE = 512,
        SERIAL_TX_BUFFER_SIZE = 128,
    };

    raw_serial();
    virtual ~raw_serial();
    virtual bool bind(const char * portname, uint32_t baudrate, uint32_t flags = 0);
    virtual bool open();
    virtual void close();
    virtual void flush( _u32 flags);
    
    virtual int waitfordata(size_t data_count,_u32 timeout = -1, size_t * returned_size = NULL);

    virtual int senddata(const unsigned char * data, size_t size);
    virtual int recvdata(unsigned char * data, size_t size);

    virtual int waitforsent(_u32 timeout = -1, size_t * returned_size = NULL);
    virtual int waitforrecv(_u32 timeout = -1, size_t * returned_size = NULL);

    virtual size_t rxqueue_count();

    virtual void setDTR();
    virtual void clearDTR();

    _u32 getTermBaudBitmap(_u32 baud);

    virtual void cancelOperation();

protected:
    bool open(const char * portname, uint32_t baudrate, uint32_t flags = 0);
    void _init();

    char _portName[200];
    uint32_t _baudrate;
    uint32_t _flags;

    int serial_fd;

    size_t required_tx_cnt;
    size_t required_rx_cnt;

    int    _selfpipe[2];
    bool   _operation_aborted;
};

}}}



================================================
File: src/rplidar_ros/sdk/src/arch/linux/net_socket.cpp
================================================
/*
 *  RoboPeak Project
 *  HAL Layer - Socket Interface
 *  Copyright 2009 - 2013 RoboPeak Project
 *
 *  POXIS Implementation
 */


#include "sdkcommon.h"
#include "../../hal/socket.h"

#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netdb.h>

#include <net/if.h>
#include <sys/ioctl.h>
#include <linux/can.h>
#include <linux/can/raw.h>



namespace rp{ namespace net {


static inline int _halAddrTypeToOSType(SocketAddress::address_type_t type) 
{
    switch (type) {
        case SocketAddress::ADDRESS_TYPE_INET:
            return AF_INET;
        case SocketAddress::ADDRESS_TYPE_INET6:
            return AF_INET6;
        case SocketAddress::ADDRESS_TYPE_UNSPEC:
            return AF_UNSPEC;

        default:
            assert(!"should not reach here");
            return AF_UNSPEC;
    }
}


SocketAddress::SocketAddress() 
{
    _platform_data = reinterpret_cast<void *>(new sockaddr_storage);
    memset(_platform_data, 0, sizeof(sockaddr_storage));
    
    reinterpret_cast<sockaddr_storage *>(_platform_data)->ss_family = AF_INET;
}

SocketAddress::SocketAddress(const SocketAddress & src)
{
    _platform_data = reinterpret_cast<void *>(new sockaddr_storage);
    memcpy(_platform_data, src._platform_data, sizeof(sockaddr_storage));
}



SocketAddress::SocketAddress(const char * addrString, int port, SocketAddress::address_type_t type)
{
    _platform_data = reinterpret_cast<void *>(new sockaddr_storage);
    memset(_platform_data, 0, sizeof(sockaddr_storage));
    
    // default to ipv4 in case the following operation fails
    reinterpret_cast<sockaddr_storage *>(_platform_data)->ss_family = AF_INET;

    setAddressFromString(addrString, type);
    setPort(port);
}

SocketAddress::SocketAddress(void * platform_data)
 : _platform_data(platform_data)
{}

SocketAddress & SocketAddress::operator = (const SocketAddress &src)
{
    memcpy(_platform_data, src._platform_data, sizeof(sockaddr_storage));
    return *this;
}


SocketAddress::~SocketAddress()
{
    delete reinterpret_cast<sockaddr_storage *>(_platform_data);
}

SocketAddress::address_type_t SocketAddress::getAddressType() const
{
    switch(reinterpret_cast<const sockaddr_storage *>(_platform_data)->ss_family) {
        case AF_INET:
            return ADDRESS_TYPE_INET;
        case AF_INET6:
            return ADDRESS_TYPE_INET6;
        default:
            assert(!"should not reach here");
            return ADDRESS_TYPE_INET;
    }
}

int SocketAddress::getPort() const
{
    switch (getAddressType()) {
        case ADDRESS_TYPE_INET:
            return (int)ntohs(reinterpret_cast<const sockaddr_in *>(_platform_data)->sin_port);
        case ADDRESS_TYPE_INET6:
            return (int)ntohs(reinterpret_cast<const sockaddr_in6 *>(_platform_data)->sin6_port);
        default:
            return 0;
    }
}

u_result SocketAddress::setPort(int port)
{
    switch (getAddressType()) {
        case ADDRESS_TYPE_INET:
            reinterpret_cast<sockaddr_in *>(_platform_data)->sin_port = htons((short)port);
            break;
        case ADDRESS_TYPE_INET6:
            reinterpret_cast<sockaddr_in6 *>(_platform_data)->sin6_port = htons((short)port);
            break;
        default:
            return RESULT_OPERATION_FAIL;
    }
    return RESULT_OK;
}

u_result SocketAddress::setAddressFromString(const char * address_string,  SocketAddress::address_type_t type)
{
    int ans = 0;
    int prevPort = getPort();
    switch (type) {
        case ADDRESS_TYPE_INET:
            reinterpret_cast<sockaddr_storage *>(_platform_data)->ss_family = AF_INET;
            ans = inet_pton(AF_INET, 
                            address_string, 
                            &reinterpret_cast<sockaddr_in *>(_platform_data)->sin_addr);
        break;


        case ADDRESS_TYPE_INET6:
            
            reinterpret_cast<sockaddr_storage *>(_platform_data)->ss_family = AF_INET6;
            ans = inet_pton(AF_INET6, 
                            address_string, 
                            &reinterpret_cast<sockaddr_in6  *>(_platform_data)->sin6_addr);
        break;

        default:
            return RESULT_INVALID_DATA;

    }
    setPort(prevPort);

    return ans<=0?RESULT_INVALID_DATA:RESULT_OK;
}


u_result SocketAddress::getAddressAsString(char * buffer, size_t buffersize) const
{
    int net_family = reinterpret_cast<const sockaddr_storage *>(_platform_data)->ss_family;
    const char *ans = NULL;
    switch (net_family) {
        case AF_INET:
            ans = inet_ntop(net_family, &reinterpret_cast<const sockaddr_in *>(_platform_data)->sin_addr,
                            buffer, buffersize);
        break;

        case AF_INET6:
            ans = inet_ntop(net_family, &reinterpret_cast<const sockaddr_in6 *>(_platform_data)->sin6_addr,
                            buffer, buffersize);

        break;
    }
    return ans==NULL?RESULT_OPERATION_FAIL:RESULT_OK;
}



size_t SocketAddress::LoopUpHostName(const char * hostname, const char * sevicename, std::vector<SocketAddress> &addresspool , bool performDNS, SocketAddress::address_type_t type)
{
    struct addrinfo hints;
    struct addrinfo *result;
    int ans;

    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = _halAddrTypeToOSType(type);
    hints.ai_flags = AI_PASSIVE;

    if (!performDNS) {
        hints.ai_family |= AI_NUMERICSERV | AI_NUMERICHOST;
    
    }

    ans = getaddrinfo(hostname, sevicename, &hints, &result);

    addresspool.clear();

    if (ans != 0) {
        // hostname loopup failed
        return 0;
    }

    
    for (struct addrinfo * cursor = result; cursor != NULL; cursor = cursor->ai_next) {
        if (cursor->ai_family == ADDRESS_TYPE_INET || cursor->ai_family == ADDRESS_TYPE_INET6) {
            sockaddr_storage * storagebuffer = new sockaddr_storage;
            assert(sizeof(sockaddr_storage) >= cursor->ai_addrlen);
            memcpy(storagebuffer, cursor->ai_addr, cursor->ai_addrlen);
            addresspool.push_back(SocketAddress(storagebuffer));
        }
    }

    
    freeaddrinfo(result);

    return addresspool.size();
}


u_result SocketAddress::getRawAddress(_u8 * buffer, size_t bufferSize) const
{
     switch (getAddressType()) {
        case ADDRESS_TYPE_INET:
            if (bufferSize < sizeof(in_addr::s_addr)) return RESULT_INSUFFICIENT_MEMORY;

            memcpy(buffer, &reinterpret_cast<const sockaddr_in *>(_platform_data)->sin_addr.s_addr, sizeof(reinterpret_cast<const sockaddr_in *>(_platform_data)->sin_addr.s_addr));

            
            break;
        case ADDRESS_TYPE_INET6:
            if (bufferSize < sizeof(in6_addr::s6_addr)) return RESULT_INSUFFICIENT_MEMORY;
            memcpy(buffer, reinterpret_cast<const sockaddr_in6 *>(_platform_data)->sin6_addr.s6_addr, sizeof(reinterpret_cast<const sockaddr_in6 *>(_platform_data)->sin6_addr.s6_addr));

            break;
        default:
            return RESULT_OPERATION_FAIL;
    }
    return RESULT_OK;
}


void SocketAddress::setLoopbackAddress(SocketAddress::address_type_t type)
{

    int prevPort = getPort();
    switch (type) {
        case ADDRESS_TYPE_INET:
            {
                sockaddr_in * addrv4 = reinterpret_cast<sockaddr_in *>(_platform_data);
                addrv4->sin_family = AF_INET;
                addrv4->sin_addr.s_addr = htonl(INADDR_LOOPBACK);
            }
            break;
        case ADDRESS_TYPE_INET6:
            {
                sockaddr_in6  * addrv6 = reinterpret_cast<sockaddr_in6  *>(_platform_data);
                addrv6->sin6_family = AF_INET6;
                addrv6->sin6_addr = in6addr_loopback;

            }
            break;
        default:
            return;
    }

    setPort(prevPort);
}

void SocketAddress::setBroadcastAddressIPv4()
{

    int prevPort = getPort();
    sockaddr_in * addrv4 = reinterpret_cast<sockaddr_in *>(_platform_data);
    addrv4->sin_family = AF_INET;
    addrv4->sin_addr.s_addr = htonl(INADDR_BROADCAST);
    setPort(prevPort);

}

void SocketAddress::setAnyAddress(SocketAddress::address_type_t type)
{
    int prevPort = getPort();
    switch (type) {
        case ADDRESS_TYPE_INET:
            {
                sockaddr_in * addrv4 = reinterpret_cast<sockaddr_in *>(_platform_data);
                addrv4->sin_family = AF_INET;
                addrv4->sin_addr.s_addr = htonl(INADDR_ANY);
            }
            break;
        case ADDRESS_TYPE_INET6:
            {
                sockaddr_in6  * addrv6 = reinterpret_cast<sockaddr_in6  *>(_platform_data);
                addrv6->sin6_family = AF_INET6;
                addrv6->sin6_addr = in6addr_any;

            }
            break;
        default:
            return;
    }

    setPort(prevPort);


}


}}



///--------------------------------


namespace rp { namespace arch { namespace net{ 

using namespace rp::net;

class _single_thread StreamSocketImpl : public StreamSocket
{
public:

    StreamSocketImpl(int fd)
        : _socket_fd(fd)
    {
        assert(fd>=0);
        int bool_true = 1;
        ::setsockopt( _socket_fd, SOL_SOCKET, SO_REUSEADDR , (char *)&bool_true, sizeof(bool_true) );

        enableNoDelay(true);
        this->setTimeout(DEFAULT_SOCKET_TIMEOUT, SOCKET_DIR_BOTH);
    }

    virtual ~StreamSocketImpl() 
    {
        close(_socket_fd);
    }

    virtual void dispose()
    {
        delete this;
    }


    virtual u_result bind(const SocketAddress & localaddr)
    {
        const struct sockaddr * addr = reinterpret_cast<const struct sockaddr *>(localaddr.getPlatformData());
        assert(addr);
        int ans = ::bind(_socket_fd, addr, sizeof(sockaddr_storage));
        if (ans) {
            return RESULT_OPERATION_FAIL;
        } else {
            return RESULT_OK;
        }
    }

    virtual u_result getLocalAddress(SocketAddress & localaddr)
    {
        struct sockaddr * addr = reinterpret_cast<struct sockaddr *>( const_cast<void *>(localaddr.getPlatformData())); //donnot do this at home...
        assert(addr);

        size_t actualsize =  sizeof(sockaddr_storage);
        int ans = ::getsockname(_socket_fd, addr, (socklen_t*)&actualsize);

        assert(actualsize <= sizeof(sockaddr_storage));
        assert(addr->sa_family == AF_INET || addr->sa_family == AF_INET6);

        return ans?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result setTimeout(_u32 timeout, socket_direction_mask msk)
    {
        int ans;
        timeval tv;
        tv.tv_sec = timeout / 1000; 
        tv.tv_usec = (timeout % 1000) * 1000; 

        if (msk & SOCKET_DIR_RD) {
             ans = ::setsockopt( _socket_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv) );
             if (ans) return RESULT_OPERATION_FAIL;
        }

        if (msk & SOCKET_DIR_WR) {
             ans = ::setsockopt( _socket_fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv) );
             if (ans) return RESULT_OPERATION_FAIL;
        }

        return RESULT_OK;
    }
  
    virtual u_result connect(const SocketAddress & pairAddress)
    {
        const struct sockaddr * addr = reinterpret_cast<const struct sockaddr *>(pairAddress.getPlatformData());
        int ans = ::connect(_socket_fd, addr, sizeof(sockaddr_storage));
        if (!ans) return RESULT_OK;


        switch (errno) {
            case EAFNOSUPPORT:
                return RESULT_OPERATION_NOT_SUPPORT;
#if 0
            case EINPROGRESS:
                return RESULT_OK; //treat async connection as good status
#endif
            case ETIMEDOUT:
                return RESULT_OPERATION_TIMEOUT;
            default:
                return RESULT_OPERATION_FAIL;
        }
    }
      
    virtual u_result listen(int backlog)
    {
        int ans = ::listen( _socket_fd,   backlog);

        return ans?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual StreamSocket * accept(SocketAddress * pairAddress) 
    {
        size_t addrsize;
        addrsize = sizeof(sockaddr_storage);
        int pair_socket = ::accept( _socket_fd, pairAddress?reinterpret_cast<struct sockaddr *>(const_cast<void *>(pairAddress->getPlatformData())):NULL
            , (socklen_t*)&addrsize);

        if (pair_socket>=0) {
            return new StreamSocketImpl(pair_socket);
        } else {
            return NULL;
        }
    }

    virtual u_result waitforIncomingConnection(_u32 timeout)
    {
        return waitforData(timeout);
    }

    virtual u_result send(const void * buffer, size_t len) 
    {
        size_t ans = ::send( _socket_fd, buffer, len, MSG_NOSIGNAL);
        if (ans == len) {
            return RESULT_OK;
        } else {
            switch (errno) {
                case EAGAIN:
#if EWOULDBLOCK!=EAGAIN
                case EWOULDBLOCK:
#endif
                    return RESULT_OPERATION_TIMEOUT;
                default:
                    return RESULT_OPERATION_FAIL;
            }
        }
        
    }


    virtual u_result recv(void *buf, size_t len, size_t & recv_len)
    {
        size_t ans = ::recv( _socket_fd, buf, len, 0);
        if (ans == (size_t)-1) {
            recv_len = 0;  

            switch (errno) {
                case EAGAIN:
#if EWOULDBLOCK!=EAGAIN
                case EWOULDBLOCK:
#endif
                    return RESULT_OPERATION_TIMEOUT;
                default:
                    return RESULT_OPERATION_FAIL;
            }

            

        } else {
            recv_len = ans;
            return RESULT_OK;
        }
    }

#if 0
    virtual u_result recvNoWait(void *buf, size_t len, size_t & recv_len)
    {
        size_t ans = ::recv( _socket_fd, buf, len, MSG_DONTWAIT);
        if (ans == (size_t)-1) {
            recv_len = 0;  
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                return RESULT_OK; 
            } else {
                return RESULT_OPERATION_FAIL;
            }


        } else {
            recv_len = ans;
            return RESULT_OK;
        }

    }
#endif

    virtual u_result getPeerAddress(SocketAddress & peerAddr)
    {
        struct sockaddr * addr = reinterpret_cast<struct sockaddr *>(const_cast<void *>(peerAddr.getPlatformData())); //donnot do this at home...
        assert(addr);
        size_t actualsize =  sizeof(sockaddr_storage);
        int ans = ::getpeername(_socket_fd, addr, (socklen_t*)&actualsize);

        assert(actualsize <=  sizeof(sockaddr_storage));
        assert(addr->sa_family == AF_INET || addr->sa_family == AF_INET6);

        return ans?RESULT_OPERATION_FAIL:RESULT_OK;

    }

    virtual u_result shutdown(socket_direction_mask mask)
    {
        int shutdw_opt ;

        switch (mask) {
            case SOCKET_DIR_RD:
                shutdw_opt = SHUT_RD;
                break;
            case SOCKET_DIR_WR:
                shutdw_opt = SHUT_WR;
                break;
            case SOCKET_DIR_BOTH:
            default:
                shutdw_opt = SHUT_RDWR;
        }

        int ans = ::shutdown(_socket_fd, shutdw_opt);
        return ans?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result enableKeepAlive(bool enable)
    {
        int bool_true = enable?1:0;
        return ::setsockopt( _socket_fd, SOL_SOCKET, SO_KEEPALIVE , &bool_true, sizeof(bool_true) )?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result enableNoDelay(bool enable ) 
    {
        int bool_true = enable?1:0;
        return ::setsockopt( _socket_fd, IPPROTO_TCP, TCP_NODELAY,&bool_true, sizeof(bool_true) )?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result waitforSent(_u32 timeout ) 
    {
        fd_set wrset;
        FD_ZERO(&wrset);
        FD_SET(_socket_fd, &wrset);

        timeval tv;
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = (timeout % 1000) * 1000;
        int ans = ::select(_socket_fd+1, NULL, &wrset, NULL, &tv);

        switch (ans) {
            case 1:
                // fired
                return RESULT_OK;
            case 0:
                // timeout
                return RESULT_OPERATION_TIMEOUT;
            default:
                delay(0); //relax cpu
                return RESULT_OPERATION_FAIL;
        }
    }

    virtual u_result waitforData(_u32 timeout )
    {
        fd_set rdset;
        FD_ZERO(&rdset);
        FD_SET(_socket_fd, &rdset);

        timeval tv;
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = (timeout % 1000) * 1000;
        int ans = ::select(_socket_fd+1, &rdset, NULL, NULL, &tv);

        switch (ans) {
            case 1:
                // fired
                return RESULT_OK;
            case 0:
                // timeout
                return RESULT_OPERATION_TIMEOUT;
            default:
                delay(0); //relax cpu
                return RESULT_OPERATION_FAIL;
        }
    }

protected:
    int  _socket_fd;


};


class _single_thread DGramSocketImpl : public DGramSocket
{
public:

    DGramSocketImpl(int fd)
        : _socket_fd(fd)
    {
        assert(fd>=0);
        int bool_true = 1;
        ::setsockopt( _socket_fd, SOL_SOCKET, SO_REUSEADDR | SO_BROADCAST , (char *)&bool_true, sizeof(bool_true) );
        setTimeout(DEFAULT_SOCKET_TIMEOUT, SOCKET_DIR_BOTH);
    }

    virtual ~DGramSocketImpl() 
    {
        close(_socket_fd);
    }

    virtual void dispose()
    {
        delete this;
    }


    virtual u_result bind(const SocketAddress & localaddr)
    {
        const struct sockaddr * addr = reinterpret_cast<const struct sockaddr *>(localaddr.getPlatformData());
        assert(addr);
        int ans = ::bind(_socket_fd, addr, sizeof(sockaddr_storage));
        if (ans) {
            return RESULT_OPERATION_FAIL;
        } else {
            return RESULT_OK;
        }
    }

    virtual u_result getLocalAddress(SocketAddress & localaddr)
    {
        struct sockaddr * addr = reinterpret_cast<struct sockaddr *>(const_cast<void *>((localaddr.getPlatformData()))); //donnot do this at home...
        assert(addr);

        size_t actualsize =  sizeof(sockaddr_storage);
        int ans = ::getsockname(_socket_fd, addr, (socklen_t*)&actualsize);

        assert(actualsize <= sizeof(sockaddr_storage));
        assert(addr->sa_family == AF_INET || addr->sa_family == AF_INET6);

        return ans?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result setTimeout(_u32 timeout, socket_direction_mask msk)
    {
        int ans;
        timeval tv;
        tv.tv_sec = timeout / 1000; 
        tv.tv_usec = (timeout % 1000) * 1000; 

        if (msk & SOCKET_DIR_RD) {
             ans = ::setsockopt( _socket_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv) );
             if (ans) return RESULT_OPERATION_FAIL;
        }

        if (msk & SOCKET_DIR_WR) {
             ans = ::setsockopt( _socket_fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv) );
             if (ans) return RESULT_OPERATION_FAIL;
        }

        return RESULT_OK;
    }
  

    virtual u_result waitforSent(_u32 timeout ) 
    {
        fd_set wrset;
        FD_ZERO(&wrset);
        FD_SET(_socket_fd, &wrset);

        timeval tv;
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = (timeout % 1000) * 1000;
        int ans = ::select(_socket_fd+1, NULL, &wrset, NULL, &tv);

        switch (ans) {
            case 1:
                // fired
                return RESULT_OK;
            case 0:
                // timeout
                return RESULT_OPERATION_TIMEOUT;
            default:
                delay(0); //relax cpu
                return RESULT_OPERATION_FAIL;
        }
    }

    virtual u_result waitforData(_u32 timeout )
    {
        fd_set rdset;
        FD_ZERO(&rdset);
        FD_SET(_socket_fd, &rdset);

        timeval tv;
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = (timeout % 1000) * 1000;
        int ans = ::select(_socket_fd+1, &rdset, NULL, NULL, &tv);

        switch (ans) {
            case 1:
                // fired
                return RESULT_OK;
            case 0:
                // timeout
                return RESULT_OPERATION_TIMEOUT;
            default:
                delay(0); //relax cpu
                return RESULT_OPERATION_FAIL;
        }
    }

    virtual u_result sendTo(const SocketAddress * target, const void * buffer, size_t len)
    {
        const struct sockaddr * addr = target ? reinterpret_cast<const struct sockaddr *>(target->getPlatformData()) : NULL;
        int dest_addr_size = (target ? sizeof(sockaddr_storage) : 0);
        int ans = ::sendto(_socket_fd, (const char *)buffer, (int)len, 0, addr, dest_addr_size);
        if (ans != -1) {
            assert(ans == len);
            return RESULT_OK;
        } else {
            switch (errno) {
                case EAGAIN:
#if EWOULDBLOCK!=EAGAIN
                case EWOULDBLOCK:
#endif
                    return RESULT_OPERATION_TIMEOUT;

                case EMSGSIZE:
                    return RESULT_INVALID_DATA;
                default:
                    return RESULT_OPERATION_FAIL;
            }
        
        }

    }

    virtual u_result setPairAddress(const SocketAddress* pairAddress)
    {
        sockaddr_storage unspecAddr;
        unspecAddr.ss_family = AF_UNSPEC;

        const struct sockaddr* addr = pairAddress ? reinterpret_cast<const struct sockaddr*>(pairAddress->getPlatformData()) : reinterpret_cast<const struct sockaddr*>(&unspecAddr);
        int ans = ::connect(_socket_fd, addr, (int)sizeof(sockaddr_storage));
        return ans ? RESULT_OPERATION_FAIL : RESULT_OK;

    }
    
    virtual u_result clearRxCache()
    {
        timeval tv;
        tv.tv_sec = 0;
        tv.tv_usec = 0;
        fd_set rdset;
        FD_ZERO(&rdset);
        FD_SET(_socket_fd, &rdset);

        int res = -1;
        char recv_data[2];
        memset(recv_data, 0, sizeof(recv_data));
        while (true) {
            res = select(FD_SETSIZE, &rdset, nullptr, nullptr, &tv);
            if (res == 0) break;
            recv(_socket_fd, recv_data, 1, 0);
        }
        return RESULT_OK;
    }

    virtual u_result recvFrom(void *buf, size_t len, size_t & recv_len, SocketAddress * sourceAddr)
    {
        struct sockaddr * addr = (sourceAddr?reinterpret_cast<struct sockaddr *>(const_cast<void *>(sourceAddr->getPlatformData())):NULL);
        size_t source_addr_size = (sourceAddr?sizeof(sockaddr_storage):0);

        size_t ans = ::recvfrom( _socket_fd, buf, len, 0, addr, (socklen_t*)&source_addr_size);
        if (ans == (size_t)-1) {
            recv_len = 0;  
            switch (errno) {
                case EAGAIN:
#if EWOULDBLOCK!=EAGAIN
                case EWOULDBLOCK:
#endif
                    return RESULT_OPERATION_TIMEOUT;
                default:
                    return RESULT_OPERATION_FAIL;
            }

        } else {
            recv_len = ans;
            return RESULT_OK;
        }

    }

#if 0
    virtual u_result recvFromNoWait(void *buf, size_t len, size_t & recv_len, SocketAddress * sourceAddr)
    {
        struct sockaddr * addr = (sourceAddr?reinterpret_cast<struct sockaddr *>(const_cast<void *>(sourceAddr->getPlatformData())):NULL);
        size_t source_addr_size = (sourceAddr?sizeof(sockaddr_storage):0);


        size_t ans = ::recvfrom( _socket_fd, buf, len, MSG_DONTWAIT, addr, &source_addr_size);

        if (ans == (size_t)-1) {
            recv_len = 0;  
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                return RESULT_OK; 
            } else {
                return RESULT_OPERATION_FAIL;
            }


        } else {
            recv_len = ans;
            return RESULT_OK;
        }

    }
#endif
    
protected:
    int  _socket_fd;

};


}}}


namespace rp { namespace net{ 


static inline int _socketHalFamilyToOSFamily(SocketBase::socket_family_t family)
{
    switch (family) {
        case SocketBase::SOCKET_FAMILY_INET:
            return AF_INET;
        case SocketBase::SOCKET_FAMILY_INET6:
            return AF_INET6;
        case SocketBase::SOCKET_FAMILY_RAW:
            return AF_PACKET;
        default:
            assert(!"should not reach here");
            return AF_INET; // force treating as IPv4 in release mode
    }

}

StreamSocket * StreamSocket::CreateSocket(SocketBase::socket_family_t family)
{
    if (family == SOCKET_FAMILY_RAW) return NULL;


    int socket_family = _socketHalFamilyToOSFamily(family);
    int socket_fd = ::socket(socket_family, SOCK_STREAM, 0);
    if (socket_fd == -1) return NULL;

    StreamSocket * newborn = static_cast<StreamSocket *>(new rp::arch::net::StreamSocketImpl(socket_fd));
    return newborn;

}


DGramSocket * DGramSocket::CreateSocket(SocketBase::socket_family_t family)
{
    int socket_family = _socketHalFamilyToOSFamily(family);


    int socket_fd = ::socket(socket_family, (family==SOCKET_FAMILY_RAW)?SOCK_RAW:SOCK_DGRAM, 0);
    if (socket_fd == -1) return NULL;

    DGramSocket * newborn = static_cast<DGramSocket *>(new rp::arch::net::DGramSocketImpl(socket_fd));
    return newborn;

}


}}




================================================
File: src/rplidar_ros/sdk/src/arch/linux/thread.hpp
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2018 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "arch/linux/arch_linux.h"

#include <sched.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/resource.h>

namespace rp{ namespace hal{

Thread Thread::create(thread_proc_t proc, void * data)
{
    Thread newborn(proc, data);
    
    // tricky code, we assume pthread_t is not a structure but a word size value
    assert( sizeof(newborn._handle) >= sizeof(pthread_t));

    pthread_create((pthread_t *)&newborn._handle, NULL, (void * (*)(void *))proc, data);

    return newborn;
}

u_result Thread::terminate()
{
    if (!this->_handle) return RESULT_OK;
    
    return pthread_cancel((pthread_t)this->_handle)==0?RESULT_OK:RESULT_OPERATION_FAIL;
}

u_result Thread::SetSelfPriority( priority_val_t p)
{

    pid_t selfTid = syscall(SYS_gettid);

        // check whether current schedule policy supports priority levels
    int current_policy = SCHED_OTHER;
    struct sched_param current_param;
    int nice = 0;
    int ans;

    if (sched_getparam(selfTid, &current_param))
    {
        // cannot retreieve values
        return RESULT_OPERATION_FAIL;
    }   

    int pthread_priority_min;

#if 1
    pthread_priority_min = sched_get_priority_min(SCHED_RR);
#else
    pthread_priority_min = 1;
#endif
	int pthread_priority = 0 ;

	switch(p)
	{
	case PRIORITY_REALTIME:
		//pthread_priority = pthread_priority_max;
        current_policy = SCHED_RR;
        pthread_priority = pthread_priority_min + 1;
        nice = 0;
		break;
	case PRIORITY_HIGH:
		//pthread_priority = (pthread_priority_max + pthread_priority_min)/2;
        current_policy = SCHED_RR;
        pthread_priority = pthread_priority_min;
        nice = 0;
		break;
	case PRIORITY_NORMAL:
        pthread_priority = 0;
        current_policy = SCHED_OTHER;
        nice = 0;
        break;
	case PRIORITY_LOW:
        pthread_priority = 0;
        current_policy = SCHED_OTHER;
        nice = 10;
        break;
	case PRIORITY_IDLE:
		pthread_priority = 0;
        current_policy = SCHED_IDLE;
        nice = 0;
		break;
	}
    // change the inhertiable behavior
    current_policy |= SCHED_RESET_ON_FORK;

    current_param.__sched_priority = pthread_priority;

  

    
    // do not use pthread version as it will make the priority be inherited by a thread child
	if ( (ans = sched_setscheduler(selfTid, current_policy , &current_param)) )
	{
        if (ans == EPERM)
        {
            //DBG_PRINT("warning, current process hasn't the right permission to set threads priority\n");
        }
		return RESULT_OPERATION_FAIL;
	}


    if ((current_policy == SCHED_OTHER) || (current_policy == SCHED_BATCH))
    {
        if (setpriority(PRIO_PROCESS, selfTid, nice)) {
            return RESULT_OPERATION_FAIL;
        }
    }
    

	return  RESULT_OK;
}

Thread::priority_val_t Thread::getPriority()
{
	if (!this->_handle) return PRIORITY_NORMAL;

    int current_policy;
    struct sched_param current_param;
    if (pthread_getschedparam( (pthread_t) this->_handle, &current_policy, &current_param))
    {
        // cannot retreieve values
        return PRIORITY_NORMAL;
    }   

    int pthread_priority_max = sched_get_priority_max(SCHED_RR);
    int pthread_priority_min = sched_get_priority_min(SCHED_RR);

    if (current_param.__sched_priority ==(pthread_priority_max ))
	{
		return PRIORITY_REALTIME;
	}
	if (current_param.__sched_priority >=(pthread_priority_max + pthread_priority_min)/2)
	{
		return PRIORITY_HIGH;
	}
	return PRIORITY_NORMAL;
}

u_result Thread::join(unsigned long timeout)
{
    if (!this->_handle) return RESULT_OK;
    
    pthread_join((pthread_t)(this->_handle), NULL);
    this->_handle = 0;
    return RESULT_OK;
}

}}



================================================
File: src/rplidar_ros/sdk/src/arch/linux/timer.cpp
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2018 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "arch/linux/arch_linux.h"

namespace rp{ namespace arch{
_u64 rp_getus()
{
    struct timespec t;
    t.tv_sec = t.tv_nsec = 0;
    clock_gettime(CLOCK_MONOTONIC, &t);
    return t.tv_sec*1000000LL + t.tv_nsec/1000;
}
_u64 rp_getms()
{
    struct timespec t;
    t.tv_sec = t.tv_nsec = 0;
    clock_gettime(CLOCK_MONOTONIC, &t);
    return t.tv_sec*1000L + t.tv_nsec/1000000L;
}
}}



================================================
File: src/rplidar_ros/sdk/src/arch/linux/timer.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2018 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

#include "hal/types.h"

#include <unistd.h>
static inline void delay(_word_size_t ms){
    while (ms>=1000){
        usleep(1000*1000);
        ms-=1000;
    };
    if (ms!=0)
        usleep(ms*1000);
}

// TODO: the highest timer interface should be clock_gettime
namespace rp{ namespace arch{

_u64 rp_getus();
_u64 rp_getms();

}}

#define getms() rp::arch::rp_getms()
#define getus() rp::arch::rp_getus()




================================================
File: src/rplidar_ros/sdk/src/arch/macOS/arch_macOS.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2018 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

// libc dep
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include <time.h>
#include <stdarg.h>

// libc++ dep
#include <iostream>
#include <string>


// POSIX specific
extern "C" {
#include <unistd.h>
#include <errno.h>
#include <pthread.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <time.h>
}

#include "arch/macOS/timer.h"




================================================
File: src/rplidar_ros/sdk/src/arch/macOS/net_serial.cpp
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2018 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "arch/macOS/arch_macOS.h"
#include "arch/macOS/net_serial.h"
#include <termios.h>
#include <sys/select.h>
#include <IOKit/serial/ioss.h>

namespace rp{ namespace arch{ namespace net{

raw_serial::raw_serial()
    : rp::hal::serial_rxtx()
    , _baudrate(0)
    , _flags(0)
    , serial_fd(-1)
{
    _init();
}

raw_serial::~raw_serial()
{
    close();

}

bool raw_serial::open()
{
    return open(_portName, _baudrate, _flags);
}

bool raw_serial::bind(const char * portname, uint32_t baudrate, uint32_t flags)
{   
    strncpy(_portName, portname, sizeof(_portName));
    _baudrate = baudrate;
    _flags    = flags;
    return true;
}

bool raw_serial::open(const char * portname, uint32_t baudrate, uint32_t flags)
{
    if (isOpened()) close();
    
    serial_fd = ::open(portname, O_RDWR | O_NOCTTY | O_NDELAY);

    if (serial_fd == -1) return false;

    struct termios options, oldopt;
    tcgetattr(serial_fd, &oldopt);
	bzero(&options,sizeof(struct termios));

    cfsetspeed(&options, B19200);

	// enable rx and tx
	options.c_cflag |= (CLOCAL | CREAD);


    options.c_cflag &= ~PARENB; //no checkbit
	options.c_cflag &= ~CSTOPB; //1bit stop bit

	options.c_cflag &= ~CSIZE;
    options.c_cflag |= CS8; /* Select 8 data bits */

#ifdef CNEW_RTSCTS
    options.c_cflag &= ~CNEW_RTSCTS; // no hw flow control
#endif

    options.c_iflag &= ~(IXON | IXOFF | IXANY); // no sw flow control

    // raw input mode   
    options.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
    // raw output mode   
    options.c_oflag &= ~OPOST;
    
    tcflush(serial_fd,TCIFLUSH); 

    if (tcsetattr(serial_fd, TCSANOW, &options))
    {
        close();
        return false;
    }
	
    printf("Setting serial port baudrate...\n");
    
    speed_t speed = (speed_t)baudrate;
    if (ioctl(serial_fd, IOSSIOSPEED, &speed)== -1) {
        printf("Error calling ioctl(..., IOSSIOSPEED, ...) %s - %s(%d).\n",
               portname, strerror(errno), errno);
        close();
        return false;
    }

    _is_serial_opened = true;

    //Clear the DTR bit to let the motor spin
    clearDTR();
    
    return true;
}

void raw_serial::close()
{
    if (serial_fd != -1)
        ::close(serial_fd);
    serial_fd = -1;
    
    _is_serial_opened = false;
}

int raw_serial::senddata(const unsigned char * data, size_t size)
{
// FIXME: non-block io should be used
    if (!isOpened()) return 0;

    if (data == NULL || size ==0) return 0;
    
    size_t tx_len = 0;
    required_tx_cnt = 0;
    do {
        int ans = ::write(serial_fd, data + tx_len, size-tx_len);
        
        if (ans == -1) return tx_len;
        
        tx_len += ans;
        required_tx_cnt = tx_len;
    }while (tx_len<size);
    
    
    return tx_len;
}


int raw_serial::recvdata(unsigned char * data, size_t size)
{
    if (!isOpened()) return 0;
    
    int ans = ::read(serial_fd, data, size);
    
    if (ans == -1) ans=0;
    required_rx_cnt = ans;
    return ans;
}


void raw_serial::flush( _u32 flags)
{
    tcflush(serial_fd,TCIFLUSH); 
}

int raw_serial::waitforsent(_u32 timeout, size_t * returned_size)
{
    if (returned_size) *returned_size = required_tx_cnt;
    return 0;
}

int raw_serial::waitforrecv(_u32 timeout, size_t * returned_size)
{
    if (!isOpened() ) return -1;
   
    if (returned_size) *returned_size = required_rx_cnt;
    return 0;
}

int raw_serial::waitfordata(size_t data_count, _u32 timeout, size_t * returned_size)
{
    size_t length = 0;
    if (returned_size==NULL) returned_size=(size_t *)&length;
    *returned_size = 0;
    
    int max_fd;
    fd_set input_set;
    struct timeval timeout_val;

    /* Initialize the input set */
    FD_ZERO(&input_set);
    FD_SET(serial_fd, &input_set);
    max_fd = serial_fd + 1;

    /* Initialize the timeout structure */
    timeout_val.tv_sec = timeout / 1000;
    timeout_val.tv_usec = (timeout % 1000) * 1000;

    if ( isOpened() )
    {
        int nread;

        if ( ioctl(serial_fd, FIONREAD, &nread) == -1) return ANS_DEV_ERR;

        *returned_size = nread;

        if (*returned_size >= data_count)
        {
            return 0;
        }
    }

    while ( isOpened() )
    {
        /* Do the select */
        int n = ::select(max_fd, &input_set, NULL, NULL, &timeout_val);

        if (n < 0)
        {
            // select error
            *returned_size =  0;
            return ANS_DEV_ERR;
        }
        else if (n == 0)
        {
            // time out
            *returned_size =0;
            return ANS_TIMEOUT;
        }
        else
        {
            // data avaliable
            assert (FD_ISSET(serial_fd, &input_set));


            if ( ioctl(serial_fd, FIONREAD, returned_size) == -1) return ANS_DEV_ERR;
            if (*returned_size >= data_count)
            {
                return 0;
            }
        }
        
    }

    *returned_size=0;
    return ANS_DEV_ERR;
}

size_t raw_serial::rxqueue_count()
{
    if  ( !isOpened() ) return 0;
    size_t remaining;
    
    if (::ioctl(serial_fd, FIONREAD, &remaining) == -1) return 0;
    return remaining;
}

void raw_serial::setDTR()
{
    if ( !isOpened() ) return;

    uint32_t dtr_bit = TIOCM_DTR;
    ioctl(serial_fd, TIOCMBIS, &dtr_bit);
}

void raw_serial::clearDTR()
{
    if ( !isOpened() ) return;

    uint32_t dtr_bit = TIOCM_DTR;
    ioctl(serial_fd, TIOCMBIC, &dtr_bit);
}

void raw_serial::_init()
{
    serial_fd = 0;
    _portName[0] = 0;
    required_tx_cnt = required_rx_cnt = 0;
}



_u32 raw_serial::getTermBaudBitmap(_u32 baud)
{
#define BAUD_CONV(_baud_) case _baud_:  return _baud_
    switch (baud)
    {
        BAUD_CONV(1200);
        BAUD_CONV(1800);
        BAUD_CONV(2400);
        BAUD_CONV(4800);
        BAUD_CONV(9600);
        BAUD_CONV(19200);
        BAUD_CONV(38400);
        BAUD_CONV(57600);
        BAUD_CONV(115200);
        BAUD_CONV(230400);
        BAUD_CONV(460800);
        BAUD_CONV(500000);
        BAUD_CONV(576000);
        BAUD_CONV(921600);
        BAUD_CONV(1000000);
        BAUD_CONV(1152000);
        BAUD_CONV(1500000);
        BAUD_CONV(2000000);
        BAUD_CONV(2500000);
        BAUD_CONV(3000000);
        BAUD_CONV(3500000);
        BAUD_CONV(4000000);
    }
    return -1;
}
    
}}} //end rp::arch::net



//begin rp::hal
namespace rp{ namespace hal{
    
    serial_rxtx * serial_rxtx::CreateRxTx()
    {
        return new rp::arch::net::raw_serial();
    }
    
    void serial_rxtx::ReleaseRxTx(serial_rxtx *rxtx)
    {
        delete rxtx;
    }
    
}} //end rp::hal



================================================
File: src/rplidar_ros/sdk/src/arch/macOS/net_serial.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2018 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

#include "hal/abs_rxtx.h"

namespace rp{ namespace arch{ namespace net{

class raw_serial : public rp::hal::serial_rxtx
{
public:
    enum{
        SERIAL_RX_BUFFER_SIZE = 512,
        SERIAL_TX_BUFFER_SIZE = 128,
    };

    raw_serial();
    virtual ~raw_serial();
    virtual bool bind(const char * portname, uint32_t baudrate, uint32_t flags = 0);
    virtual bool open();
    virtual void close();
    virtual void flush( _u32 flags);
    
    virtual int waitfordata(size_t data_count,_u32 timeout = -1, size_t * returned_size = NULL);

    virtual int senddata(const unsigned char * data, size_t size);
    virtual int recvdata(unsigned char * data, size_t size);

    virtual int waitforsent(_u32 timeout = -1, size_t * returned_size = NULL);
    virtual int waitforrecv(_u32 timeout = -1, size_t * returned_size = NULL);

    virtual size_t rxqueue_count();

    virtual void setDTR();
    virtual void clearDTR();

    _u32 getTermBaudBitmap(_u32 baud);
protected:
    bool open(const char * portname, uint32_t baudrate, uint32_t flags = 0);
    void _init();

    char _portName[200];
    uint32_t _baudrate;
    uint32_t _flags;

    int serial_fd;

    size_t required_tx_cnt;
    size_t required_rx_cnt;
};

}}}



================================================
File: src/rplidar_ros/sdk/src/arch/macOS/net_socket.cpp
================================================
/*
 *  RoboPeak Project
 *  HAL Layer - Socket Interface
 *  Copyright 2018 RoboPeak Project
 *
 *  macOS Implementation
 */


#include "sdkcommon.h"
#include "../../hal/socket.h"

#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netdb.h>

namespace rp{ namespace net {


static inline int _halAddrTypeToOSType(SocketAddress::address_type_t type) 
{
    switch (type) {
        case SocketAddress::ADDRESS_TYPE_INET:
            return AF_INET;
        case SocketAddress::ADDRESS_TYPE_INET6:
            return AF_INET6;
        case SocketAddress::ADDRESS_TYPE_UNSPEC:
            return AF_UNSPEC;

        default:
            assert(!"should not reach here");
            return AF_UNSPEC;
    }
}


SocketAddress::SocketAddress() 
{
    _platform_data = reinterpret_cast<void *>(new sockaddr_storage);
    memset(_platform_data, 0, sizeof(sockaddr_storage));
    
    reinterpret_cast<sockaddr_storage *>(_platform_data)->ss_family = AF_INET;
}

SocketAddress::SocketAddress(const SocketAddress & src)
{
    _platform_data = reinterpret_cast<void *>(new sockaddr_storage);
    memcpy(_platform_data, src._platform_data, sizeof(sockaddr_storage));
}



SocketAddress::SocketAddress(const char * addrString, int port, SocketAddress::address_type_t type)
{
    _platform_data = reinterpret_cast<void *>(new sockaddr_storage);
    memset(_platform_data, 0, sizeof(sockaddr_storage));
    
    // default to ipv4 in case the following operation fails
    reinterpret_cast<sockaddr_storage *>(_platform_data)->ss_family = AF_INET;

    setAddressFromString(addrString, type);
    setPort(port);
}

SocketAddress::SocketAddress(void * platform_data)
 : _platform_data(platform_data)
{}

SocketAddress & SocketAddress::operator = (const SocketAddress &src)
{
    memcpy(_platform_data, src._platform_data, sizeof(sockaddr_storage));
    return *this;
}


SocketAddress::~SocketAddress()
{
    delete reinterpret_cast<sockaddr_storage *>(_platform_data);
}

SocketAddress::address_type_t SocketAddress::getAddressType() const
{
    switch(reinterpret_cast<const sockaddr_storage *>(_platform_data)->ss_family) {
        case AF_INET:
            return ADDRESS_TYPE_INET;
        case AF_INET6:
            return ADDRESS_TYPE_INET6;
        default:
            assert(!"should not reach here");
            return ADDRESS_TYPE_INET;
    }
}

int SocketAddress::getPort() const
{
    switch (getAddressType()) {
        case ADDRESS_TYPE_INET:
            return (int)ntohs(reinterpret_cast<const sockaddr_in *>(_platform_data)->sin_port);
        case ADDRESS_TYPE_INET6:
            return (int)ntohs(reinterpret_cast<const sockaddr_in6 *>(_platform_data)->sin6_port);
        default:
            return 0;
    }
}

u_result SocketAddress::setPort(int port)
{
    switch (getAddressType()) {
        case ADDRESS_TYPE_INET:
            reinterpret_cast<sockaddr_in *>(_platform_data)->sin_port = htons((short)port);
            break;
        case ADDRESS_TYPE_INET6:
            reinterpret_cast<sockaddr_in6 *>(_platform_data)->sin6_port = htons((short)port);
            break;
        default:
            return RESULT_OPERATION_FAIL;
    }
    return RESULT_OK;
}

u_result SocketAddress::setAddressFromString(const char * address_string,  SocketAddress::address_type_t type)
{
    int ans = 0;
    int prevPort = getPort();
    switch (type) {
        case ADDRESS_TYPE_INET:
            reinterpret_cast<sockaddr_storage *>(_platform_data)->ss_family = AF_INET;
            ans = inet_pton(AF_INET, 
                            address_string, 
                            &reinterpret_cast<sockaddr_in *>(_platform_data)->sin_addr);
        break;


        case ADDRESS_TYPE_INET6:
            
            reinterpret_cast<sockaddr_storage *>(_platform_data)->ss_family = AF_INET6;
            ans = inet_pton(AF_INET6, 
                            address_string, 
                            &reinterpret_cast<sockaddr_in6  *>(_platform_data)->sin6_addr);
        break;

        default:
            return RESULT_INVALID_DATA;

    }
    setPort(prevPort);

    return ans<=0?RESULT_INVALID_DATA:RESULT_OK;
}


u_result SocketAddress::getAddressAsString(char * buffer, size_t buffersize) const
{
    int net_family = reinterpret_cast<const sockaddr_storage *>(_platform_data)->ss_family;
    const char *ans = NULL;
    switch (net_family) {
        case AF_INET:
            ans = inet_ntop(net_family, &reinterpret_cast<const sockaddr_in *>(_platform_data)->sin_addr,
                            buffer, buffersize);
        break;

        case AF_INET6:
            ans = inet_ntop(net_family, &reinterpret_cast<const sockaddr_in6 *>(_platform_data)->sin6_addr,
                            buffer, buffersize);

        break;
    }
    return !ans?RESULT_OPERATION_FAIL:RESULT_OK;
}



size_t SocketAddress::LoopUpHostName(const char * hostname, const char * sevicename, std::vector<SocketAddress> &addresspool , bool performDNS, SocketAddress::address_type_t type)
{
    struct addrinfo hints;
    struct addrinfo *result;
    int ans;

    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = _halAddrTypeToOSType(type);
    hints.ai_flags = AI_PASSIVE;

    if (!performDNS) {
        hints.ai_family |= AI_NUMERICSERV | AI_NUMERICHOST;
    
    }

    ans = getaddrinfo(hostname, sevicename, &hints, &result);

    addresspool.clear();

    if (ans != 0) {
        // hostname loopup failed
        return 0;
    }

    
    for (struct addrinfo * cursor = result; cursor != NULL; cursor = cursor->ai_next) {
        if (cursor->ai_family == ADDRESS_TYPE_INET || cursor->ai_family == ADDRESS_TYPE_INET6) {
            sockaddr_storage * storagebuffer = new sockaddr_storage;
            assert(sizeof(sockaddr_storage) >= cursor->ai_addrlen);
            memcpy(storagebuffer, cursor->ai_addr, cursor->ai_addrlen);
            addresspool.push_back(SocketAddress(storagebuffer));
        }
    }

    
    freeaddrinfo(result);

    return addresspool.size();
}


u_result SocketAddress::getRawAddress(_u8 * buffer, size_t bufferSize) const
{
     switch (getAddressType()) {
        case ADDRESS_TYPE_INET:
            if (bufferSize < sizeof(in_addr_t)) return RESULT_INSUFFICIENT_MEMORY;

            memcpy(buffer, &reinterpret_cast<const sockaddr_in *>(_platform_data)->sin_addr.s_addr, sizeof(reinterpret_cast<const sockaddr_in *>(_platform_data)->sin_addr.s_addr));

            
            break;
        case ADDRESS_TYPE_INET6:
            if (bufferSize < sizeof(in6_addr)) return RESULT_INSUFFICIENT_MEMORY;
            memcpy(buffer, reinterpret_cast<const sockaddr_in6 *>(_platform_data)->sin6_addr.s6_addr, sizeof(reinterpret_cast<const sockaddr_in6 *>(_platform_data)->sin6_addr.s6_addr));

            break;
        default:
            return RESULT_OPERATION_FAIL;
    }
    return RESULT_OK;
}


void SocketAddress::setLoopbackAddress(SocketAddress::address_type_t type)
{

    int prevPort = getPort();
    switch (type) {
        case ADDRESS_TYPE_INET:
            {
                sockaddr_in * addrv4 = reinterpret_cast<sockaddr_in *>(_platform_data);
                addrv4->sin_family = AF_INET;
                addrv4->sin_addr.s_addr = htonl(INADDR_LOOPBACK);
            }
            break;
        case ADDRESS_TYPE_INET6:
            {
                sockaddr_in6  * addrv6 = reinterpret_cast<sockaddr_in6  *>(_platform_data);
                addrv6->sin6_family = AF_INET6;
                addrv6->sin6_addr = in6addr_loopback;

            }
            break;
        default:
            return;
    }

    setPort(prevPort);
}

void SocketAddress::setBroadcastAddressIPv4()
{

    int prevPort = getPort();
    sockaddr_in * addrv4 = reinterpret_cast<sockaddr_in *>(_platform_data);
    addrv4->sin_family = AF_INET;
    addrv4->sin_addr.s_addr = htonl(INADDR_BROADCAST);
    setPort(prevPort);

}

void SocketAddress::setAnyAddress(SocketAddress::address_type_t type)
{
    int prevPort = getPort();
    switch (type) {
        case ADDRESS_TYPE_INET:
            {
                sockaddr_in * addrv4 = reinterpret_cast<sockaddr_in *>(_platform_data);
                addrv4->sin_family = AF_INET;
                addrv4->sin_addr.s_addr = htonl(INADDR_ANY);
            }
            break;
        case ADDRESS_TYPE_INET6:
            {
                sockaddr_in6  * addrv6 = reinterpret_cast<sockaddr_in6  *>(_platform_data);
                addrv6->sin6_family = AF_INET6;
                addrv6->sin6_addr = in6addr_any;

            }
            break;
        default:
            return;
    }

    setPort(prevPort);


}


}}



///--------------------------------


namespace rp { namespace arch { namespace net{ 

using namespace rp::net;

class _single_thread StreamSocketImpl : public StreamSocket
{
public:

    StreamSocketImpl(int fd)
        : _socket_fd(fd)
    {
        assert(fd>=0);
        int bool_true = 1;
        ::setsockopt( _socket_fd, SOL_SOCKET, SO_REUSEADDR , (char *)&bool_true, sizeof(bool_true) );
        ::setsockopt( _socket_fd, SOL_SOCKET, SO_NOSIGPIPE, (char*)&bool_true, sizeof(bool_true));

        enableNoDelay(true);
        this->setTimeout(DEFAULT_SOCKET_TIMEOUT, SOCKET_DIR_BOTH);
    }

    virtual ~StreamSocketImpl() 
    {
        close(_socket_fd);
    }

    virtual void dispose()
    {
        delete this;
    }


    virtual u_result bind(const SocketAddress & localaddr)
    {
        const struct sockaddr * addr = reinterpret_cast<const struct sockaddr *>(localaddr.getPlatformData());
        assert(addr);
        int ans = ::bind(_socket_fd, addr, sizeof(sockaddr_storage));
        if (ans) {
            return RESULT_OPERATION_FAIL;
        } else {
            return RESULT_OK;
        }
    }

    virtual u_result getLocalAddress(SocketAddress & localaddr)
    {
        struct sockaddr * addr = reinterpret_cast<struct sockaddr *>( const_cast<void *>(localaddr.getPlatformData())); //donnot do this at home...
        assert(addr);

        size_t actualsize =  sizeof(sockaddr_storage);
        int ans = ::getsockname(_socket_fd, addr, (socklen_t*)&actualsize);

        assert(actualsize <= sizeof(sockaddr_storage));
        assert(addr->sa_family == AF_INET || addr->sa_family == AF_INET6);

        return ans?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result setTimeout(_u32 timeout, socket_direction_mask msk)
    {
        int ans;
        timeval tv;
        tv.tv_sec = timeout / 1000; 
        tv.tv_usec = (timeout % 1000) * 1000; 

        if (msk & SOCKET_DIR_RD) {
             ans = ::setsockopt( _socket_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv) );
             if (ans) return RESULT_OPERATION_FAIL;
        }

        if (msk & SOCKET_DIR_WR) {
             ans = ::setsockopt( _socket_fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv) );
             if (ans) return RESULT_OPERATION_FAIL;
        }

        return RESULT_OK;
    }
  
    virtual u_result connect(const SocketAddress & pairAddress)
    {
        const struct sockaddr * addr = reinterpret_cast<const struct sockaddr *>(pairAddress.getPlatformData());

        int ans;
        if (pairAddress.getAddressType() == SocketAddress::ADDRESS_TYPE_INET) {
            ans = ::connect(_socket_fd, addr, sizeof(sockaddr_in));
        } else {
            ans = ::connect(_socket_fd, addr, sizeof(sockaddr_in6));
        }

        if (!ans) return RESULT_OK;


        switch (errno) {
            case EAFNOSUPPORT:
                return RESULT_OPERATION_NOT_SUPPORT;
#if 0
            case EINPROGRESS:
                return RESULT_OK; //treat async connection as good status
#endif
            case ETIMEDOUT:
                return RESULT_OPERATION_TIMEOUT;
            default:
                return RESULT_OPERATION_FAIL;
        }
    }
      
    virtual u_result listen(int backlog)
    {
        int ans = ::listen( _socket_fd,   backlog);

        return ans?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual StreamSocket * accept(SocketAddress * pairAddress) 
    {
        size_t addrsize;
        addrsize = sizeof(sockaddr_storage);
        int pair_socket = ::accept( _socket_fd, pairAddress?reinterpret_cast<struct sockaddr *>(const_cast<void *>(pairAddress->getPlatformData())):NULL
            , (socklen_t*)&addrsize);

        if (pair_socket>=0) {
            return new StreamSocketImpl(pair_socket);
        } else {
            return NULL;
        }
    }

    virtual u_result waitforIncomingConnection(_u32 timeout)
    {
        return waitforData(timeout);
    }

    virtual u_result send(const void * buffer, size_t len) 
    {
        size_t ans = ::send( _socket_fd, buffer, len, 0);
        if (ans == (int)len) {
            return RESULT_OK;
        } else {
            switch (errno) {
                case EAGAIN:
#if EWOULDBLOCK!=EAGAIN
                case EWOULDBLOCK:
#endif
                    return RESULT_OPERATION_TIMEOUT;
                default:
                    return RESULT_OPERATION_FAIL;
            }
        }
        
    }


    virtual u_result recv(void *buf, size_t len, size_t & recv_len)
    {
        size_t ans = ::recv( _socket_fd, buf, len, 0);
        if (ans == (size_t)-1) {
            recv_len = 0;  

            switch (errno) {
                case EAGAIN:
#if EWOULDBLOCK!=EAGAIN
                case EWOULDBLOCK:
#endif
                    return RESULT_OPERATION_TIMEOUT;
                default:
                    return RESULT_OPERATION_FAIL;
            }

            

        } else {
            recv_len = ans;
            return RESULT_OK;
        }
    }

#if 0
    virtual u_result recvNoWait(void *buf, size_t len, size_t & recv_len)
    {
        size_t ans = ::recv( _socket_fd, buf, len, MSG_DONTWAIT);
        if (ans == (size_t)-1) {
            recv_len = 0;  
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                return RESULT_OK; 
            } else {
                return RESULT_OPERATION_FAIL;
            }


        } else {
            recv_len = ans;
            return RESULT_OK;
        }

    }
#endif

    virtual u_result getPeerAddress(SocketAddress & peerAddr)
    {
        struct sockaddr * addr = reinterpret_cast<struct sockaddr *>(const_cast<void *>(peerAddr.getPlatformData())); //donnot do this at home...
        assert(addr);
        size_t actualsize =  sizeof(sockaddr_storage);
        int ans = ::getpeername(_socket_fd, addr, (socklen_t*)&actualsize);

        assert(actualsize <=  sizeof(sockaddr_storage));
        assert(addr->sa_family == AF_INET || addr->sa_family == AF_INET6);

        return ans?RESULT_OPERATION_FAIL:RESULT_OK;

    }

    virtual u_result shutdown(socket_direction_mask mask)
    {
        int shutdw_opt ;

        switch (mask) {
            case SOCKET_DIR_RD:
                shutdw_opt = SHUT_RD;
                break;
            case SOCKET_DIR_WR:
                shutdw_opt = SHUT_WR;
                break;
            case SOCKET_DIR_BOTH:
            default:
                shutdw_opt = SHUT_RDWR;
        }

        int ans = ::shutdown(_socket_fd, shutdw_opt);
        return ans?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result enableKeepAlive(bool enable)
    {
        int bool_true = enable?1:0;
        return ::setsockopt( _socket_fd, SOL_SOCKET, SO_KEEPALIVE , &bool_true, sizeof(bool_true) )?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result enableNoDelay(bool enable ) 
    {
        int bool_true = enable?1:0;
        return ::setsockopt( _socket_fd, IPPROTO_TCP, TCP_NODELAY,&bool_true, sizeof(bool_true) )?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result waitforSent(_u32 timeout ) 
    {
        fd_set wrset;
        FD_ZERO(&wrset);
        FD_SET(_socket_fd, &wrset);

        timeval tv;
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = (timeout % 1000) * 1000;
        int ans = ::select(_socket_fd+1, NULL, &wrset, NULL, &tv);

        switch (ans) {
            case 1:
                // fired
                return RESULT_OK;
            case 0:
                // timeout
                return RESULT_OPERATION_TIMEOUT;
            default:
                delay(0); //relax cpu
                return RESULT_OPERATION_FAIL;
        }
    }

    virtual u_result waitforData(_u32 timeout )
    {
        fd_set rdset;
        FD_ZERO(&rdset);
        FD_SET(_socket_fd, &rdset);

        timeval tv;
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = (timeout % 1000) * 1000;
        int ans = ::select(_socket_fd+1, &rdset, NULL, NULL, &tv);

        switch (ans) {
            case 1:
                // fired
                return RESULT_OK;
            case 0:
                // timeout
                return RESULT_OPERATION_TIMEOUT;
            default:
                delay(0); //relax cpu
                return RESULT_OPERATION_FAIL;
        }
    }

protected:
    int  _socket_fd;


};


class _single_thread DGramSocketImpl : public DGramSocket
{
public:

    DGramSocketImpl(int fd)
        : _socket_fd(fd)
    {
        assert(fd>=0);
        int bool_true = 1;
        ::setsockopt( _socket_fd, SOL_SOCKET, SO_REUSEADDR | SO_BROADCAST , (char *)&bool_true, sizeof(bool_true) );
        setTimeout(DEFAULT_SOCKET_TIMEOUT, SOCKET_DIR_BOTH);
    }

    virtual ~DGramSocketImpl() 
    {
        close(_socket_fd);
    }

    virtual void dispose()
    {
        delete this;
    }


    virtual u_result bind(const SocketAddress & localaddr)
    {
        const struct sockaddr * addr = reinterpret_cast<const struct sockaddr *>(localaddr.getPlatformData());
        assert(addr);
        int ans = ::bind(_socket_fd, addr, sizeof(sockaddr_storage));
        if (ans) {
            return RESULT_OPERATION_FAIL;
        } else {
            return RESULT_OK;
        }
    }

    virtual u_result getLocalAddress(SocketAddress & localaddr)
    {
        struct sockaddr * addr = reinterpret_cast<struct sockaddr *>(const_cast<void *>((localaddr.getPlatformData()))); //donnot do this at home...
        assert(addr);

        size_t actualsize =  sizeof(sockaddr_storage);
        int ans = ::getsockname(_socket_fd, addr, (socklen_t*)&actualsize);

        assert(actualsize <= sizeof(sockaddr_storage));
        assert(addr->sa_family == AF_INET || addr->sa_family == AF_INET6);

        return ans?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result setTimeout(_u32 timeout, socket_direction_mask msk)
    {
        int ans;
        timeval tv;
        tv.tv_sec = timeout / 1000; 
        tv.tv_usec = (timeout % 1000) * 1000; 

        if (msk & SOCKET_DIR_RD) {
             ans = ::setsockopt( _socket_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv) );
             if (ans) return RESULT_OPERATION_FAIL;
        }

        if (msk & SOCKET_DIR_WR) {
             ans = ::setsockopt( _socket_fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv) );
             if (ans) return RESULT_OPERATION_FAIL;
        }

        return RESULT_OK;
    }
  

    virtual u_result waitforSent(_u32 timeout ) 
    {
        fd_set wrset;
        FD_ZERO(&wrset);
        FD_SET(_socket_fd, &wrset);

        timeval tv;
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = (timeout % 1000) * 1000;
        int ans = ::select(_socket_fd+1, NULL, &wrset, NULL, &tv);

        switch (ans) {
            case 1:
                // fired
                return RESULT_OK;
            case 0:
                // timeout
                return RESULT_OPERATION_TIMEOUT;
            default:
                delay(0); //relax cpu
                return RESULT_OPERATION_FAIL;
        }
    }

    virtual u_result waitforData(_u32 timeout )
    {
        fd_set rdset;
        FD_ZERO(&rdset);
        FD_SET(_socket_fd, &rdset);

        timeval tv;
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = (timeout % 1000) * 1000;
        int ans = ::select(_socket_fd+1, &rdset, NULL, NULL, &tv);

        switch (ans) {
            case 1:
                // fired
                return RESULT_OK;
            case 0:
                // timeout
                return RESULT_OPERATION_TIMEOUT;
            default:
                delay(0); //relax cpu
                return RESULT_OPERATION_FAIL;
        }
    }

    virtual u_result sendTo(const SocketAddress * target, const void * buffer, size_t len)
    {
        const struct sockaddr * addr = target ? reinterpret_cast<const struct sockaddr *>(target->getPlatformData()) : NULL;
        int dest_addr_size = (target ? sizeof(sockaddr_storage) : 0);
        int ans = ::sendto(_socket_fd, (const char *)buffer, (int)len, 0, addr, dest_addr_size);
        if (ans != -1) {
            assert(ans == (int)len);
            return RESULT_OK;
        } else {
            switch (errno) {
                case EAGAIN:
#if EWOULDBLOCK!=EAGAIN
                case EWOULDBLOCK:
#endif
                    return RESULT_OPERATION_TIMEOUT;

                case EMSGSIZE:
                    return RESULT_INVALID_DATA;
                default:
                    return RESULT_OPERATION_FAIL;
            }
        
        }

    }
    virtual u_result setPairAddress(const SocketAddress* pairAddress)
    {
        sockaddr_storage unspecAddr;
        unspecAddr.ss_family = AF_UNSPEC;

        const struct sockaddr* addr = pairAddress ? reinterpret_cast<const struct sockaddr*>(pairAddress->getPlatformData()) : reinterpret_cast<const struct sockaddr*>(&unspecAddr);
        int ans;
        if (pairAddress->getAddressType() == SocketAddress::ADDRESS_TYPE_INET) {
            ans = ::connect(_socket_fd, addr, sizeof(sockaddr_in));
        } else {
            ans = ::connect(_socket_fd, addr, sizeof(sockaddr_in6));
        }   
        return ans ? RESULT_OPERATION_FAIL : RESULT_OK;

    }
    
    virtual u_result clearRxCache()
    {
        timeval tv;
        tv.tv_sec = 0;
        tv.tv_usec = 0;
        fd_set rdset;
        FD_ZERO(&rdset);
        FD_SET(_socket_fd, &rdset);

        int res = -1;
        char recv_data[2];
        memset(recv_data, 0, sizeof(recv_data));
        while (true) {
            res = select(FD_SETSIZE, &rdset, nullptr, nullptr, &tv);
            if (res == 0) break;
            recv(_socket_fd, recv_data, 1, 0);
        }
        return RESULT_OK;
    }

    virtual u_result recvFrom(void *buf, size_t len, size_t & recv_len, SocketAddress * sourceAddr)
    {
        struct sockaddr * addr = (sourceAddr?reinterpret_cast<struct sockaddr *>(const_cast<void *>(sourceAddr->getPlatformData())):NULL);
        size_t source_addr_size = (sourceAddr?sizeof(sockaddr_storage):0);

        size_t ans = ::recvfrom( _socket_fd, buf, len, 0, addr, (socklen_t*)&source_addr_size);
        if (ans == (size_t)-1) {
            recv_len = 0;  
            switch (errno) {
                case EAGAIN:
#if EWOULDBLOCK!=EAGAIN
                case EWOULDBLOCK:
#endif
                    return RESULT_OPERATION_TIMEOUT;
                default:
                    return RESULT_OPERATION_FAIL;
            }

        } else {
            recv_len = ans;
            return RESULT_OK;
        }

    }

#if 0
    virtual u_result recvFromNoWait(void *buf, size_t len, size_t & recv_len, SocketAddress * sourceAddr)
    {
        struct sockaddr * addr = (sourceAddr?reinterpret_cast<struct sockaddr *>(const_cast<void *>(sourceAddr->getPlatformData())):NULL);
        size_t source_addr_size = (sourceAddr?sizeof(sockaddr_storage):0);


        size_t ans = ::recvfrom( _socket_fd, buf, len, MSG_DONTWAIT, addr, &source_addr_size);

        if (ans == (size_t)-1) {
            recv_len = 0;  
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                return RESULT_OK; 
            } else {
                return RESULT_OPERATION_FAIL;
            }


        } else {
            recv_len = ans;
            return RESULT_OK;
        }

    }
#endif
    
protected:
    int  _socket_fd;

};


}}}


namespace rp { namespace net{ 


static inline int _socketHalFamilyToOSFamily(SocketBase::socket_family_t family)
{
    switch (family) {
        case SocketBase::SOCKET_FAMILY_INET:
            return AF_INET;
        case SocketBase::SOCKET_FAMILY_INET6:
            return AF_INET6;
        case SocketBase::SOCKET_FAMILY_RAW:
            assert(!"should not reach here, AF_PACKET is not supported on macOS");
            return AF_INET;
        default:
            assert(!"should not reach here");
            return AF_INET; // force treating as IPv4 in release mode
    }

}

StreamSocket * StreamSocket::CreateSocket(SocketBase::socket_family_t family)
{
    if (family == SOCKET_FAMILY_RAW) return NULL;


    int socket_family = _socketHalFamilyToOSFamily(family);
    int socket_fd = ::socket(socket_family, SOCK_STREAM, 0);
    if (socket_fd == -1) return NULL;

    StreamSocket * newborn = static_cast<StreamSocket *>(new rp::arch::net::StreamSocketImpl(socket_fd));
    return newborn;

}


DGramSocket * DGramSocket::CreateSocket(SocketBase::socket_family_t family)
{
    int socket_family = _socketHalFamilyToOSFamily(family);


    int socket_fd = ::socket(socket_family, (family==SOCKET_FAMILY_RAW)?SOCK_RAW:SOCK_DGRAM, 0);
    if (socket_fd == -1) return NULL;

    DGramSocket * newborn = static_cast<DGramSocket *>(new rp::arch::net::DGramSocketImpl(socket_fd));
    return newborn;

}


}}




================================================
File: src/rplidar_ros/sdk/src/arch/macOS/thread.hpp
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2018 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "arch/macOS/arch_macOS.h"

namespace rp{ namespace hal{

Thread Thread::create(thread_proc_t proc, void * data)
{
    Thread newborn(proc, data);
    
    // tricky code, we assume pthread_t is not a structure but a word size value
    assert( sizeof(newborn._handle) >= sizeof(pthread_t));

    pthread_create((pthread_t *)&newborn._handle, NULL,(void * (*)(void *))proc, data);

    return newborn;
}

u_result Thread::terminate()
{
    if (!this->_handle) return RESULT_OK;
    
  //  return pthread_cancel((pthread_t)this->_handle)==0?RESULT_OK:RESULT_OPERATION_FAIL;
    return RESULT_OK;
}

u_result Thread::SetSelfPriority( priority_val_t p)
{
    // simply ignore this request
	return  RESULT_OK;
}

Thread::priority_val_t Thread::getPriority()
{
	return PRIORITY_NORMAL;
}

u_result Thread::join(unsigned long timeout)
{
    if (!this->_handle) return RESULT_OK;
    
    pthread_join((pthread_t)(this->_handle), NULL);
    this->_handle = 0;
    return RESULT_OK;
}

}}



================================================
File: src/rplidar_ros/sdk/src/arch/macOS/timer.cpp
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2018 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "arch/macOS/arch_macOS.h"


namespace rp{ namespace arch{
_u64 rp_getus()
{
    struct timespec t;
    t.tv_sec = t.tv_nsec = 0;
    clock_gettime(CLOCK_MONOTONIC, &t);
    return t.tv_sec*1000000LL + t.tv_nsec/1000;
}
_u64 rp_getms()
{
    struct timespec t;
    t.tv_sec = t.tv_nsec = 0;
    clock_gettime(CLOCK_MONOTONIC, &t);
    return t.tv_sec*1000L + t.tv_nsec/1000000L;
}

}}



================================================
File: src/rplidar_ros/sdk/src/arch/macOS/timer.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2018 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

#include "rptypes.h"

#include <unistd.h>
static inline void delay(_word_size_t ms){
    while (ms>=1000){
        usleep(1000*1000);
        ms-=1000;
    };
    if (ms!=0)
        usleep(ms*1000);
}

// TODO: the highest timer interface should be clock_gettime
namespace rp{ namespace arch{

_u64 rp_getus();
_u64 rp_getms();

}}

#define getms() rp::arch::rp_getms()
#define getus() rp::arch::rp_getus()



================================================
File: src/rplidar_ros/sdk/src/arch/win32/arch_win32.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

#pragma warning (disable: 4996)
#define _CRT_SECURE_NO_WARNINGS

#ifndef WINVER
#define WINVER		0x0500
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT	0x0501
#endif


#ifndef _WIN32_IE
#define _WIN32_IE	0x0501
#endif

#ifndef _RICHEDIT_VER
#define _RICHEDIT_VER	0x0200
#endif


#include <stddef.h>
#include <stdio.h>
#include <windows.h>
#include <stdlib.h>   //for memcpy etc..
#include <process.h>
#include <direct.h> 


#include "timer.h"



================================================
File: src/rplidar_ros/sdk/src/arch/win32/net_serial.cpp
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "sdkcommon.h"
#include "net_serial.h"

namespace rp{ namespace arch{ namespace net{

raw_serial::raw_serial()
    : rp::hal::serial_rxtx()
    , _serial_handle(NULL)
    , _baudrate(0)
    , _flags(0)
{
    _init();
}

raw_serial::~raw_serial()
{
    close();

    CloseHandle(_ro.hEvent);
    CloseHandle(_wo.hEvent);
    CloseHandle(_wait_o.hEvent);
}

bool raw_serial::open()
{
    return open(_portName, _baudrate, _flags);
}

bool raw_serial::bind(const char * portname, _u32 baudrate, _u32 flags)
{   
    strncpy(_portName, portname, sizeof(_portName));
    _baudrate = baudrate;
    _flags    = flags;
    return true;
}

bool raw_serial::open(const char * portname, _u32 baudrate, _u32 flags)
{
#ifdef _UNICODE
    wchar_t wportname[1024];
    mbstowcs(wportname, portname, sizeof(wportname) / sizeof(wchar_t));
#endif

    if (isOpened()) close();
    
    _serial_handle = CreateFile(
#ifdef _UNICODE
        wportname,
#else
        portname,
#endif
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        NULL
        );

    if (_serial_handle == INVALID_HANDLE_VALUE) return false;

    if (!SetupComm(_serial_handle, SERIAL_RX_BUFFER_SIZE, SERIAL_TX_BUFFER_SIZE))
    {
        close();
        return false;
    }
    
    _dcb.BaudRate = baudrate;
    _dcb.ByteSize = 8;
    _dcb.Parity   = NOPARITY;
    _dcb.StopBits = ONESTOPBIT;
    _dcb.fDtrControl = DTR_CONTROL_ENABLE;

    if (!SetCommState(_serial_handle, &_dcb))
    {
        close();
        return false;
    }

    if (!SetCommTimeouts(_serial_handle, &_co))
    {
        close();
        return false;
    }

    if (!SetCommMask(_serial_handle, EV_RXCHAR | EV_ERR ))
    {
        close();
        return false;
    }

    if (!PurgeComm(_serial_handle, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR ))
    {
        close();
        return false;
    }

    Sleep(30); 
    _is_serial_opened = true;

    //Clear the DTR bit set DTR=high
    clearDTR();

    return true;
}

void raw_serial::close()
{
    SetCommMask(_serial_handle, 0);
    ResetEvent(_wait_o.hEvent);

    CloseHandle(_serial_handle);
    _serial_handle = INVALID_HANDLE_VALUE;
    
    _is_serial_opened = false;
}

int raw_serial::senddata(const unsigned char * data, size_t size)
{
    DWORD    error;
    DWORD w_len = 0, o_len = -1;
    if (!isOpened()) return ANS_DEV_ERR;

    if (data == NULL || size ==0) return 0;
    
    if(ClearCommError(_serial_handle, &error, NULL) && error > 0)
        PurgeComm(_serial_handle, PURGE_TXABORT | PURGE_TXCLEAR);

    if(!WriteFile(_serial_handle, data, (DWORD)size, &w_len, &_wo))
        if(GetLastError() != ERROR_IO_PENDING)
            w_len = ANS_DEV_ERR;

    return w_len;
}

int raw_serial::recvdata(unsigned char * data, size_t size)
{
    if (!isOpened()) return 0;
    DWORD r_len = 0;


    if(!ReadFile(_serial_handle, data, (DWORD)size, &r_len, &_ro))
    {
        if(GetLastError() == ERROR_IO_PENDING) 
        {
            if(!GetOverlappedResult(_serial_handle, &_ro, &r_len, FALSE))
            {
                if(GetLastError() != ERROR_IO_INCOMPLETE)
                    r_len = 0;
            }
        }
        else
            r_len = 0;
    }

    return r_len;
}

void raw_serial::flush( _u32 flags)
{
    PurgeComm(_serial_handle, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR );
}

int raw_serial::waitforsent(_u32 timeout, size_t * returned_size)
{
    if (!isOpened() ) return ANS_DEV_ERR;
    DWORD w_len = 0;
    _word_size_t ans =0;

    if (WaitForSingleObject(_wo.hEvent, timeout) == WAIT_TIMEOUT)
    {
        ans = ANS_TIMEOUT;
        goto _final;
    }
    if(!GetOverlappedResult(_serial_handle, &_wo, &w_len, FALSE))
    {
        ans = ANS_DEV_ERR;
    }
_final:
    if (returned_size) *returned_size = w_len;
    return (int)ans;
}

int raw_serial::waitforrecv(_u32 timeout, size_t * returned_size)
{
    if (!isOpened() ) return -1;
    DWORD r_len = 0;
    _word_size_t ans =0;

    if (WaitForSingleObject(_ro.hEvent, timeout) == WAIT_TIMEOUT)
    {
        ans = ANS_TIMEOUT;
    }
    if(!GetOverlappedResult(_serial_handle, &_ro, &r_len, FALSE))
    {
        ans = ANS_DEV_ERR;
    }
    if (returned_size) *returned_size = r_len;
    return (int)ans;
}

int raw_serial::waitfordata(size_t data_count, _u32 timeout, size_t * returned_size)
{
    COMSTAT  stat;
    DWORD error;
    DWORD msk,length;
    size_t dummy_length;

    if (returned_size==NULL) returned_size=(size_t *)&dummy_length;

    
    if ( isOpened()) {
        size_t rxqueue_remaining =  rxqueue_count();
        if (rxqueue_remaining >= data_count) {
            *returned_size = rxqueue_remaining;
            return 0;
        }
    }

    while ( isOpened() )
    {
        msk = 0;
        SetCommMask(_serial_handle, EV_RXCHAR | EV_ERR );
        if(!WaitCommEvent(_serial_handle, &msk, &_wait_o))
        {
            if(GetLastError() == ERROR_IO_PENDING)
            {
                if (WaitForSingleObject(_wait_o.hEvent, timeout) == WAIT_TIMEOUT)
                {
                    *returned_size =0;
                    return ANS_TIMEOUT;
                }

                GetOverlappedResult(_serial_handle, &_wait_o, &length, TRUE);

                ::ResetEvent(_wait_o.hEvent);
            }else
            {
                ClearCommError(_serial_handle, &error, &stat);
                 *returned_size = stat.cbInQue;
                return ANS_DEV_ERR;
            }
        }

        if(msk & EV_ERR){
            // FIXME: may cause problem here
            ClearCommError(_serial_handle, &error, &stat);
        }

        if(msk & EV_RXCHAR){
            ClearCommError(_serial_handle, &error, &stat);
            if(stat.cbInQue >= data_count)
            {
                *returned_size = stat.cbInQue;
                return 0;
            }
        }
    }
    *returned_size=0;
    return ANS_DEV_ERR;
}

size_t raw_serial::rxqueue_count()
{
    if  ( !isOpened() ) return 0;
    COMSTAT  com_stat;
    DWORD error;
    DWORD r_len = 0;

    if(ClearCommError(_serial_handle, &error, &com_stat) && error > 0)
    {
        PurgeComm(_serial_handle, PURGE_RXABORT | PURGE_RXCLEAR);
        return 0;
    }
    return com_stat.cbInQue;
}

void raw_serial::setDTR()
{
    if ( !isOpened() ) return;

    EscapeCommFunction(_serial_handle, SETDTR);
}

void raw_serial::clearDTR()
{
    if ( !isOpened() ) return;

    EscapeCommFunction(_serial_handle, CLRDTR);
}


void raw_serial::_init()
{
    memset(&_dcb, 0, sizeof(_dcb));
    _dcb.DCBlength = sizeof(_dcb);
    _serial_handle = INVALID_HANDLE_VALUE;
    memset(&_co, 0, sizeof(_co));
    _co.ReadIntervalTimeout = 0;
    _co.ReadTotalTimeoutMultiplier = 0;
    _co.ReadTotalTimeoutConstant = 0;
    _co.WriteTotalTimeoutMultiplier = 0;
    _co.WriteTotalTimeoutConstant = 0;

    memset(&_ro, 0, sizeof(_ro));
    memset(&_wo, 0, sizeof(_wo));
    memset(&_wait_o, 0, sizeof(_wait_o));

    _ro.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    _wo.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    _wait_o.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    _portName[0] = 0;
}

}}} //end rp::arch::net


//begin rp::hal
namespace rp{ namespace hal{

serial_rxtx * serial_rxtx::CreateRxTx()
{
    return new rp::arch::net::raw_serial();
}

void  serial_rxtx::ReleaseRxTx( serial_rxtx * rxtx)
{
    delete rxtx;
}


}} //end rp::hal



================================================
File: src/rplidar_ros/sdk/src/arch/win32/net_serial.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

#include "hal/abs_rxtx.h"

namespace rp{ namespace arch{ namespace net{

class raw_serial : public rp::hal::serial_rxtx
{
public:
    enum{
        SERIAL_RX_BUFFER_SIZE = 512,
        SERIAL_TX_BUFFER_SIZE = 128,
        SERIAL_RX_TIMEOUT     = 2000,
        SERIAL_TX_TIMEOUT     = 2000,
    };

    raw_serial();
    virtual ~raw_serial();
    virtual bool bind(const char * portname, _u32 baudrate, _u32 flags = 0);
    virtual bool open();
    virtual void close();
    virtual void flush( _u32 flags);
    
    virtual int waitfordata(size_t data_count,_u32 timeout = -1, size_t * returned_size = NULL);

    virtual int senddata(const unsigned char * data, size_t size);
    virtual int recvdata(unsigned char * data, size_t size);

    virtual int waitforsent(_u32 timeout = -1, size_t * returned_size = NULL);
    virtual int waitforrecv(_u32 timeout = -1, size_t * returned_size = NULL);

    virtual size_t rxqueue_count();

    virtual void setDTR();
    virtual void clearDTR();

protected:
    bool open(const char * portname, _u32 baudrate, _u32 flags);
    void _init();

    char _portName[20];
    uint32_t _baudrate;
    uint32_t _flags;

    OVERLAPPED _ro, _wo;
    OVERLAPPED _wait_o;
    volatile HANDLE _serial_handle;
    DCB _dcb;
    COMMTIMEOUTS _co;
};

}}}



================================================
File: src/rplidar_ros/sdk/src/arch/win32/net_socket.cpp
================================================
/*
 *  RoboPeak Project
 *  HAL Layer - Socket Interface
 *  Copyright 2009 - 2013 RoboPeak Project
 *
 *  Win32 Implementation
 */

#define _WINSOCKAPI_

#include "sdkcommon.h"
#include "..\..\hal\socket.h"
#include <windows.h>  
#include <winsock2.h>
#include <ws2tcpip.h>

#include <stdlib.h>  
#include <stdio.h>  
#pragma comment (lib, "Ws2_32.lib")

namespace rp{ namespace net {

static volatile bool _isWSAStartupCalled = false;

static inline bool _checkWSAStartup() {
    int  iResult;
    WSADATA wsaData;
    if (!_isWSAStartupCalled) {
        iResult = WSAStartup(MAKEWORD(2,2), &wsaData);
        if (iResult != 0) {
            return false;
        }
        _isWSAStartupCalled = true;
    }
    return true;
}

static const char* _inet_ntop(int af, const void* src, char* dst, int cnt){

	struct sockaddr_storage srcaddr;


    memset(dst, 0, cnt);

	memset(&srcaddr, 0, sizeof(struct sockaddr_storage));
	

    srcaddr.ss_family = af;

    switch (af) {
    case AF_INET:
        {
            struct sockaddr_in * ipv4 = reinterpret_cast< struct sockaddr_in *>(&srcaddr);
            memcpy(&(ipv4->sin_addr), src, sizeof(ipv4->sin_addr));
        }
        break;
    case AF_INET6:
        {
            struct sockaddr_in6 * ipv6 = reinterpret_cast< struct sockaddr_in6 *>(&srcaddr);
            memcpy(&(ipv6->sin6_addr), src, sizeof(ipv6->sin6_addr));
        }
        break;
    }

	if (WSAAddressToStringA((struct sockaddr*) &srcaddr, sizeof(struct sockaddr_storage), 0, dst, (LPDWORD) &cnt) != 0) {
		DWORD rv = WSAGetLastError();
		return NULL;
	}
	return dst;
}

static int _inet_pton(int Family, const char * pszAddrString, void* pAddrBuf)
{
    struct sockaddr_storage tmpholder;
    int actualSize =  sizeof(sockaddr_storage);

    int result = WSAStringToAddressA((char *)pszAddrString, Family, NULL, (sockaddr*)&tmpholder, &actualSize);
    if (result) return -1;

    switch (Family) {
        case AF_INET:
            {
                struct sockaddr_in * ipv4 = reinterpret_cast< struct sockaddr_in *>(&tmpholder);
                memcpy(pAddrBuf, &(ipv4->sin_addr), sizeof(ipv4->sin_addr));
            }
            break;
        case AF_INET6:
            {
                struct sockaddr_in6 * ipv6 = reinterpret_cast< struct sockaddr_in6 *>(&tmpholder);
                memcpy(pAddrBuf, &(ipv6->sin6_addr), sizeof(ipv6->sin6_addr));
            }
            break;
    }
    return 1;
}

static inline int _halAddrTypeToOSType(SocketAddress::address_type_t type) 
{
    switch (type) {
        case SocketAddress::ADDRESS_TYPE_INET:
            return AF_INET;
        case SocketAddress::ADDRESS_TYPE_INET6:
            return AF_INET6;
        case SocketAddress::ADDRESS_TYPE_UNSPEC:
            return AF_UNSPEC;

        default:
            assert(!"should not reach here");
            return AF_UNSPEC;
    }
}


SocketAddress::SocketAddress() 
{
    _checkWSAStartup();
    _platform_data = reinterpret_cast<void *>(new sockaddr_storage);
    memset(_platform_data, 0, sizeof(sockaddr_storage));
    
    reinterpret_cast<sockaddr_storage *>(_platform_data)->ss_family = AF_INET;
}

SocketAddress::SocketAddress(const SocketAddress & src)
{
    _platform_data = reinterpret_cast<void *>(new sockaddr_storage);
    memcpy(_platform_data, src._platform_data, sizeof(sockaddr_storage));
}



SocketAddress::SocketAddress(const char * addrString, int port, SocketAddress::address_type_t type)
{
    _checkWSAStartup();
    _platform_data = reinterpret_cast<void *>(new sockaddr_storage);
    memset(_platform_data, 0, sizeof(sockaddr_storage));
    
    // default to ipv4 in case the following operation fails
    reinterpret_cast<sockaddr_storage *>(_platform_data)->ss_family = AF_INET;

    setAddressFromString(addrString, type);
    setPort(port);
}

SocketAddress::SocketAddress(void * platform_data)
 : _platform_data(platform_data)
{ _checkWSAStartup(); }

SocketAddress & SocketAddress::operator = (const SocketAddress &src)
{
    memcpy(_platform_data, src._platform_data, sizeof(sockaddr_storage));
    return *this;
}


SocketAddress::~SocketAddress()
{
    delete reinterpret_cast<sockaddr_storage *>(_platform_data);
}

SocketAddress::address_type_t SocketAddress::getAddressType() const
{
    switch(reinterpret_cast<const sockaddr_storage *>(_platform_data)->ss_family) {
        case AF_INET:
            return ADDRESS_TYPE_INET;
        case AF_INET6:
            return ADDRESS_TYPE_INET6;
        default:
            assert(!"should not reach here");
            return ADDRESS_TYPE_INET;
    }
}

int SocketAddress::getPort() const
{
    switch (getAddressType()) {
        case ADDRESS_TYPE_INET:
            return (int)ntohs(reinterpret_cast<const sockaddr_in *>(_platform_data)->sin_port);
        case ADDRESS_TYPE_INET6:
            return (int)ntohs(reinterpret_cast<const sockaddr_in6 *>(_platform_data)->sin6_port);
        default:
            return 0;
    }
}

u_result SocketAddress::setPort(int port)
{
    switch (getAddressType()) {
        case ADDRESS_TYPE_INET:
            reinterpret_cast<sockaddr_in *>(_platform_data)->sin_port = htons((short)port);
            break;
        case ADDRESS_TYPE_INET6:
            reinterpret_cast<sockaddr_in6 *>(_platform_data)->sin6_port = htons((short)port);
            break;
        default:
            return RESULT_OPERATION_FAIL;
    }
    return RESULT_OK;
}

u_result SocketAddress::setAddressFromString(const char * address_string,  SocketAddress::address_type_t type)
{
    int ans = 0;
    int prevPort = getPort();
    switch (type) {
        case ADDRESS_TYPE_INET:
            reinterpret_cast<sockaddr_storage *>(_platform_data)->ss_family = AF_INET;
            ans = _inet_pton(AF_INET, 
                            address_string, 
                            &reinterpret_cast<sockaddr_in *>(_platform_data)->sin_addr);
        break;


        case ADDRESS_TYPE_INET6:
            
            reinterpret_cast<sockaddr_storage *>(_platform_data)->ss_family = AF_INET6;
            ans = _inet_pton(AF_INET6, 
                            address_string, 
                            &reinterpret_cast<sockaddr_in6  *>(_platform_data)->sin6_addr);
        break;

        default:
            return RESULT_INVALID_DATA;

    }
    setPort(prevPort);

    return ans<=0?RESULT_INVALID_DATA:RESULT_OK;
}


u_result SocketAddress::getAddressAsString(char * buffer, size_t buffersize) const
{
    int net_family = reinterpret_cast<const sockaddr_storage *>(_platform_data)->ss_family;
    const char *ans = NULL;
    switch (net_family) {
        case AF_INET:
            ans = _inet_ntop(net_family, &reinterpret_cast<const sockaddr_in *>(_platform_data)->sin_addr,
                            buffer, (int)buffersize);
        break;

        case AF_INET6:
            ans = _inet_ntop(net_family, &reinterpret_cast<const sockaddr_in6 *>(_platform_data)->sin6_addr,
                            buffer, (int)buffersize);

        break;
    }
    return (ans==NULL)?RESULT_OPERATION_FAIL:RESULT_OK;
}



size_t SocketAddress::LoopUpHostName(const char * hostname, const char * sevicename, std::vector<SocketAddress> &addresspool , bool performDNS, SocketAddress::address_type_t type)
{
    struct addrinfo hints;
    struct addrinfo *result;
    int ans;
    _checkWSAStartup();
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = _halAddrTypeToOSType(type);
    hints.ai_flags = AI_PASSIVE;

    if (!performDNS) {
        hints.ai_family |= AI_NUMERICSERV | AI_NUMERICHOST;
    
    }

    ans = getaddrinfo(hostname, sevicename, &hints, &result);

    addresspool.clear();

    if (ans != 0) {
        // hostname loopup failed
        return 0;
    }

    
    for (struct addrinfo * cursor = result; cursor != NULL; cursor = cursor->ai_next) {
        if (cursor->ai_family == ADDRESS_TYPE_INET || cursor->ai_family == ADDRESS_TYPE_INET6) {
            sockaddr_storage * storagebuffer = new sockaddr_storage;
            assert(sizeof(sockaddr_storage) >= cursor->ai_addrlen);
            memcpy(storagebuffer, cursor->ai_addr, cursor->ai_addrlen);
            addresspool.push_back(SocketAddress(storagebuffer));
        }
    }

    
    freeaddrinfo(result);

    return addresspool.size();
}


u_result SocketAddress::getRawAddress(_u8 * buffer, size_t bufferSize) const
{
     switch (getAddressType()) {
        case ADDRESS_TYPE_INET:
            if (bufferSize < sizeof(reinterpret_cast<const sockaddr_in *>(_platform_data)->sin_addr.s_addr)) return RESULT_INSUFFICIENT_MEMORY;

            memcpy(buffer, &reinterpret_cast<const sockaddr_in *>(_platform_data)->sin_addr.s_addr, sizeof(reinterpret_cast<const sockaddr_in *>(_platform_data)->sin_addr.s_addr));

            
            break;
        case ADDRESS_TYPE_INET6:
            if (bufferSize < sizeof(reinterpret_cast<const sockaddr_in6 *>(_platform_data)->sin6_addr.s6_addr)) return RESULT_INSUFFICIENT_MEMORY;
            memcpy(buffer, reinterpret_cast<const sockaddr_in6 *>(_platform_data)->sin6_addr.s6_addr, sizeof(reinterpret_cast<const sockaddr_in6 *>(_platform_data)->sin6_addr.s6_addr));

            break;
        default:
            return RESULT_OPERATION_FAIL;
    }
    return RESULT_OK;
}


void SocketAddress::setLoopbackAddress(SocketAddress::address_type_t type)
{

    int prevPort = getPort();
    switch (type) {
        case ADDRESS_TYPE_INET:
            {
                sockaddr_in * addrv4 = reinterpret_cast<sockaddr_in *>(_platform_data);
                addrv4->sin_family = AF_INET;
                addrv4->sin_addr.s_addr = htonl(INADDR_LOOPBACK);
            }
            break;
        case ADDRESS_TYPE_INET6:
            {
                sockaddr_in6  * addrv6 = reinterpret_cast<sockaddr_in6  *>(_platform_data);
                addrv6->sin6_family = AF_INET6;
                addrv6->sin6_addr = in6addr_loopback;

            }
            break;
        default:
            return;
    }

    setPort(prevPort);
}

void SocketAddress::setBroadcastAddressIPv4()
{

    int prevPort = getPort();
    sockaddr_in * addrv4 = reinterpret_cast<sockaddr_in *>(_platform_data);
    addrv4->sin_family = AF_INET;
    addrv4->sin_addr.s_addr = htonl(INADDR_BROADCAST);
    setPort(prevPort);

}

void SocketAddress::setAnyAddress(SocketAddress::address_type_t type)
{
    int prevPort = getPort();
    switch (type) {
        case ADDRESS_TYPE_INET:
            {
                sockaddr_in * addrv4 = reinterpret_cast<sockaddr_in *>(_platform_data);
                addrv4->sin_family = AF_INET;
                addrv4->sin_addr.s_addr = htonl(INADDR_ANY);
            }
            break;
        case ADDRESS_TYPE_INET6:
            {
                sockaddr_in6  * addrv6 = reinterpret_cast<sockaddr_in6  *>(_platform_data);
                addrv6->sin6_family = AF_INET6;
                addrv6->sin6_addr = in6addr_any;

            }
            break;
        default:
            return;
    }

    setPort(prevPort);


}


}}



///--------------------------------


namespace rp { namespace arch { namespace net{ 

using namespace rp::net;

class _single_thread StreamSocketImpl : public StreamSocket
{
public:

    StreamSocketImpl(SOCKET fd)
        : _socket_fd(fd)
    {
        assert(fd>=0);
        int bool_true = 1;
        ::setsockopt( _socket_fd, SOL_SOCKET, SO_REUSEADDR , (char *)&bool_true, (int)sizeof(bool_true) );
        
        enableNoDelay(true);
        this->setTimeout(DEFAULT_SOCKET_TIMEOUT, SOCKET_DIR_BOTH);
    }

    virtual ~StreamSocketImpl() 
    {
        closesocket(_socket_fd);
    }

    virtual void dispose()
    {
        delete this;
    }


    virtual u_result bind(const SocketAddress & localaddr)
    {
        const struct sockaddr * addr = reinterpret_cast<const struct sockaddr *>(localaddr.getPlatformData());
        assert(addr);
        int ans = ::bind(_socket_fd, addr, (int)sizeof(sockaddr_storage));
        if (ans) {
            return RESULT_OPERATION_FAIL;
        } else {
            return RESULT_OK;
        }
    }

    virtual u_result getLocalAddress(SocketAddress & localaddr)
    {
        struct sockaddr * addr = reinterpret_cast<struct sockaddr *>( const_cast<void *>(localaddr.getPlatformData())); //donnot do this at home...
        assert(addr);

        int actualsize =  sizeof(sockaddr_storage);
        int ans = ::getsockname(_socket_fd, addr, &actualsize);

        assert(actualsize <= sizeof(sockaddr_storage));
        assert(addr->sa_family == AF_INET || addr->sa_family == AF_INET6);

        return ans?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result setTimeout(_u32 timeout, socket_direction_mask msk)
    {
        int ans;
        timeval tv;
        tv.tv_sec = timeout / 1000; 
        tv.tv_usec = (timeout % 1000) * 1000; 

        if (msk & SOCKET_DIR_RD) {
             ans = ::setsockopt( _socket_fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, (int)sizeof(tv) );
             if (ans) return RESULT_OPERATION_FAIL;
        }

        if (msk & SOCKET_DIR_WR) {
             ans = ::setsockopt( _socket_fd, SOL_SOCKET, SO_SNDTIMEO, (char *)&tv, (int)sizeof(tv) );
             if (ans) return RESULT_OPERATION_FAIL;
        }

        return RESULT_OK;
    }
  
    virtual u_result connect(const SocketAddress & pairAddress)
    {
        u_long mode_block = 0;
        u_long mode_notBlock = 1;
        
        //set to non block mode
        if (SOCKET_ERROR == ioctlsocket(_socket_fd, (long)FIONBIO, &mode_notBlock))
        {
            return RESULT_OPERATION_FAIL;
        }

        struct timeval tm;  
        tm.tv_sec  = 2;  
        tm.tv_usec = 0;  
        int ret = -1;  

        const struct sockaddr * addr = reinterpret_cast<const struct sockaddr *>(pairAddress.getPlatformData());
        int ans = ::connect(_socket_fd, addr, (int)sizeof(sockaddr_storage));
        if (!ans) return RESULT_OK;

        fd_set set;  
        FD_ZERO(&set);  
        FD_SET(_socket_fd, &set);

        if (select(-1, NULL, &set, NULL, &tm) <= 0)  
        {  
            ret = -1; // error(select error or timeout)  
            return RESULT_OPERATION_TIMEOUT;
        }  
        
        int error = -1;  
        int optLen = sizeof(int);  
        getsockopt(_socket_fd, SOL_SOCKET, SO_ERROR, (char*)&error, &optLen);   

        if (0 != error)  
        {  
            ret = -1; // error  
        }  
        else  
        {  
            ret = 1;  // correct  
        }  

        //set back to block mode
        if (SOCKET_ERROR == ioctlsocket(_socket_fd, (long)FIONBIO, &mode_block))
        {
            return RESULT_OPERATION_FAIL;
        }
        if(1 == ret)  
        {
            return RESULT_OK;
        }
        else
        {
            return RESULT_OPERATION_FAIL;
        }
    }
      
    virtual u_result listen(int backlog)
    {
        int ans = ::listen( _socket_fd,   backlog);

        return ans?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual StreamSocket * accept(SocketAddress * pairAddress) 
    {
        int addrsize;
        addrsize = sizeof(sockaddr_storage);
        SOCKET pair_socket = ::accept( _socket_fd, pairAddress?reinterpret_cast<struct sockaddr *>(const_cast<void *>(pairAddress->getPlatformData())):NULL
            , &addrsize);

        if (pair_socket>=0) {
            return new StreamSocketImpl(pair_socket);
        } else {
            return NULL;
        }
    }

    virtual u_result waitforIncomingConnection(_u32 timeout)
    {
        return waitforData(timeout);
    }

    virtual u_result send(const void * buffer, size_t len) 
    {
        int ans = ::send( _socket_fd, (const char *)buffer, (int)len, 0);
        if (ans != SOCKET_ERROR ) {
            assert(ans == (int)len);

            return RESULT_OK;
        } else {
            switch(WSAGetLastError()) {
            case WSAETIMEDOUT:
                return RESULT_OPERATION_TIMEOUT;
            default:
                return RESULT_OPERATION_FAIL;
            }
            
        }
        
    }

    virtual u_result recv(void *buf, size_t len, size_t & recv_len)
    {
        int ans = ::recv( _socket_fd, (char *)buf, (int)len, 0);
		//::setsockopt(_socket_fd, IPPROTO_TCP, TCP_QUICKACK,  (const char *)1, sizeof(int));
		//::setsockopt(_socket_fd, IPPROTO_TCP, TCP_QUICKACK, (int[]){1}, sizeof(int))
        if (ans == SOCKET_ERROR) {
            recv_len = 0;  
                switch(WSAGetLastError()) {
                case WSAETIMEDOUT:
                    return RESULT_OPERATION_TIMEOUT;
                default:
                    return RESULT_OPERATION_FAIL;
                }
        } else {
            recv_len = ans;
            return RESULT_OK;
        }
    }

    virtual u_result getPeerAddress(SocketAddress & peerAddr)
    {
        struct sockaddr * addr = reinterpret_cast<struct sockaddr *>(const_cast<void *>(peerAddr.getPlatformData())); //donnot do this at home...
        assert(addr);
        int actualsize =  (int)sizeof(sockaddr_storage);
        int ans = ::getpeername(_socket_fd, addr, &actualsize);

        assert(actualsize <=  (int)sizeof(sockaddr_storage));
        assert(addr->sa_family == AF_INET || addr->sa_family == AF_INET6);

        return ans?RESULT_OPERATION_FAIL:RESULT_OK;

    }

    virtual u_result shutdown(socket_direction_mask mask)
    {
        int shutdw_opt ;

        switch (mask) {
            case SOCKET_DIR_RD:
                shutdw_opt = SD_RECEIVE;
                break;
            case SOCKET_DIR_WR:
                shutdw_opt = SD_SEND;
                break;
            case SOCKET_DIR_BOTH:
            default:
                shutdw_opt = SD_BOTH;
        }

        int ans = ::shutdown(_socket_fd, shutdw_opt);
        return ans?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result enableKeepAlive(bool enable)
    {
        int bool_true = enable?1:0;
        return ::setsockopt( _socket_fd, SOL_SOCKET, SO_KEEPALIVE , (const char *)&bool_true, (int)sizeof(bool_true) )?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result enableNoDelay(bool enable ) 
    {
        int bool_true = enable?1:0;
        return ::setsockopt( _socket_fd, IPPROTO_TCP, TCP_NODELAY, (const char *)&bool_true, (int)sizeof(bool_true) )?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result waitforSent(_u32 timeout ) 
    {
        fd_set wrset;
        FD_ZERO(&wrset);
        FD_SET(_socket_fd, &wrset);

        timeval tv;
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = (timeout % 1000) * 1000;
        int ans = ::select(NULL, NULL, &wrset, NULL, &tv);

        switch (ans) {
            case 1:
                // fired
                return RESULT_OK;
            case 0:
                // timeout
                return RESULT_OPERATION_TIMEOUT;
            default:
                delay(0); //relax cpu
                return RESULT_OPERATION_FAIL;
        }
    }

    virtual u_result waitforData(_u32 timeout )
    {
        fd_set rdset;
        FD_ZERO(&rdset);
        FD_SET(_socket_fd, &rdset);

        timeval tv;
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = (timeout % 1000) * 1000;
        int ans = ::select((int)_socket_fd+1, &rdset, NULL, NULL, &tv);

        switch (ans) {
            case 1:
                // fired
                return RESULT_OK;
            case 0:
                // timeout
                return RESULT_OPERATION_TIMEOUT;
            default:
                delay(0); //relax cpu
                return RESULT_OPERATION_FAIL;
        }
    }

protected:

    SOCKET  _socket_fd;


};


class _single_thread DGramSocketImpl : public DGramSocket
{
public:

    DGramSocketImpl(SOCKET fd)
        : _socket_fd(fd)
    {
        assert(fd>=0);
        int bool_true = 1;
        ::setsockopt( _socket_fd, SOL_SOCKET, SO_REUSEADDR | SO_BROADCAST , (char *)&bool_true, (int)sizeof(bool_true) );
        setTimeout(DEFAULT_SOCKET_TIMEOUT, SOCKET_DIR_BOTH);
    }

    virtual ~DGramSocketImpl() 
    {
        closesocket(_socket_fd);
    }

    virtual void dispose()
    {
        delete this;
    }


    virtual u_result bind(const SocketAddress & localaddr)
    {
        const struct sockaddr * addr = reinterpret_cast<const struct sockaddr *>(localaddr.getPlatformData());
        assert(addr);
        int ans = ::bind(_socket_fd, addr, (int)sizeof(sockaddr_storage));
        if (ans) {
            return RESULT_OPERATION_FAIL;
        } else {
            return RESULT_OK;
        }
    }

    virtual u_result getLocalAddress(SocketAddress & localaddr)
    {
        struct sockaddr * addr = reinterpret_cast<struct sockaddr *>(const_cast<void *>((localaddr.getPlatformData()))); //donnot do this at home...
        assert(addr);

        int actualsize =  (int)sizeof(sockaddr_storage);
        int ans = ::getsockname(_socket_fd, addr, &actualsize);

        assert(actualsize <= (int)sizeof(sockaddr_storage));
        assert(addr->sa_family == AF_INET || addr->sa_family == AF_INET6);

        return ans?RESULT_OPERATION_FAIL:RESULT_OK;
    }

    virtual u_result setTimeout(_u32 timeout, socket_direction_mask msk)
    {
        int ans;
        timeval tv;
        tv.tv_sec = timeout / 1000; 
        tv.tv_usec = (timeout % 1000) * 1000; 

        if (msk & SOCKET_DIR_RD) {
             ans = ::setsockopt( _socket_fd, SOL_SOCKET, SO_RCVTIMEO, (const char *)&tv, (int)sizeof(tv) );
             if (ans) return RESULT_OPERATION_FAIL;
        }

        if (msk & SOCKET_DIR_WR) {
             ans = ::setsockopt( _socket_fd, SOL_SOCKET, SO_SNDTIMEO, (const char *)&tv, (int)sizeof(tv) );
             if (ans) return RESULT_OPERATION_FAIL;
        }

        return RESULT_OK;
    }
  

    virtual u_result waitforSent(_u32 timeout ) 
    {
        fd_set wrset;
        FD_ZERO(&wrset);
        FD_SET(_socket_fd, &wrset);

        timeval tv;
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = (timeout % 1000) * 1000;
        int ans = ::select(NULL, NULL, &wrset, NULL, &tv);

        switch (ans) {
            case 1:
                // fired
                return RESULT_OK;
            case 0:
                // timeout
                return RESULT_OPERATION_TIMEOUT;
            default:
                delay(0); //relax cpu
                return RESULT_OPERATION_FAIL;
        }
    }

    virtual u_result waitforData(_u32 timeout )
    {
        fd_set rdset;
        FD_ZERO(&rdset);
        FD_SET(_socket_fd, &rdset);

        timeval tv;
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = (timeout % 1000) * 1000;
        int ans = ::select(NULL, &rdset, NULL, NULL, &tv);

        switch (ans) {
            case 1:
                // fired
                return RESULT_OK;
            case 0:
                // timeout
                return RESULT_OPERATION_TIMEOUT;
            default:
                delay(0); //relax cpu
                return RESULT_OPERATION_FAIL;
        }
    }

    virtual u_result setPairAddress(const SocketAddress * pairAddress)
    {
        sockaddr_storage unspecAddr;
        unspecAddr.ss_family = AF_UNSPEC;

        const struct sockaddr * addr = pairAddress ? reinterpret_cast<const struct sockaddr *>(pairAddress->getPlatformData()) : reinterpret_cast<const struct sockaddr *>(&unspecAddr);
        int ans = ::connect(_socket_fd, addr, (int)sizeof(sockaddr_storage));
        return ans? RESULT_OPERATION_FAIL: RESULT_OK;

    }

    virtual u_result sendTo(const SocketAddress * target, const void * buffer, size_t len)
    {

        const struct sockaddr * addr = target?reinterpret_cast<const struct sockaddr *>(target->getPlatformData()): NULL;
        int dest_addr_size = (target ? sizeof(sockaddr_storage) : 0);
        int ans = ::sendto( _socket_fd, (const char *)buffer, (int)len, 0, addr, dest_addr_size);
        if (ans != SOCKET_ERROR) {
            assert(ans == (int)len);
            return RESULT_OK;
        } else {
           switch(WSAGetLastError()) {
            case WSAETIMEDOUT:
                return RESULT_OPERATION_TIMEOUT;
            case WSAEMSGSIZE:
                return RESULT_INVALID_DATA;
            default:
                return RESULT_OPERATION_FAIL;
            }
        }

    }

    virtual u_result clearRxCache()
    {
        timeval tv;
        tv.tv_sec = 0;
        tv.tv_usec = 0;
        fd_set rdset;
        FD_ZERO(&rdset);
        FD_SET(_socket_fd, &rdset);

        int res = -1;
        char recv_data[2];
        memset(recv_data, 0, sizeof(recv_data));
        while (true) {
            res = select(FD_SETSIZE, &rdset, nullptr, nullptr, &tv);
            if (res == 0) break;
            recv(_socket_fd, recv_data, 1, 0);
        }
        return RESULT_OK;
    }


    virtual u_result recvFrom(void *buf, size_t len, size_t & recv_len, SocketAddress * sourceAddr)
    {
        struct sockaddr * addr = (sourceAddr?reinterpret_cast<struct sockaddr *>(const_cast<void *>(sourceAddr->getPlatformData())):NULL);
        int source_addr_size = (sourceAddr?sizeof(sockaddr_storage):0);

        int ans = ::recvfrom( _socket_fd, (char *)buf, (int)len, 0, addr, addr?&source_addr_size:NULL);
        if (ans == SOCKET_ERROR) {
            recv_len = 0;  
            int errCode = WSAGetLastError();
           switch(errCode) {
            case WSAETIMEDOUT:
                return RESULT_OPERATION_TIMEOUT;
            default:
                return RESULT_OPERATION_FAIL;
            }
        } else {
            recv_len = ans;
            return RESULT_OK;
        }

    }


    
protected:
    SOCKET  _socket_fd;

};


}}}


namespace rp { namespace net{ 



static inline int _socketHalFamilyToOSFamily(SocketBase::socket_family_t family)
{
    switch (family) {
        case SocketBase::SOCKET_FAMILY_INET:
            return AF_INET;
        case SocketBase::SOCKET_FAMILY_INET6:
            return AF_INET6;
        case SocketBase::SOCKET_FAMILY_RAW:
            return AF_UNSPEC; //win32 doesn't support RAW Packet
        default:
            assert(!"should not reach here");
            return AF_INET; // force treating as IPv4 in release mode
    }

}

StreamSocket * StreamSocket::CreateSocket(SocketBase::socket_family_t family)
{
    _checkWSAStartup();
    if (family == SOCKET_FAMILY_RAW) return NULL;


    int socket_family = _socketHalFamilyToOSFamily(family);
    SOCKET socket_fd = ::socket(socket_family, SOCK_STREAM, 0);
    if (socket_fd == -1) return NULL;
    StreamSocket * newborn = static_cast<StreamSocket *>(new rp::arch::net::StreamSocketImpl(socket_fd));
    return newborn;

}


DGramSocket * DGramSocket::CreateSocket(SocketBase::socket_family_t family)
{
    _checkWSAStartup();
    int socket_family = _socketHalFamilyToOSFamily(family);


    SOCKET socket_fd = ::socket(socket_family, (family == SOCKET_FAMILY_RAW) ? SOCK_RAW : SOCK_DGRAM, 0);
    if (socket_fd == -1) return NULL;
    DGramSocket * newborn = static_cast<DGramSocket *>(new rp::arch::net::DGramSocketImpl(socket_fd));
    return newborn;

}


}}




================================================
File: src/rplidar_ros/sdk/src/arch/win32/timer.cpp
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "sdkcommon.h"
#include <mmsystem.h>
#pragma comment(lib, "Winmm.lib")

namespace rp{ namespace arch{

static LARGE_INTEGER _current_freq;

void HPtimer_reset()
{
    BOOL ans=QueryPerformanceFrequency(&_current_freq);
    _current_freq.QuadPart/=1000ULL;
    assert(ans);
}

_u64 getHDTimer_us()
{
    LARGE_INTEGER current;
    QueryPerformanceCounter(&current);

    return (_u64)(current.QuadPart / (_current_freq.QuadPart/1000ULL));

}

_u64 getHDTimer()
{
    LARGE_INTEGER current;
    QueryPerformanceCounter(&current);

    return (_u64)(current.QuadPart/_current_freq.QuadPart);
}

BEGIN_STATIC_CODE(timer_cailb)
{
    HPtimer_reset();
}END_STATIC_CODE(timer_cailb)

}}



================================================
File: src/rplidar_ros/sdk/src/arch/win32/timer.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

#include "hal/types.h"

#define delay(x)   ::Sleep(x)

namespace rp{ namespace arch{
    void HPtimer_reset();
    _u64 getHDTimer();
    _u64 getHDTimer_us();

}}

#define getms()   rp::arch::getHDTimer()
#define getus()   rp::arch::getHDTimer_us()



================================================
File: src/rplidar_ros/sdk/src/arch/win32/winthread.hpp
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "sdkcommon.h"
#include <process.h>

namespace rp{ namespace hal{

Thread Thread::create(thread_proc_t proc, void * data)
{
    Thread newborn(proc, data);

    newborn._handle = (_word_size_t)( 
        _beginthreadex(NULL, 0, (unsigned int (_stdcall * )( void * ))proc,
                        data, 0, NULL));
    return newborn;
}

u_result Thread::terminate()
{
    if (!this->_handle) return RESULT_OK;
    if (TerminateThread( reinterpret_cast<HANDLE>(this->_handle), -1))
    {
        CloseHandle(reinterpret_cast<HANDLE>(this->_handle));
        this->_handle = NULL;
        return RESULT_OK;
    }else
    {
        return RESULT_OPERATION_FAIL;
    }
}

u_result Thread::SetSelfPriority( priority_val_t p)
{
    HANDLE selfHandle = GetCurrentThread();
	
	int win_priority =  THREAD_PRIORITY_NORMAL;
	switch(p)
	{
	case PRIORITY_REALTIME:
		win_priority = THREAD_PRIORITY_TIME_CRITICAL;
		break;
	case PRIORITY_HIGH:
		win_priority = THREAD_PRIORITY_HIGHEST;
		break;
	case PRIORITY_NORMAL:
		win_priority = THREAD_PRIORITY_NORMAL;
		break;
	case PRIORITY_LOW:
		win_priority = THREAD_PRIORITY_LOWEST;
		break;
	case PRIORITY_IDLE:
		win_priority = THREAD_PRIORITY_IDLE;
		break;
	}

	if (SetThreadPriority(selfHandle, win_priority))
	{
		return RESULT_OK;
	}
	return RESULT_OPERATION_FAIL;
}

Thread::priority_val_t Thread::getPriority()
{
	if (!this->_handle) return PRIORITY_NORMAL;
	int win_priority =  ::GetThreadPriority(reinterpret_cast<HANDLE>(this->_handle));
	
	if (win_priority == THREAD_PRIORITY_ERROR_RETURN)
	{
		return PRIORITY_NORMAL;
	}

	if (win_priority >= THREAD_PRIORITY_TIME_CRITICAL )
	{
		return PRIORITY_REALTIME;
	}
	else if (win_priority<THREAD_PRIORITY_TIME_CRITICAL && win_priority>=THREAD_PRIORITY_ABOVE_NORMAL)
	{	
		return PRIORITY_HIGH;
	}
	else if (win_priority<THREAD_PRIORITY_ABOVE_NORMAL && win_priority>THREAD_PRIORITY_BELOW_NORMAL)
	{
		return PRIORITY_NORMAL;
	}else if (win_priority<=THREAD_PRIORITY_BELOW_NORMAL && win_priority>THREAD_PRIORITY_IDLE)
	{
		return PRIORITY_LOW;
	}else if (win_priority<=THREAD_PRIORITY_IDLE)
	{
		return PRIORITY_IDLE;
	}
	return PRIORITY_NORMAL;
}

u_result Thread::join(unsigned long timeout)
{
    if (!this->_handle) return RESULT_OK;
    switch ( WaitForSingleObject(reinterpret_cast<HANDLE>(this->_handle), timeout))
    {
    case WAIT_OBJECT_0:
        CloseHandle(reinterpret_cast<HANDLE>(this->_handle));
        this->_handle = NULL;
        return RESULT_OK;
    case WAIT_ABANDONED:
        return RESULT_OPERATION_FAIL;
    case WAIT_TIMEOUT:
        return RESULT_OPERATION_TIMEOUT;
    }

    return RESULT_OK;
}

}}



================================================
File: src/rplidar_ros/sdk/src/dataunpacker/dataunnpacker_commondef.h
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */

 /*
  *  Sample Data Unpacker System
  *  External Reference and dependencies
  */

  /*
	* Redistribution and use in source and binary forms, with or without
	* modification, are permitted provided that the following conditions are met:
	*
	* 1. Redistributions of source code must retain the above copyright notice,
	*    this list of conditions and the following disclaimer.
	*
	* 2. Redistributions in binary form must reproduce the above copyright notice,
	*    this list of conditions and the following disclaimer in the documentation
	*    and/or other materials provided with the distribution.
	*
	* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
	* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
	* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
	* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	*/

#pragma once

#include "sdkcommon.h"
#include "hal/abs_rxtx.h"
#include "hal/thread.h"
#include "hal/types.h"
#include "hal/assert.h"
#include "hal/locker.h"
#include "hal/socket.h"
#include "hal/event.h"
#include "hal/waiter.h"
#include "hal/byteorder.h"
#include "sl_lidar_driver.h"
#include "sl_crc.h" 
#include <algorithm>
#include <memory>

#define CONF_NO_BOOST_CRC_SUPPORT

#include "dataupacker_namespace.h"





================================================
File: src/rplidar_ros/sdk/src/dataunpacker/dataunnpacker_internal.h
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */

 /*
  *  Sample Data Unpacker System
  *  Internal Definition
  */

  /*
	* Redistribution and use in source and binary forms, with or without
	* modification, are permitted provided that the following conditions are met:
	*
	* 1. Redistributions of source code must retain the above copyright notice,
	*    this list of conditions and the following disclaimer.
	*
	* 2. Redistributions in binary form must reproduce the above copyright notice,
	*    this list of conditions and the following disclaimer in the documentation
	*    and/or other materials provided with the distribution.
	*
	* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
	* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
	* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
	* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	*/

#pragma once

BEGIN_DATAUNPACKER_NS()


class LIDARSampleDataUnpackerInner: public LIDARSampleDataUnpacker
{
public:
	LIDARSampleDataUnpackerInner(LIDARSampleDataListener& l): LIDARSampleDataUnpacker(l){}

	virtual void publishHQNode(_u64 timestamp_uS, const rplidar_response_measurement_node_hq_t* node) = 0;
	virtual void publishDecodingErrorMsg(int errorType, _u8 ansType, const void* payload, size_t size) = 0;
	virtual void publishCustomData(_u8 ansType, _u32 customCode, const void* payload, size_t size) = 0;
	virtual void publishNewScanReset() = 0;


	virtual _u64 getCurrentTimestamp_uS() = 0;

};

class IDataUnpackerHandler
{
public:
	IDataUnpackerHandler() {}
	virtual ~IDataUnpackerHandler() {}


	virtual void onUnpackerContextSet(LIDARSampleDataUnpacker::UnpackerContextType type, const void* data, size_t size) = 0;

	virtual _u8 getSampleAnswerType() const = 0;
	virtual void onData(LIDARSampleDataUnpackerInner* engine, const _u8* data, size_t size) = 0;
	virtual void reset() = 0;

};

END_DATAUNPACKER_NS()


================================================
File: src/rplidar_ros/sdk/src/dataunpacker/dataunpacker.cpp
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */

 /*
  *  Sample Data Unpacker System
  *
  */

  /*
	* Redistribution and use in source and binary forms, with or without
	* modification, are permitted provided that the following conditions are met:
	*
	* 1. Redistributions of source code must retain the above copyright notice,
	*    this list of conditions and the following disclaimer.
	*
	* 2. Redistributions in binary form must reproduce the above copyright notice,
	*    this list of conditions and the following disclaimer in the documentation
	*    and/or other materials provided with the distribution.
	*
	* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
	* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
	* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
	* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	*/

#include "dataunnpacker_commondef.h"
#include "dataunpacker.h"
#include "dataunnpacker_internal.h"


#include <map>


#define REGISTER_HANDLER(_c_) {     \
		auto newBorn = new unpacker::_c_();   \
		if (!newBorn) return false; \
		handlerList.push_back(newBorn); \
	} 

// How to include new handlers?
// 1. add extra include line below if a new handle is to be included
// 2. update the code in function _registerDataUnpackerHandlers
#include "unpacker/handler_capsules.h"
#include "unpacker/handler_hqnode.h"
#include "unpacker/handler_normalnode.h"


#define  DEF_REGISTER_HANDLER_LIST


BEGIN_DATAUNPACKER_NS()


static bool _registerDataUnpackerHandlers(std::vector<IDataUnpackerHandler *> & handlerList)
{
	REGISTER_HANDLER(UnpackerHandler_NormalNode);
	REGISTER_HANDLER(UnpackerHandler_HQNode);
	REGISTER_HANDLER(UnpackerHandler_CapsuleNode);
	REGISTER_HANDLER(UnpackerHandler_UltraCapsuleNode);
	REGISTER_HANDLER(UnpackerHandler_DenseCapsuleNode);
	REGISTER_HANDLER(UnpackerHandler_UltraDenseCapsuleNode);
	return true;
}


class LIDARSampleDataUnpackerImpl : public LIDARSampleDataUnpackerInner
{
public:

	void registerHandler(_u8 ansType, IDataUnpackerHandler* handler)
	{
		_handlerMap[ansType] = handler;
	}


	void unregisterAllHandlers()
	{
		for (auto itr = _handlerMap.begin(); itr != _handlerMap.end(); ++itr)
		{
			delete itr->second;
		}
		_handlerMap.clear();
	}

	LIDARSampleDataUnpackerImpl(LIDARSampleDataListener& l)
		: LIDARSampleDataUnpackerInner(l)
		, _enabled(false)
		, _lastActiveAnsType(0)
		, _lastActiveHandler(nullptr)
	{

	}

	virtual ~LIDARSampleDataUnpackerImpl()
	{
		unregisterAllHandlers();
	}


	virtual void updateUnpackerContext(UnpackerContextType type, const void* data, size_t size)
	{
	
		// notify the handlers ...
		for (auto itr = _handlerMap.begin(); itr != _handlerMap.end(); ++itr)
		{
			itr->second->onUnpackerContextSet(type, data, size);
		}
	}

	virtual bool onSampleData(_u8 ansType, const void* buffer, size_t size) {
		if (!_enabled) return false;


		if (_lastActiveAnsType != ansType) {
			onDeselectHandler();

			auto itr = _handlerMap.find(ansType);
			if (itr != _handlerMap.end()) {
				onSelectHandler(ansType, itr->second);
			}
			else {
				onSelectHandler(ansType, nullptr);
			}
			
		}

		if (_lastActiveHandler) {
			_lastActiveHandler->onData(this, reinterpret_cast<const _u8 *>(buffer), size);
			return true;
		}
		else {
			return false;
		}
	}

	virtual void reset()
	{
		clearCache();
		_lastActiveHandler = nullptr;
		_lastActiveAnsType = 0;

	}

	virtual void enable()
	{
		_enabled = true;
		reset();
	}

	virtual void disable()
	{
		_enabled = false;
		reset();

	}

	virtual void clearCache()
	{
		if (_lastActiveHandler) {
			_lastActiveHandler->reset();
		}
	}

	virtual _u64 getCurrentTimestamp_uS() {
		return getus();
	}

	virtual void publishHQNode(_u64 timestamp_uS, const rplidar_response_measurement_node_hq_t* node)
	{
		_listener.onHQNodeDecoded(timestamp_uS, node);
	}


	virtual void publishDecodingErrorMsg(int errorType, _u8 ansType, const void* payload, size_t size)
	{
		_listener.onDecodingError(errorType, ansType, payload, size);

	}

	virtual void publishCustomData(_u8 ansType, _u32 customCode, const void* payload, size_t size)
	{
		_listener.onCustomSampleDataDecoded(ansType, customCode, payload, size);
	}


	virtual void publishNewScanReset()
	{
		_listener.onHQNodeScanResetReq();
	}
protected:

	void onSelectHandler(_u8 ansType, IDataUnpackerHandler* handler)
	{
		_lastActiveHandler = handler;
		_lastActiveAnsType = ansType;
	}

	void onDeselectHandler()
	{
		reset();
	}


protected:
	bool _enabled;
	std::map<_u8, IDataUnpackerHandler*> _handlerMap;

	_u8 _lastActiveAnsType;
	IDataUnpackerHandler* _lastActiveHandler;
};

LIDARSampleDataUnpacker* LIDARSampleDataUnpacker::CreateInstance(LIDARSampleDataListener& listener)
{
	LIDARSampleDataUnpackerImpl* impl = new LIDARSampleDataUnpackerImpl(listener);
	
	std::vector<IDataUnpackerHandler*> list;
	if (!_registerDataUnpackerHandlers(list)) {
		delete  impl;
		for (auto itr = list.begin(); itr != list.end(); ++itr) {
			delete* itr;
		}
		impl = nullptr;
	}

	for (auto itr = list.begin(); itr != list.end(); ++itr) {
		impl->registerHandler((*itr)->getSampleAnswerType(), (*itr));
	}
	return impl;
}

void LIDARSampleDataUnpacker::ReleaseInstance(LIDARSampleDataUnpacker* unpacker) {
	delete unpacker;
}

LIDARSampleDataUnpacker::~LIDARSampleDataUnpacker() {

}

LIDARSampleDataUnpacker::LIDARSampleDataUnpacker(LIDARSampleDataListener& l) 
	: _listener(l)
{

}


END_DATAUNPACKER_NS()


================================================
File: src/rplidar_ros/sdk/src/dataunpacker/dataunpacker.h
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */

 /*
  *  Sample Data Unpacker System
  *
  */

  /*
	* Redistribution and use in source and binary forms, with or without
	* modification, are permitted provided that the following conditions are met:
	*
	* 1. Redistributions of source code must retain the above copyright notice,
	*    this list of conditions and the following disclaimer.
	*
	* 2. Redistributions in binary form must reproduce the above copyright notice,
	*    this list of conditions and the following disclaimer in the documentation
	*    and/or other materials provided with the distribution.
	*
	* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
	* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
	* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
	* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	*/


#pragma once

#include "dataupacker_namespace.h"

BEGIN_DATAUNPACKER_NS()


class LIDARSampleDataListener
{


public:
	virtual void onHQNodeScanResetReq() = 0;
	virtual void onHQNodeDecoded(_u64 timestamp_uS, const rplidar_response_measurement_node_hq_t* node) = 0;
	virtual void onCustomSampleDataDecoded(_u8 ansType, _u32 customCode, const void* data, size_t size) {}

	virtual void onDecodingError(int errMsg, _u8 ansType, const void* payload, size_t size) {}
};

class LIDARSampleDataUnpacker
{
public:
	enum {
		ERR_EVENT_ON_EXP_ENCODER_RESET = 0x8001,
		ERR_EVENT_ON_EXP_CHECKSUM_ERR = 0x8002,
	};

	enum UnpackerContextType {
		UNPACKER_CONTEXT_TYPE_LIDAR_UNKNOWN = 0,
		UNPACKER_CONTEXT_TYPE_LIDAR_TIMING = 1,
		UNPACKER_CONTEXT_TYPE_TRIANGULATION_OPTICAL_FACTOR = 2,

	};

	virtual ~LIDARSampleDataUnpacker();
	static LIDARSampleDataUnpacker* CreateInstance(LIDARSampleDataListener& listener);
	static void ReleaseInstance(LIDARSampleDataUnpacker*);

	virtual void updateUnpackerContext(UnpackerContextType type, const void* data, size_t size) = 0;

	virtual void enable() = 0;
	virtual void disable() = 0;

	virtual bool onSampleData(_u8 ansType, const void* buffer, size_t size) = 0;
	virtual void reset() = 0;
	virtual void clearCache() = 0;

protected:
	LIDARSampleDataUnpacker(LIDARSampleDataListener&);
	LIDARSampleDataListener& _listener;

};

END_DATAUNPACKER_NS()


================================================
File: src/rplidar_ros/sdk/src/dataunpacker/dataupacker_namespace.h
================================================
#pragma once


#define BEGIN_DATAUNPACKER_NS()  namespace sl{ namespace internal{
#define END_DATAUNPACKER_NS()  }}


================================================
File: src/rplidar_ros/sdk/src/dataunpacker/unpacker/handler_capsules.cpp
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */

 /*
  *  Sample Data Unpacker System
  *  Capsule Style Sample Node Handlers
  */

  /*
	* Redistribution and use in source and binary forms, with or without
	* modification, are permitted provided that the following conditions are met:
	*
	* 1. Redistributions of source code must retain the above copyright notice,
	*    this list of conditions and the following disclaimer.
	*
	* 2. Redistributions in binary form must reproduce the above copyright notice,
	*    this list of conditions and the following disclaimer in the documentation
	*    and/or other materials provided with the distribution.
	*
	* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
	* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
	* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
	* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	*/

#include "../dataunnpacker_commondef.h"
#include "../dataunpacker.h"
#include "../dataunnpacker_internal.h"



#include "handler_capsules.h"

BEGIN_DATAUNPACKER_NS()
	
namespace unpacker{


// UnpackerHandler_CapsuleNode
///////////////////////////////////////////////////////////////////////////////////

static _u64 _getSampleDelayOffsetInExpressMode(const SlamtecLidarTimingDesc& timing, int sampleIdx)
{
    // FIXME: to eval
    // 
    // guess channel baudrate by LIDAR model ....
    const _u64 channelBaudRate = timing.native_baudrate? timing.native_baudrate:115200;

    _u64 tranmissionDelay = 1000000ULL * sizeof(rplidar_response_capsule_measurement_nodes_t) * 10 / channelBaudRate;

    if (timing.native_interface_type == LIDARInterfaceType::LIDAR_INTERFACE_ETHERNET)
    {
        tranmissionDelay = 100; //dummy value
    }

    // center of the sample duration
    const _u64 sampleDelay = (timing.sample_duration_uS >> 1);
    const _u64 sampleFilterDelay = timing.sample_duration_uS;
    const _u64 groupingDelay = (31 - sampleIdx) * timing.sample_duration_uS;


    return sampleFilterDelay + sampleDelay + tranmissionDelay + timing.linkage_delay_uS + groupingDelay;
}


UnpackerHandler_CapsuleNode::UnpackerHandler_CapsuleNode()
    : _cached_scan_node_buf_pos(0)
    , _is_previous_capsuledataRdy(false)
    , _cached_last_data_timestamp_us(0)
{
    _cached_scan_node_buf.resize(sizeof(rplidar_response_capsule_measurement_nodes_t));
    memset(&_cachedTimingDesc, 0, sizeof(_cachedTimingDesc));
}

UnpackerHandler_CapsuleNode::~UnpackerHandler_CapsuleNode()
{

}

void UnpackerHandler_CapsuleNode::onUnpackerContextSet(LIDARSampleDataUnpacker::UnpackerContextType type, const void* data, size_t size)
{
    if (type == LIDARSampleDataUnpacker::UNPACKER_CONTEXT_TYPE_LIDAR_TIMING) {
        assert(size == sizeof(_cachedTimingDesc));
        _cachedTimingDesc = *reinterpret_cast<const SlamtecLidarTimingDesc*>(data);
    }
}


_u8 UnpackerHandler_CapsuleNode::getSampleAnswerType() const
{
	return RPLIDAR_ANS_TYPE_MEASUREMENT_CAPSULED;
}

void UnpackerHandler_CapsuleNode::onData(LIDARSampleDataUnpackerInner* engine, const _u8* data, size_t cnt)
{
    for (size_t pos = 0; pos < cnt; ++pos) {
        _u8 current_data = data[pos];
        switch (_cached_scan_node_buf_pos) {
        case 0: // expect the sync bit 1
        {
            _u8 tmp = (current_data >> 4);
            if (tmp == RPLIDAR_RESP_MEASUREMENT_EXP_SYNC_1) {
                // pass
            }
            else {
                _is_previous_capsuledataRdy = false;
                continue;
            }

        }
        break;
        case 1: // expect the sync bit 2
        {
            _u8 tmp = (current_data >> 4);
            if (tmp == RPLIDAR_RESP_MEASUREMENT_EXP_SYNC_2) {
                // pass
            }
            else {
                _cached_scan_node_buf_pos = 0;
                _is_previous_capsuledataRdy = false;
                continue;
            }
        }
        break;

        case sizeof(rplidar_response_capsule_measurement_nodes_t) - 1: // new data ready
        {
            _cached_scan_node_buf[sizeof(rplidar_response_capsule_measurement_nodes_t) - 1] = current_data;
            _cached_scan_node_buf_pos = 0;

            rplidar_response_capsule_measurement_nodes_t* node = reinterpret_cast<rplidar_response_capsule_measurement_nodes_t*>(&_cached_scan_node_buf[0]);

            // calc the checksum ...
            _u8 checksum = 0;
            _u8 recvChecksum = ((node->s_checksum_1 & 0xF) | (node->s_checksum_2 << 4));
            for (size_t cpos = offsetof(rplidar_response_capsule_measurement_nodes_t, start_angle_sync_q6);
                cpos < sizeof(rplidar_response_capsule_measurement_nodes_t); ++cpos)
            {
                checksum ^= _cached_scan_node_buf[cpos];
            }

            if (recvChecksum == checksum)
            {
                // only consider vaild if the checksum matches...

                // perform data endianess convertion if necessary
#ifdef _CPU_ENDIAN_BIG
                node->start_angle_sync_q6 = le16_to_cpu(node->start_angle_sync_q6);
                for (size_t cpos = 0; cpos < _countof(node->cabins); ++cpos) {
                    node->cabins[cpos].distance_angle_1 = le16_to_cpu(node->cabins[cpos].distance_angle_1);
                    node->cabins[cpos].distance_angle_2 = le16_to_cpu(node->cabins[cpos].distance_angle_2);
                }
#endif
                if (node->start_angle_sync_q6 & RPLIDAR_RESP_MEASUREMENT_EXP_SYNCBIT)
                {
                    if (_is_previous_capsuledataRdy) {
                        engine->publishDecodingErrorMsg(LIDARSampleDataUnpacker::ERR_EVENT_ON_EXP_ENCODER_RESET
                            , RPLIDAR_ANS_TYPE_MEASUREMENT_CAPSULED, node, sizeof(*node));
                    }
                    // this is the first capsule frame in logic, discard the previous cached data...
                    _is_previous_capsuledataRdy = false;
                    engine->publishNewScanReset();


                }
                _onScanNodeCapsuleData(*node, engine);
            }
            else {
                _is_previous_capsuledataRdy = false;


                engine->publishDecodingErrorMsg(LIDARSampleDataUnpacker::ERR_EVENT_ON_EXP_CHECKSUM_ERR
                    , RPLIDAR_ANS_TYPE_MEASUREMENT_CAPSULED, node, sizeof(*node));

            }
            continue;
        }
        break;

        }
        _cached_scan_node_buf[_cached_scan_node_buf_pos++] = current_data;
    }

}

void UnpackerHandler_CapsuleNode::reset()
{
    _cached_scan_node_buf_pos = 0;
    _is_previous_capsuledataRdy = false;
    _cached_last_data_timestamp_us = 0;
}

void UnpackerHandler_CapsuleNode::_onScanNodeCapsuleData(rplidar_response_capsule_measurement_nodes_t& capsule, LIDARSampleDataUnpackerInner* engine)
{
    _u64 currentTS = engine->getCurrentTimestamp_uS();
    if (_is_previous_capsuledataRdy) {
        int diffAngle_q8;
        int currentStartAngle_q8 = ((capsule.start_angle_sync_q6 & 0x7FFF) << 2);
        int prevStartAngle_q8 = ((_cached_previous_capsuledata.start_angle_sync_q6 & 0x7FFF) << 2);

        diffAngle_q8 = (currentStartAngle_q8)-(prevStartAngle_q8);
        if (prevStartAngle_q8 > currentStartAngle_q8) {
            diffAngle_q8 += (360 << 8);
        }

        int angleInc_q16 = (diffAngle_q8 << 3);
        int currentAngle_raw_q16 = (prevStartAngle_q8 << 8);
        for (int pos = 0; pos < (int)_countof(_cached_previous_capsuledata.cabins); ++pos)
        {
            int dist_q2[2];
            int angle_q6[2];
            int syncBit[2];

            dist_q2[0] = (_cached_previous_capsuledata.cabins[pos].distance_angle_1 & 0xFFFC);
            dist_q2[1] = (_cached_previous_capsuledata.cabins[pos].distance_angle_2 & 0xFFFC);

            int angle_offset1_q3 = ((_cached_previous_capsuledata.cabins[pos].offset_angles_q3 & 0xF) | ((_cached_previous_capsuledata.cabins[pos].distance_angle_1 & 0x3) << 4));
            int angle_offset2_q3 = ((_cached_previous_capsuledata.cabins[pos].offset_angles_q3 >> 4) | ((_cached_previous_capsuledata.cabins[pos].distance_angle_2 & 0x3) << 4));

            angle_q6[0] = ((currentAngle_raw_q16 - (angle_offset1_q3 << 13)) >> 10);
            syncBit[0] = (((currentAngle_raw_q16 + angleInc_q16) % (360 << 16)) < angleInc_q16) ? 1 : 0;
            currentAngle_raw_q16 += angleInc_q16;


            angle_q6[1] = ((currentAngle_raw_q16 - (angle_offset2_q3 << 13)) >> 10);
            syncBit[1] = (((currentAngle_raw_q16 + angleInc_q16) % (360 << 16)) < angleInc_q16) ? 1 : 0;
            currentAngle_raw_q16 += angleInc_q16;

            for (int cpos = 0; cpos < 2; ++cpos) {

                if (angle_q6[cpos] < 0) angle_q6[cpos] += (360 << 6);
                if (angle_q6[cpos] >= (360 << 6)) angle_q6[cpos] -= (360 << 6);

                rplidar_response_measurement_node_hq_t hqNode;


                hqNode.flag = (syncBit[cpos] | ((!syncBit[cpos]) << 1));
                hqNode.quality = dist_q2[cpos] ? (0x2F << RPLIDAR_RESP_MEASUREMENT_QUALITY_SHIFT) : 0;

                hqNode.angle_z_q14 = (angle_q6[cpos] << 8) / 90;
                hqNode.dist_mm_q2 = dist_q2[cpos];

                engine->publishHQNode(_cached_last_data_timestamp_us - _getSampleDelayOffsetInExpressMode(_cachedTimingDesc, pos * 2 + cpos), &hqNode);
            }

        }
    }

    _cached_previous_capsuledata = capsule;
    _is_previous_capsuledataRdy = true;
    _cached_last_data_timestamp_us = currentTS;

}


// UnpackerHandler_UltraCapsuleNode
///////////////////////////////////////////////////////////////////////////////////

static _u64 _getSampleDelayOffsetInUltraBoostMode(const SlamtecLidarTimingDesc& timing, int sampleIdx)
{
    // FIXME: to eval
    // 
    // guess channel baudrate by LIDAR model ....
    const _u64 channelBaudRate = timing.native_baudrate ? timing.native_baudrate : 256000;

    _u64 tranmissionDelay = 1000000ULL * sizeof(rplidar_response_ultra_capsule_measurement_nodes_t) * 10 / channelBaudRate;

    if (timing.native_interface_type == LIDARInterfaceType::LIDAR_INTERFACE_ETHERNET)
    {
        tranmissionDelay = 100; //dummy value
    }

    // center of the sample duration
    const _u64 sampleDelay = (timing.sample_duration_uS >> 1);
    const _u64 sampleFilterDelay = timing.sample_duration_uS;
    const _u64 groupingDelay = ((32 * 3 - 1) - sampleIdx) * timing.sample_duration_uS;


    return sampleFilterDelay + sampleDelay + tranmissionDelay + timing.linkage_delay_uS + groupingDelay;
}


UnpackerHandler_UltraCapsuleNode::UnpackerHandler_UltraCapsuleNode()
    : _cached_scan_node_buf_pos(0)
    , _is_previous_capsuledataRdy(false)
    , _cached_last_data_timestamp_us(0)
{
    _cached_scan_node_buf.resize(sizeof(rplidar_response_ultra_capsule_measurement_nodes_t));
    memset(&_cachedTimingDesc, 0, sizeof(_cachedTimingDesc));
}

UnpackerHandler_UltraCapsuleNode::~UnpackerHandler_UltraCapsuleNode()
{

}

void UnpackerHandler_UltraCapsuleNode::onUnpackerContextSet(LIDARSampleDataUnpacker::UnpackerContextType type, const void* data, size_t size)
{
    if (type == LIDARSampleDataUnpacker::UNPACKER_CONTEXT_TYPE_LIDAR_TIMING) {
        assert(size == sizeof(_cachedTimingDesc));
        _cachedTimingDesc = *reinterpret_cast<const SlamtecLidarTimingDesc*>(data);
    }
}


_u8 UnpackerHandler_UltraCapsuleNode::getSampleAnswerType() const
{
    return RPLIDAR_ANS_TYPE_MEASUREMENT_CAPSULED_ULTRA;
}

void UnpackerHandler_UltraCapsuleNode::onData(LIDARSampleDataUnpackerInner* engine, const _u8* data, size_t cnt)
{

    for (size_t pos = 0; pos < cnt; ++pos) {
        _u8 current_data = data[pos];
        switch (_cached_scan_node_buf_pos) {
        case 0: // expect the sync bit 1
        {
            _u8 tmp = (current_data >> 4);
            if (tmp == RPLIDAR_RESP_MEASUREMENT_EXP_SYNC_1) {
                // pass
            }
            else {
                _is_previous_capsuledataRdy = false;
                continue;
            }

        }
        break;
        case 1: // expect the sync bit 2
        {
            _u8 tmp = (current_data >> 4);
            if (tmp == RPLIDAR_RESP_MEASUREMENT_EXP_SYNC_2) {
                // pass
            }
            else {
                _cached_scan_node_buf_pos = 0;
                _is_previous_capsuledataRdy = false;
                continue;
            }
        }
        break;

        case sizeof(rplidar_response_ultra_capsule_measurement_nodes_t) - 1: // new data ready
        {
            _cached_scan_node_buf[sizeof(rplidar_response_ultra_capsule_measurement_nodes_t) - 1] = current_data;
            _cached_scan_node_buf_pos = 0;

            rplidar_response_ultra_capsule_measurement_nodes_t* node = reinterpret_cast<rplidar_response_ultra_capsule_measurement_nodes_t*>(&_cached_scan_node_buf[0]);

            // calc the checksum ...
            _u8 checksum = 0;
            _u8 recvChecksum = ((node->s_checksum_1 & 0xF) | (node->s_checksum_2 << 4));
            for (size_t cpos = offsetof(rplidar_response_ultra_capsule_measurement_nodes_t, start_angle_sync_q6);
                cpos < sizeof(rplidar_response_ultra_capsule_measurement_nodes_t); ++cpos)
            {
                checksum ^= _cached_scan_node_buf[cpos];
            }

            if (recvChecksum == checksum)
            {
                // only consider vaild if the checksum matches...

                // perform data endianess convertion if necessary
#ifdef _CPU_ENDIAN_BIG
                node->start_angle_sync_q6 = le16_to_cpu(node->start_angle_sync_q6);
                for (size_t cpos = 0; cpos < _countof(node->ultra_cabins); ++cpos) {
                    node->ultra_cabins[cpos].combined_x3 = le32_to_cpu(node->ultra_cabins[cpos].combined_x3);
                }
#endif
                if (node->start_angle_sync_q6 & RPLIDAR_RESP_MEASUREMENT_EXP_SYNCBIT)
                {
                    if (_is_previous_capsuledataRdy) {
                        engine->publishDecodingErrorMsg(LIDARSampleDataUnpacker::ERR_EVENT_ON_EXP_ENCODER_RESET
                            , RPLIDAR_ANS_TYPE_MEASUREMENT_CAPSULED_ULTRA, node, sizeof(*node));

                    }
                    // this is the first capsule frame in logic, discard the previous cached data...
                    _is_previous_capsuledataRdy = false;

                    engine->publishNewScanReset();

                }
                _onScanNodeUltraCapsuleData(*node, engine);
            }
            else {
                _is_previous_capsuledataRdy = false;

                engine->publishDecodingErrorMsg(LIDARSampleDataUnpacker::ERR_EVENT_ON_EXP_CHECKSUM_ERR
                    , RPLIDAR_ANS_TYPE_MEASUREMENT_CAPSULED_ULTRA, node, sizeof(*node));

            }
            continue;
        }
        break;

        }
        _cached_scan_node_buf[_cached_scan_node_buf_pos++] = current_data;
    }

}

void UnpackerHandler_UltraCapsuleNode::reset()
{
    _cached_scan_node_buf_pos = 0;
    _is_previous_capsuledataRdy = false;
}

static _u32 _varbitscale_decode(_u32 scaled, _u32& scaleLevel)
{
    static const _u32 VBS_SCALED_BASE[] = {
        RPLIDAR_VARBITSCALE_X16_DEST_VAL,
        RPLIDAR_VARBITSCALE_X8_DEST_VAL,
        RPLIDAR_VARBITSCALE_X4_DEST_VAL,
        RPLIDAR_VARBITSCALE_X2_DEST_VAL,
        0,
    };

    static const _u32 VBS_SCALED_LVL[] = {
        4,
        3,
        2,
        1,
        0,
    };

    static const _u32 VBS_TARGET_BASE[] = {
        (0x1 << RPLIDAR_VARBITSCALE_X16_SRC_BIT),
        (0x1 << RPLIDAR_VARBITSCALE_X8_SRC_BIT),
        (0x1 << RPLIDAR_VARBITSCALE_X4_SRC_BIT),
        (0x1 << RPLIDAR_VARBITSCALE_X2_SRC_BIT),
        0,
    };

    for (size_t i = 0; i < _countof(VBS_SCALED_BASE); ++i)
    {
        int remain = ((int)scaled - (int)VBS_SCALED_BASE[i]);
        if (remain >= 0) {
            scaleLevel = VBS_SCALED_LVL[i];
            return VBS_TARGET_BASE[i] + (remain << scaleLevel);
        }
    }

    return 0;
}

void UnpackerHandler_UltraCapsuleNode::_onScanNodeUltraCapsuleData(rplidar_response_ultra_capsule_measurement_nodes_t& capsule, LIDARSampleDataUnpackerInner* engine)
{
    _u64 currentTS = engine->getCurrentTimestamp_uS();
    if (_is_previous_capsuledataRdy) {
        int diffAngle_q8;
        int currentStartAngle_q8 = ((capsule.start_angle_sync_q6 & 0x7FFF) << 2);
        int prevStartAngle_q8 = ((_cached_previous_ultracapsuledata.start_angle_sync_q6 & 0x7FFF) << 2);

        diffAngle_q8 = (currentStartAngle_q8)-(prevStartAngle_q8);
        if (prevStartAngle_q8 > currentStartAngle_q8) {
            diffAngle_q8 += (360 << 8);
        }

        int angleInc_q16 = (diffAngle_q8 << 3) / 3;
        int currentAngle_raw_q16 = (prevStartAngle_q8 << 8);
        for (int pos = 0; pos < (int)_countof(_cached_previous_ultracapsuledata.ultra_cabins); ++pos)
        {
            int dist_q2[3];
            int angle_q6[3];
            int syncBit[3];


            _u32 combined_x3 = _cached_previous_ultracapsuledata.ultra_cabins[pos].combined_x3;

            // unpack ...
            int dist_major = (combined_x3 & 0xFFF);

            // signed partical integer, using the magic shift here
            // DO NOT TOUCH

            int dist_predict1 = (((int)(combined_x3 << 10)) >> 22);
            int dist_predict2 = (((int)combined_x3) >> 22);

            int dist_major2;

            _u32 scalelvl1=0, scalelvl2 = 0;

            // prefetch next ...
            if (pos == _countof(_cached_previous_ultracapsuledata.ultra_cabins) - 1)
            {
                dist_major2 = (capsule.ultra_cabins[0].combined_x3 & 0xFFF);
            }
            else {
                dist_major2 = (_cached_previous_ultracapsuledata.ultra_cabins[pos + 1].combined_x3 & 0xFFF);
            }

            // decode with the var bit scale ...
            dist_major = _varbitscale_decode(dist_major, scalelvl1);
            dist_major2 = _varbitscale_decode(dist_major2, scalelvl2);


            int dist_base1 = dist_major;
            int dist_base2 = dist_major2;

            if ((!dist_major) && dist_major2) {
                dist_base1 = dist_major2;
                scalelvl1 = scalelvl2;
            }


            dist_q2[0] = (dist_major << 2);
            if (((_u32)dist_predict1 == 0xFFFFFE00) || ((_u32)dist_predict1 == 0x1FF)) {
                dist_q2[1] = 0;
            }
            else {
                dist_predict1 = (int)(dist_predict1 << scalelvl1);
                dist_q2[1] = (dist_predict1 + dist_base1) << 2;

            }

            if (((_u32)dist_predict2 == 0xFFFFFE00) || ((_u32)dist_predict2 == 0x1FF)) {
                dist_q2[2] = 0;
            }
            else {
                dist_predict2 = (int)(dist_predict2 << scalelvl2);
                dist_q2[2] = (dist_predict2 + dist_base2) << 2;
            }

            for (int cpos = 0; cpos < 3; ++cpos)
            {

                syncBit[cpos] = (((currentAngle_raw_q16 + angleInc_q16) % (360 << 16)) < angleInc_q16) ? 1 : 0;


                rplidar_response_measurement_node_hq_t hqNode;


                int offsetAngleMean_q16 = (int)(7.5 * 3.1415926535 * (1 << 16) / 180.0);

                if (dist_q2[cpos] >= (50 * 4))
                {
                    const int k1 = 98361;
                    const int k2 = int(k1 / dist_q2[cpos]);

                    offsetAngleMean_q16 = (int)(8 * 3.1415926535 * (1 << 16) / 180) - (k2 << 6) - (k2 * k2 * k2) / 98304;
                }

                angle_q6[cpos] = ((currentAngle_raw_q16 - int(offsetAngleMean_q16 * 180 / 3.14159265)) >> 10);
                currentAngle_raw_q16 += angleInc_q16;

                if (angle_q6[cpos] < 0) angle_q6[cpos] += (360 << 6);
                if (angle_q6[cpos] >= (360 << 6)) angle_q6[cpos] -= (360 << 6);


                hqNode.flag = (syncBit[cpos] | ((!syncBit[cpos]) << 1));
                hqNode.quality = dist_q2[cpos] ? (0x2F << RPLIDAR_RESP_MEASUREMENT_QUALITY_SHIFT) : 0;

                hqNode.angle_z_q14 = (angle_q6[cpos] << 8) / 90;
                hqNode.dist_mm_q2 = dist_q2[cpos];

                engine->publishHQNode(_cached_last_data_timestamp_us - _getSampleDelayOffsetInUltraBoostMode(_cachedTimingDesc, pos * 3 + cpos), &hqNode);
            }

        }
    }

    _cached_previous_ultracapsuledata = capsule;
    _is_previous_capsuledataRdy = true;
    _cached_last_data_timestamp_us = currentTS;

}


// UnpackerHandler_DenseCapsuleNode
///////////////////////////////////////////////////////////////////////////////////

static _u64 _getSampleDelayOffsetInDenseMode(const SlamtecLidarTimingDesc& timing, int sampleIdx)
{
    // FIXME: to eval
    // 
    // guess channel baudrate by LIDAR model ....
    const _u64 channelBaudRate = timing.native_baudrate ? timing.native_baudrate : 256000;

    _u64 tranmissionDelay = 1000000ULL * sizeof(rplidar_response_dense_capsule_measurement_nodes_t) * 10 / channelBaudRate;

    if (timing.native_interface_type == LIDARInterfaceType::LIDAR_INTERFACE_ETHERNET)
    {
        tranmissionDelay = 100; //dummy value
    }

    // center of the sample duration
    const _u64 sampleDelay = (timing.sample_duration_uS >> 1);
    const _u64 sampleFilterDelay = timing.sample_duration_uS;
    const _u64 groupingDelay = (39 - sampleIdx) * timing.sample_duration_uS;


    return sampleFilterDelay + sampleDelay + tranmissionDelay + timing.linkage_delay_uS + groupingDelay;
}

UnpackerHandler_DenseCapsuleNode::UnpackerHandler_DenseCapsuleNode()
    : _cached_scan_node_buf_pos(0)
    , _is_previous_capsuledataRdy(false)
    , _cached_last_data_timestamp_us(0)

{
    _cached_scan_node_buf.resize(sizeof(rplidar_response_dense_capsule_measurement_nodes_t));
    memset(&_cachedTimingDesc, 0, sizeof(_cachedTimingDesc));
}

UnpackerHandler_DenseCapsuleNode::~UnpackerHandler_DenseCapsuleNode()
{

}

void UnpackerHandler_DenseCapsuleNode::onUnpackerContextSet(LIDARSampleDataUnpacker::UnpackerContextType type, const void* data, size_t size)
{
    if (type == LIDARSampleDataUnpacker::UNPACKER_CONTEXT_TYPE_LIDAR_TIMING) {
        assert(size == sizeof(_cachedTimingDesc));
        _cachedTimingDesc = *reinterpret_cast<const SlamtecLidarTimingDesc*>(data);
    }
}


_u8 UnpackerHandler_DenseCapsuleNode::getSampleAnswerType() const
{
    return RPLIDAR_ANS_TYPE_MEASUREMENT_DENSE_CAPSULED;
}


void UnpackerHandler_DenseCapsuleNode::onData(LIDARSampleDataUnpackerInner* engine, const _u8* data, size_t cnt)
{

    for (size_t pos = 0; pos < cnt; ++pos) {
        _u8 current_data = data[pos];
        switch (_cached_scan_node_buf_pos) {
        case 0: // expect the sync bit 1
        {
            _u8 tmp = (current_data >> 4);
            if (tmp == RPLIDAR_RESP_MEASUREMENT_EXP_SYNC_1) {
                // pass
            }
            else {
                _is_previous_capsuledataRdy = false;
                continue;
            }

        }
        break;
        case 1: // expect the sync bit 2
        {
            _u8 tmp = (current_data >> 4);
            if (tmp == RPLIDAR_RESP_MEASUREMENT_EXP_SYNC_2) {
                // pass
            }
            else {
                _cached_scan_node_buf_pos = 0;
                _is_previous_capsuledataRdy = false;
                continue;
            }
        }
        break;

        case sizeof(rplidar_response_dense_capsule_measurement_nodes_t) - 1: // new data ready
        {
            _cached_scan_node_buf[sizeof(rplidar_response_dense_capsule_measurement_nodes_t) - 1] = current_data;
            _cached_scan_node_buf_pos = 0;

            rplidar_response_dense_capsule_measurement_nodes_t* node = reinterpret_cast<rplidar_response_dense_capsule_measurement_nodes_t*>(&_cached_scan_node_buf[0]);

            // calc the checksum ...
            _u8 checksum = 0;
            _u8 recvChecksum = ((node->s_checksum_1 & 0xF) | (node->s_checksum_2 << 4));
            for (size_t cpos = offsetof(rplidar_response_dense_capsule_measurement_nodes_t, start_angle_sync_q6);
                cpos < sizeof(rplidar_response_dense_capsule_measurement_nodes_t); ++cpos)
            {
                checksum ^= _cached_scan_node_buf[cpos];
            }

            if (recvChecksum == checksum)
            {
                // only consider vaild if the checksum matches...

                // perform data endianess convertion if necessary
#ifdef _CPU_ENDIAN_BIG
                node->start_angle_sync_q6 = le16_to_cpu(node->start_angle_sync_q6);
                for (size_t cpos = 0; cpos < _countof(node->cabins); ++cpos) {
                    node->cabins[cpos].distance_angle_1 = le16_to_cpu(node->cabins[cpos].distance_angle_1);
                    node->cabins[cpos].distance_angle_2 = le16_to_cpu(node->cabins[cpos].distance_angle_2);
                }
#endif
                if (node->start_angle_sync_q6 & RPLIDAR_RESP_MEASUREMENT_EXP_SYNCBIT)
                {
                    if (_is_previous_capsuledataRdy) {
                        engine->publishDecodingErrorMsg(LIDARSampleDataUnpacker::ERR_EVENT_ON_EXP_ENCODER_RESET
                            , RPLIDAR_ANS_TYPE_MEASUREMENT_DENSE_CAPSULED, node, sizeof(*node));
                    }
                    // this is the first capsule frame in logic, discard the previous cached data...
                    _is_previous_capsuledataRdy = false;
                    engine->publishNewScanReset();


                }
                _onScanNodeDenseCapsuleData(*node, engine);
            }
            else {
                _is_previous_capsuledataRdy = false;

                engine->publishDecodingErrorMsg(LIDARSampleDataUnpacker::ERR_EVENT_ON_EXP_CHECKSUM_ERR
                    , RPLIDAR_ANS_TYPE_MEASUREMENT_DENSE_CAPSULED, node, sizeof(*node));

            }
            continue;
        }
        break;

        }
        _cached_scan_node_buf[_cached_scan_node_buf_pos++] = current_data;
    }
}

void UnpackerHandler_DenseCapsuleNode::reset()
{
    _cached_scan_node_buf_pos = 0;
    _cached_last_data_timestamp_us = 0;
}

void UnpackerHandler_DenseCapsuleNode::_onScanNodeDenseCapsuleData(rplidar_response_dense_capsule_measurement_nodes_t& dense_capsule, LIDARSampleDataUnpackerInner* engine)
{
    static int lastNodeSyncBit = 0;
    _u64 currentTs = engine->getCurrentTimestamp_uS();

    if (_is_previous_capsuledataRdy) {
        int diffAngle_q8;
        int currentStartAngle_q8 = ((dense_capsule.start_angle_sync_q6 & 0x7FFF) << 2);
        int prevStartAngle_q8 = ((_cached_previous_dense_capsuledata.start_angle_sync_q6 & 0x7FFF) << 2);

        diffAngle_q8 = (currentStartAngle_q8)-(prevStartAngle_q8);
        if (prevStartAngle_q8 > currentStartAngle_q8) {
            diffAngle_q8 += (360 << 8);
        }
        int maxDiffAngleThreshold_q8 = (360/* 360 degree */ * 100 /*100Hz*/ * _countof(dense_capsule.cabins) /*40 points per capsule*/ / (1000000 / _cachedTimingDesc.sample_duration_uS)) << 8;
        if (diffAngle_q8 > maxDiffAngleThreshold_q8) {//discard
            _cached_previous_dense_capsuledata = dense_capsule;
            return;
        }

        int angleInc_q16 = (diffAngle_q8 << 8) / 40;
        int currentAngle_raw_q16 = (prevStartAngle_q8 << 8);
        for (int pos = 0; pos < (int)_countof(_cached_previous_dense_capsuledata.cabins); ++pos)
        {
            int dist_q2;
            int angle_q6;
            int syncBit;
            const int dist = static_cast<const int>(_cached_previous_dense_capsuledata.cabins[pos].distance);
            dist_q2 = dist << 2;
            angle_q6 = (currentAngle_raw_q16 >> 10);
            syncBit = (((currentAngle_raw_q16 + angleInc_q16) % (360 << 16)) < (angleInc_q16 << 1)) ? 1 : 0;
            syncBit = (syncBit ^ lastNodeSyncBit) & syncBit;//Ensure that syncBit is exactly detected

            currentAngle_raw_q16 += angleInc_q16;

            if (angle_q6 < 0) angle_q6 += (360 << 6);
            if (angle_q6 >= (360 << 6)) angle_q6 -= (360 << 6);

            rplidar_response_measurement_node_hq_t hqNode;


            hqNode.flag = (syncBit | ((!syncBit) << 1));
            hqNode.quality = dist_q2 ? (0x2F << RPLIDAR_RESP_MEASUREMENT_QUALITY_SHIFT) : 0;
            hqNode.angle_z_q14 = (angle_q6 << 8) / 90;
            hqNode.dist_mm_q2 = dist_q2;
            engine->publishHQNode(currentTs - _getSampleDelayOffsetInDenseMode(_cachedTimingDesc, pos), &hqNode);
            
            lastNodeSyncBit = syncBit;

        }
    }

    _cached_previous_dense_capsuledata = dense_capsule;
    _is_previous_capsuledataRdy = true;

}

// UnpackerHandler_UltraDenseCapsuleNode
///////////////////////////////////////////////////////////////////////////////////

static _u64 _getSampleDelayOffsetInUltraDenseMode(const SlamtecLidarTimingDesc& timing, int sampleIdx)
{
    // FIXME: to eval
    // 
    // guess channel baudrate by LIDAR model ....
    const _u64 channelBaudRate = timing.native_baudrate ? timing.native_baudrate : 1000000;

    _u64 tranmissionDelay = 1000000ULL * sizeof(sl_lidar_response_ultra_dense_capsule_measurement_nodes_t) * 10 / channelBaudRate;

    if (timing.native_interface_type == LIDARInterfaceType::LIDAR_INTERFACE_ETHERNET)
    {
        tranmissionDelay = 100; //dummy value
    }

    // center of the sample duration
    const _u64 sampleDelay = (timing.sample_duration_uS >> 1);
    const _u64 sampleFilterDelay = timing.sample_duration_uS;
    const _u64 groupingDelay = ((32 * 2 - 1) - sampleIdx) * timing.sample_duration_uS;


    return sampleFilterDelay + sampleDelay + tranmissionDelay + timing.linkage_delay_uS + groupingDelay;
}


UnpackerHandler_UltraDenseCapsuleNode::UnpackerHandler_UltraDenseCapsuleNode()
    : _cached_scan_node_buf_pos(0)
    , _is_previous_capsuledataRdy(false)
    , _cached_last_data_timestamp_us(0)
    , _last_node_sync_bit(0)
    , _last_dist_q2(0)

{
    _cached_scan_node_buf.resize(sizeof(rplidar_response_ultra_dense_capsule_measurement_nodes_t));
    memset(&_cachedTimingDesc, 0, sizeof(_cachedTimingDesc));
}

UnpackerHandler_UltraDenseCapsuleNode::~UnpackerHandler_UltraDenseCapsuleNode()
{

}


void UnpackerHandler_UltraDenseCapsuleNode::onUnpackerContextSet(LIDARSampleDataUnpacker::UnpackerContextType type, const void* data, size_t size)
{
    if (type == LIDARSampleDataUnpacker::UNPACKER_CONTEXT_TYPE_LIDAR_TIMING) {
        assert(size == sizeof(_cachedTimingDesc));
        _cachedTimingDesc = *reinterpret_cast<const SlamtecLidarTimingDesc*>(data);
    }
}


_u8 UnpackerHandler_UltraDenseCapsuleNode::getSampleAnswerType() const
{
    return RPLIDAR_ANS_TYPE_MEASUREMENT_ULTRA_DENSE_CAPSULED;
}

void UnpackerHandler_UltraDenseCapsuleNode::onData(LIDARSampleDataUnpackerInner* engine, const _u8* data, size_t cnt)
{
    for (size_t pos = 0; pos < cnt; ++pos) {
        _u8 current_data = data[pos];
        switch (_cached_scan_node_buf_pos) {
        case 0: // expect the sync bit 1
        {
            _u8 tmp = (current_data >> 4);
            if (tmp == RPLIDAR_RESP_MEASUREMENT_EXP_SYNC_1) {
                // pass
            }
            else {
                _is_previous_capsuledataRdy = false;
                continue;
            }

        }
        break;
        case 1: // expect the sync bit 2
        {
            _u8 tmp = (current_data >> 4);
            if (tmp == RPLIDAR_RESP_MEASUREMENT_EXP_SYNC_2) {
                // pass
            }
            else {
                _cached_scan_node_buf_pos = 0;
                _is_previous_capsuledataRdy = false;
                continue;
            }
        }
        break;

        case sizeof(rplidar_response_ultra_dense_capsule_measurement_nodes_t) - 1: // new data ready
        {
            _cached_scan_node_buf[sizeof(rplidar_response_ultra_dense_capsule_measurement_nodes_t) - 1] = current_data;
            _cached_scan_node_buf_pos = 0;

            rplidar_response_ultra_dense_capsule_measurement_nodes_t* node = reinterpret_cast<rplidar_response_ultra_dense_capsule_measurement_nodes_t*>(&_cached_scan_node_buf[0]);

            // calc the checksum ...
            _u8 checksum = 0;
            _u8 recvChecksum = ((node->s_checksum_1 & 0xF) | (node->s_checksum_2 << 4));
            for (size_t cpos = offsetof(rplidar_response_ultra_dense_capsule_measurement_nodes_t, time_stamp);
                cpos < sizeof(rplidar_response_ultra_dense_capsule_measurement_nodes_t); ++cpos)
            {
                checksum ^= _cached_scan_node_buf[cpos];
            }

            if (recvChecksum == checksum)
            {
                // only consider vaild if the checksum matches...

                // perform data endianess convertion if necessary
#ifdef _CPU_ENDIAN_BIG
                node->start_angle_sync_q6 = le16_to_cpu(node->start_angle_sync_q6);
                for (size_t cpos = 0; cpos < _countof(node->cabins); ++cpos) {
                    node->cabins[cpos].qualityl_distance_scale[0] = le16_to_cpu(node->cabins[cpos].qualityl_distance_scale[0]);
                    node->cabins[cpos].qualityl_distance_scale[1] = le16_to_cpu(node->cabins[cpos].qualityl_distance_scale[1]);
                }
#endif
                if (node->start_angle_sync_q6 & RPLIDAR_RESP_MEASUREMENT_EXP_SYNCBIT)
                {
                    if (_is_previous_capsuledataRdy) {
                        engine->publishDecodingErrorMsg(LIDARSampleDataUnpacker::ERR_EVENT_ON_EXP_ENCODER_RESET
                            , RPLIDAR_ANS_TYPE_MEASUREMENT_ULTRA_DENSE_CAPSULED, node, sizeof(*node));

                    }
                    // this is the first capsule frame in logic, discard the previous cached data...
                    _is_previous_capsuledataRdy = false;
                    engine->publishNewScanReset();

                }
                _onScanNodeUltraDenseCapsuleData(*node, engine);
            }
            else {
                _is_previous_capsuledataRdy = false;

                engine->publishDecodingErrorMsg(LIDARSampleDataUnpacker::ERR_EVENT_ON_EXP_CHECKSUM_ERR
                    , RPLIDAR_ANS_TYPE_MEASUREMENT_ULTRA_DENSE_CAPSULED, node, sizeof(*node));

            }
            continue;
        }
        break;

        }
        _cached_scan_node_buf[_cached_scan_node_buf_pos++] = current_data;
    }

}

void UnpackerHandler_UltraDenseCapsuleNode::reset()
{
    _cached_scan_node_buf_pos = 0;
    _cached_last_data_timestamp_us = 0;
    _last_node_sync_bit = 0;
    _last_dist_q2 = 0;
}

void UnpackerHandler_UltraDenseCapsuleNode::_onScanNodeUltraDenseCapsuleData(rplidar_response_ultra_dense_capsule_measurement_nodes_t& capsule, LIDARSampleDataUnpackerInner* engine)
{
    _u64 currentTimestamp = engine->getCurrentTimestamp_uS();

    const rplidar_response_ultra_dense_capsule_measurement_nodes_t* ultra_dense_capsule = reinterpret_cast<const rplidar_response_ultra_dense_capsule_measurement_nodes_t*>(&capsule);
    if (_is_previous_capsuledataRdy) {
        int diffAngle_q8;
        int currentStartAngle_q8 = ((ultra_dense_capsule->start_angle_sync_q6 & 0x7FFF) << 2);
        int prevStartAngle_q8 = ((_cached_previous_ultra_dense_capsuledata.start_angle_sync_q6 & 0x7FFF) << 2);



        diffAngle_q8 = (currentStartAngle_q8)-(prevStartAngle_q8);
        if (prevStartAngle_q8 > currentStartAngle_q8) {
            diffAngle_q8 += (360 << 8);
        }

        int maxDiffAngleThreshold_q8 = (360/* 360 degree */ * 100 /*100Hz*/ * _countof(ultra_dense_capsule->cabins) /*64 points per capsule*/ / (1000000 / _cachedTimingDesc.sample_duration_uS)) << 8;
        if (diffAngle_q8 > maxDiffAngleThreshold_q8) {//discard
            _cached_previous_ultra_dense_capsuledata = *ultra_dense_capsule;
            return;
        }
#define DISTANCE_THRESHOLD_TO_SCALE_1 2046  // (2^10 - 1)*2 mm
#define DISTANCE_THRESHOLD_TO_SCALE_2 8187  // (2^11 - 1)*3 + 2046 mm
#define DISTANCE_THRESHOLD_TO_SCALE_3 24567 // (2^12 - 1)*4 + 8187 mm
        int angleInc_q16 = (diffAngle_q8 << 8) / 64;
        int currentAngle_raw_q16 = (prevStartAngle_q8 << 8);
        for (int pos = 0; pos < (int)_countof(_cached_previous_ultra_dense_capsuledata.cabins) * 2; ++pos)
        {
            int angle_q6;
            int syncBit;
            size_t cabin_idx = pos >> 1;
            _u32  quality_dist_scale;
            if (!(pos & 0x1)) {
                quality_dist_scale = _cached_previous_ultra_dense_capsuledata.cabins[cabin_idx].qualityl_distance_scale[0] | ((_cached_previous_ultra_dense_capsuledata.cabins[cabin_idx].qualityh_array & 0x0F) << 16);
            }
            else {
                quality_dist_scale = _cached_previous_ultra_dense_capsuledata.cabins[cabin_idx].qualityl_distance_scale[1] | ((_cached_previous_ultra_dense_capsuledata.cabins[cabin_idx].qualityh_array >> 4) << 16);
            }

            _u8 scale = quality_dist_scale & 0x3;
            _u8 quality = 0;
            int dist_q2 = 0;

            switch (scale) {
            case 0:
                quality = quality_dist_scale >> 12;
                dist_q2 = (quality_dist_scale & 0xFFC) * 2;
                if (_last_dist_q2) {
                    if (abs(dist_q2 - _last_dist_q2) <= 8/*2mm *2*/) {
                        dist_q2 = (dist_q2 + _last_dist_q2) >> 1;
                    }
                }
                break;
            case 1:
                quality = (quality_dist_scale >> 13) << 1;
                dist_q2 = (quality_dist_scale & 0x1FFC) * 3 + (DISTANCE_THRESHOLD_TO_SCALE_1 << 2);
                break;
            case 2:
                quality = (quality_dist_scale >> 14) << 2;
                dist_q2 = (quality_dist_scale & 0x3FFC) * 4 + (DISTANCE_THRESHOLD_TO_SCALE_2 << 2);
                break;
            case 3:
                quality = (quality_dist_scale >> 15) << 3;
                dist_q2 = (quality_dist_scale & 0x7FFC) * 5 + (DISTANCE_THRESHOLD_TO_SCALE_3 << 2);
                break;
            }
            _last_dist_q2 = dist_q2;
            angle_q6 = (currentAngle_raw_q16 >> 10);
            syncBit = (((currentAngle_raw_q16 + angleInc_q16) % (360 << 16)) < (angleInc_q16 << 1)) ? 1 : 0;
            syncBit = (syncBit ^ _last_node_sync_bit) & syncBit;//Ensure that syncBit is exactly detected

            currentAngle_raw_q16 += angleInc_q16;

            if (angle_q6 < 0) angle_q6 += (360 << 6);
            if (angle_q6 >= (360 << 6)) angle_q6 -= (360 << 6);


            rplidar_response_measurement_node_hq_t hqNode;



            hqNode.flag = (syncBit | ((!syncBit) << 1));
            hqNode.quality = quality;
            hqNode.angle_z_q14 = (angle_q6 << 8) / 90;
            hqNode.dist_mm_q2 = dist_q2;
            engine->publishHQNode(currentTimestamp - _getSampleDelayOffsetInUltraDenseMode(_cachedTimingDesc, pos), &hqNode);
            
            _last_node_sync_bit = syncBit;

        }
    }

    _cached_previous_ultra_dense_capsuledata = *ultra_dense_capsule;
    _is_previous_capsuledataRdy = true;

}



}


END_DATAUNPACKER_NS()


================================================
File: src/rplidar_ros/sdk/src/dataunpacker/unpacker/handler_capsules.h
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */

 /*
  *  Sample Data Unpacker System
  *  Capsule Style Sample Node Handlers
  */

  /*
	* Redistribution and use in source and binary forms, with or without
	* modification, are permitted provided that the following conditions are met:
	*
	* 1. Redistributions of source code must retain the above copyright notice,
	*    this list of conditions and the following disclaimer.
	*
	* 2. Redistributions in binary form must reproduce the above copyright notice,
	*    this list of conditions and the following disclaimer in the documentation
	*    and/or other materials provided with the distribution.
	*
	* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
	* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
	* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
	* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	*/

#pragma once

BEGIN_DATAUNPACKER_NS()

namespace unpacker {

class UnpackerHandler_CapsuleNode : public IDataUnpackerHandler {
public:
	UnpackerHandler_CapsuleNode();
	virtual ~UnpackerHandler_CapsuleNode();

	virtual _u8 getSampleAnswerType() const;
	virtual void onData(LIDARSampleDataUnpackerInner* engine, const _u8* data, size_t size);
	virtual void reset();
	virtual void onUnpackerContextSet(LIDARSampleDataUnpacker::UnpackerContextType type, const void* data, size_t size);
protected:

	void _onScanNodeCapsuleData(rplidar_response_capsule_measurement_nodes_t &, LIDARSampleDataUnpackerInner* engine);

	std::vector<_u8> _cached_scan_node_buf;
	int              _cached_scan_node_buf_pos;
	bool             _is_previous_capsuledataRdy;

	rplidar_response_capsule_measurement_nodes_t _cached_previous_capsuledata;
	_u64             _cached_last_data_timestamp_us;

	SlamtecLidarTimingDesc _cachedTimingDesc;
};

class UnpackerHandler_UltraCapsuleNode : public IDataUnpackerHandler {
public:
	UnpackerHandler_UltraCapsuleNode();
	virtual ~UnpackerHandler_UltraCapsuleNode();

	virtual _u8 getSampleAnswerType() const;
	virtual void onData(LIDARSampleDataUnpackerInner* engine, const _u8* data, size_t size);
	virtual void reset();
	virtual void onUnpackerContextSet(LIDARSampleDataUnpacker::UnpackerContextType type, const void* data, size_t size);
protected:
	void _onScanNodeUltraCapsuleData(rplidar_response_ultra_capsule_measurement_nodes_t&, LIDARSampleDataUnpackerInner* engine);


	std::vector<_u8> _cached_scan_node_buf;
	int              _cached_scan_node_buf_pos;
	bool             _is_previous_capsuledataRdy;

	rplidar_response_ultra_capsule_measurement_nodes_t _cached_previous_ultracapsuledata;
	_u64             _cached_last_data_timestamp_us;

	SlamtecLidarTimingDesc _cachedTimingDesc;

};



class UnpackerHandler_DenseCapsuleNode : public IDataUnpackerHandler {
public:
	UnpackerHandler_DenseCapsuleNode();
	virtual ~UnpackerHandler_DenseCapsuleNode();

	virtual _u8 getSampleAnswerType() const;
	virtual void onData(LIDARSampleDataUnpackerInner* engine, const _u8* data, size_t size);
	virtual void reset();
	virtual void onUnpackerContextSet(LIDARSampleDataUnpacker::UnpackerContextType type, const void* data, size_t size);
protected:
	void _onScanNodeDenseCapsuleData(rplidar_response_dense_capsule_measurement_nodes_t&, LIDARSampleDataUnpackerInner* engine);


	std::vector<_u8> _cached_scan_node_buf;
	int              _cached_scan_node_buf_pos;
	bool             _is_previous_capsuledataRdy;

	rplidar_response_dense_capsule_measurement_nodes_t _cached_previous_dense_capsuledata;
	_u64             _cached_last_data_timestamp_us;

	SlamtecLidarTimingDesc _cachedTimingDesc;

};


class UnpackerHandler_UltraDenseCapsuleNode : public IDataUnpackerHandler {
public:
	UnpackerHandler_UltraDenseCapsuleNode();
	virtual ~UnpackerHandler_UltraDenseCapsuleNode();

	virtual _u8 getSampleAnswerType() const;
	virtual void onData(LIDARSampleDataUnpackerInner* engine, const _u8* data, size_t size);
	virtual void reset();
	virtual void onUnpackerContextSet(LIDARSampleDataUnpacker::UnpackerContextType type, const void* data, size_t size);
protected:
	void _onScanNodeUltraDenseCapsuleData(rplidar_response_ultra_dense_capsule_measurement_nodes_t&, LIDARSampleDataUnpackerInner* engine);

	std::vector<_u8> _cached_scan_node_buf;
	int              _cached_scan_node_buf_pos;
	bool             _is_previous_capsuledataRdy;

	rplidar_response_ultra_dense_capsule_measurement_nodes_t _cached_previous_ultra_dense_capsuledata;
	_u64             _cached_last_data_timestamp_us;



	int              _last_node_sync_bit;
	int              _last_dist_q2;

	SlamtecLidarTimingDesc _cachedTimingDesc;
};


}

END_DATAUNPACKER_NS()


================================================
File: src/rplidar_ros/sdk/src/dataunpacker/unpacker/handler_hqnode.cpp
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */

 /*
  *  Sample Data Unpacker System
  *  HQNode Sample Node Handler
  */

  /*
	* Redistribution and use in source and binary forms, with or without
	* modification, are permitted provided that the following conditions are met:
	*
	* 1. Redistributions of source code must retain the above copyright notice,
	*    this list of conditions and the following disclaimer.
	*
	* 2. Redistributions in binary form must reproduce the above copyright notice,
	*    this list of conditions and the following disclaimer in the documentation
	*    and/or other materials provided with the distribution.
	*
	* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
	* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
	* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
	* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	*/

#include "../dataunnpacker_commondef.h"
#include "../dataunpacker.h"
#include "../dataunnpacker_internal.h"

#ifdef CONF_NO_BOOST_CRC_SUPPORT
#include "sl_crc.h" 
#endif

#include "handler_hqnode.h"

BEGIN_DATAUNPACKER_NS()
	
namespace unpacker{


static _u64 _getSampleDelayOffsetInHQMode(const SlamtecLidarTimingDesc& timing)
{
    // FIXME: to eval
    // 
    // guess channel baudrate by LIDAR model ....
    const _u64 channelBaudRate = timing.native_baudrate? timing.native_baudrate:1000000;

    _u64 tranmissionDelay = 1000000ULL * sizeof(rplidar_response_measurement_node_hq_t) * 10 / channelBaudRate;

    if (timing.native_interface_type == LIDARInterfaceType::LIDAR_INTERFACE_ETHERNET)
    {
        tranmissionDelay = 100; //dummy value
    }

    // center of the sample duration
    const _u64 sampleDelay = (timing.sample_duration_uS >> 1);
    const _u64 sampleFilterDelay = timing.sample_duration_uS;

    return sampleFilterDelay + sampleDelay + tranmissionDelay + timing.linkage_delay_uS;
}

UnpackerHandler_HQNode::UnpackerHandler_HQNode()
    : _cached_scan_node_buf_pos(0)
{
    _cached_scan_node_buf.resize(sizeof(rplidar_response_hq_capsule_measurement_nodes_t));
    memset(&_cachedTimingDesc, 0, sizeof(_cachedTimingDesc));
}

UnpackerHandler_HQNode::~UnpackerHandler_HQNode()
{

}

_u8 UnpackerHandler_HQNode::getSampleAnswerType() const
{
	return RPLIDAR_ANS_TYPE_MEASUREMENT_HQ;
}

void UnpackerHandler_HQNode::onData(LIDARSampleDataUnpackerInner* engine, const _u8* data, size_t cnt)
{

    for (size_t pos = 0; pos < cnt; ++pos)
    {
        _u8 current_data = data[pos];

        switch (_cached_scan_node_buf_pos)
        {
        case 0: // expect the sync byte
        {
            if (current_data == RPLIDAR_RESP_MEASUREMENT_HQ_SYNC) {
                // pass
            }
            else {
                continue;
            }
        }
        break;

        case sizeof(rplidar_response_hq_capsule_measurement_nodes_t) - 1 - 4:    // get bytes to calculate crc ready
        {
           
        }
        break;

        case sizeof(rplidar_response_hq_capsule_measurement_nodes_t) - 1: // new data ready
        {
            _cached_scan_node_buf[sizeof(rplidar_response_hq_capsule_measurement_nodes_t) - 1] = current_data;
            _cached_scan_node_buf_pos = 0;
            rplidar_response_hq_capsule_measurement_nodes_t* nodesData = reinterpret_cast<rplidar_response_hq_capsule_measurement_nodes_t*>(&_cached_scan_node_buf[0]);

#ifdef CONF_NO_BOOST_CRC_SUPPORT
            _u32 crcCalc = crc32::getResult(&_cached_scan_node_buf[0], sizeof(sl_lidar_response_hq_capsule_measurement_nodes_t) - 4);


#else
            // calculate crc with boost crc method
            boost::crc_optimal<32, 0x04C11DB7, 0xFFFFFFFF, 0xFFFFFFFF, true, true> mycrc;
            std::vector<_u8> crcInputData;
            crcInputData.resize(sizeof(rplidar_response_hq_capsule_measurement_nodes_t) - 4);
            memcpy(&crcInputData[0], nodesData, sizeof(rplidar_response_hq_capsule_measurement_nodes_t) - 4);
            //supplement crcInputData to mutiples of 4
            int leftBytes = 4 - (crcInputData.size() & 3);
            for (int i = 0; i < leftBytes; i++)
                crcInputData.push_back(0);
            mycrc.process_bytes(&crcInputData[0], crcInputData.size());
            _u32 crcCalc = mycrc.checksum();
            
#endif

            _u32 recvCRC = nodesData->crc32;
#ifdef _CPU_ENDIAN_BIG
            recvCRC = le32_to_cpu(recvCRC);
            nodesData->time_stamp = le64_to_cpu(nodesData->time_stamp);
#endif
            if (recvCRC == crcCalc)
            {
                for (size_t pos = 0; pos < _countof(nodesData->node_hq); ++pos)
                {
                    rplidar_response_measurement_node_hq_t hqNode = nodesData->node_hq[pos];
#ifdef _CPU_ENDIAN_BIG
                    hqNode.angle_z_q14 = le16_to_cpu(hqNode.angle_z_q14);
                    hqNode.dist_mm_q2 = le32_to_cpu(hqNode.dist_mm_q2);
#endif
                    engine->publishHQNode(engine->getCurrentTimestamp_uS() - _getSampleDelayOffsetInHQMode(_cachedTimingDesc), &hqNode);
                }
            }
            else  //crc check not passed 
            {
                engine->publishDecodingErrorMsg(LIDARSampleDataUnpacker::ERR_EVENT_ON_EXP_CHECKSUM_ERR
                    , RPLIDAR_ANS_TYPE_MEASUREMENT_HQ, nodesData, sizeof(*nodesData));
            }
            continue;
        }
        break;


        }
        _cached_scan_node_buf[_cached_scan_node_buf_pos++] = current_data;
    }

}


void UnpackerHandler_HQNode::onUnpackerContextSet(LIDARSampleDataUnpacker::UnpackerContextType type, const void* data, size_t size)
{
    if (type == LIDARSampleDataUnpacker::UNPACKER_CONTEXT_TYPE_LIDAR_TIMING) {
        assert(size == sizeof(_cachedTimingDesc));
        _cachedTimingDesc = *reinterpret_cast<const SlamtecLidarTimingDesc*>(data);
    }
}

void UnpackerHandler_HQNode::reset()
{
    _cached_scan_node_buf_pos = 0;
}
}


END_DATAUNPACKER_NS()


================================================
File: src/rplidar_ros/sdk/src/dataunpacker/unpacker/handler_hqnode.h
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */

 /*
  *  Sample Data Unpacker System
  *  HQNode Sample Node Handler
  */

  /*
	* Redistribution and use in source and binary forms, with or without
	* modification, are permitted provided that the following conditions are met:
	*
	* 1. Redistributions of source code must retain the above copyright notice,
	*    this list of conditions and the following disclaimer.
	*
	* 2. Redistributions in binary form must reproduce the above copyright notice,
	*    this list of conditions and the following disclaimer in the documentation
	*    and/or other materials provided with the distribution.
	*
	* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
	* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
	* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
	* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	*/

#pragma once

BEGIN_DATAUNPACKER_NS()

namespace unpacker {

	class UnpackerHandler_HQNode : public IDataUnpackerHandler {
	public:
		UnpackerHandler_HQNode();
		virtual ~UnpackerHandler_HQNode();

		virtual _u8 getSampleAnswerType() const;
		virtual void onData(LIDARSampleDataUnpackerInner* engine, const _u8* data, size_t size);
		virtual void reset();
		virtual void onUnpackerContextSet(LIDARSampleDataUnpacker::UnpackerContextType type, const void* data, size_t size);

	protected:
		std::vector<_u8> _cached_scan_node_buf;
		int              _cached_scan_node_buf_pos;
		SlamtecLidarTimingDesc _cachedTimingDesc;
	};

}

END_DATAUNPACKER_NS()


================================================
File: src/rplidar_ros/sdk/src/dataunpacker/unpacker/handler_normalnode.cpp
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */

 /*
  *  Sample Data Unpacker System
  *  Normal Sample Node Handler
  */

  /*
	* Redistribution and use in source and binary forms, with or without
	* modification, are permitted provided that the following conditions are met:
	*
	* 1. Redistributions of source code must retain the above copyright notice,
	*    this list of conditions and the following disclaimer.
	*
	* 2. Redistributions in binary form must reproduce the above copyright notice,
	*    this list of conditions and the following disclaimer in the documentation
	*    and/or other materials provided with the distribution.
	*
	* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
	* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
	* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
	* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	*/

#include "../dataunnpacker_commondef.h"
#include "../dataunpacker.h"
#include "../dataunnpacker_internal.h"


#include "handler_normalnode.h"

BEGIN_DATAUNPACKER_NS()
	
namespace unpacker{


static _u64 _getSampleDelayOffsetInLegacyMode(const SlamtecLidarTimingDesc& timing)
{
    // guess channel baudrate by LIDAR model ....
    const _u64 channelBaudRate = timing.native_baudrate? timing.native_baudrate:115200;

    _u64 tranmissionDelay = 1000000ULL * sizeof(rplidar_response_measurement_node_t) * 10 / channelBaudRate;

    if (timing.native_interface_type == LIDARInterfaceType::LIDAR_INTERFACE_ETHERNET)
    {
        tranmissionDelay = 100; //dummy value
    }

    // center of the sample duration
    const _u64 sampleDelay = (timing.sample_duration_uS >> 1);
    const _u64 sampleFilterDelay = timing.sample_duration_uS;

    return sampleFilterDelay + sampleDelay + tranmissionDelay + timing.linkage_delay_uS;
}

UnpackerHandler_NormalNode::UnpackerHandler_NormalNode()
    : _cached_scan_node_buf_pos(0)
{
    _cached_scan_node_buf.resize(sizeof(rplidar_response_measurement_node_t));
    memset(&_cachedTimingDesc, 0, sizeof(_cachedTimingDesc));
;}

UnpackerHandler_NormalNode::~UnpackerHandler_NormalNode()
{

}

_u8 UnpackerHandler_NormalNode::getSampleAnswerType() const
{
	return RPLIDAR_ANS_TYPE_MEASUREMENT;
}

void UnpackerHandler_NormalNode::onData(LIDARSampleDataUnpackerInner* engine, const _u8* data, size_t cnt)
{
    for (size_t pos = 0; pos < cnt; ++pos) {
        _u8 current_data = data[pos];
        switch (_cached_scan_node_buf_pos) {
        case 0: // expect the sync bit and its reverse in this byte
        {
            _u8 tmp = (current_data >> 1);
            if ((tmp ^ current_data) & 0x1) {
                // pass
            }
            else {
                continue;
            }

        }
        break;
        case 1: // expect the highest bit to be 1
        {
            if (current_data & RPLIDAR_RESP_MEASUREMENT_CHECKBIT) {
                // pass
            }
            else {
                _cached_scan_node_buf_pos = 0;
                continue;
            }
        }
        break;
        case sizeof(rplidar_response_measurement_node_t) - 1: // new data ready
        {
            _cached_scan_node_buf[sizeof(rplidar_response_measurement_node_t) - 1] = current_data;
            _cached_scan_node_buf_pos = 0;

            rplidar_response_measurement_node_t* node = reinterpret_cast<rplidar_response_measurement_node_t*>(&_cached_scan_node_buf[0]);
#ifdef _CPU_ENDIAN_BIG
            node->angle_q6_checkbit = le16_to_cpu(node->angle_q6_checkbit);
            node->distance_q2 = le16_to_cpu(node->distance_q2);
#endif
            //cast node to rplidar_response_measurement_node_hq_t
            rplidar_response_measurement_node_hq_t hqNode;
            hqNode.angle_z_q14 = (((node->angle_q6_checkbit) >> RPLIDAR_RESP_MEASUREMENT_ANGLE_SHIFT) << 8) / 90;  //transfer to q14 Z-angle
            hqNode.dist_mm_q2 = node->distance_q2;
            hqNode.flag = (node->sync_quality & RPLIDAR_RESP_MEASUREMENT_SYNCBIT);  // trasfer syncbit to HQ flag field
            hqNode.quality = (node->sync_quality >> RPLIDAR_RESP_MEASUREMENT_QUALITY_SHIFT) << RPLIDAR_RESP_MEASUREMENT_QUALITY_SHIFT;  //remove the last two bits and then make quality from 0-63 to 0-255
            
            
            engine->publishHQNode(engine->getCurrentTimestamp_uS() - _getSampleDelayOffsetInLegacyMode(_cachedTimingDesc), &hqNode);
            continue;

        }
        break;
        }
        _cached_scan_node_buf[_cached_scan_node_buf_pos++] = current_data;
    }
}


void UnpackerHandler_NormalNode::onUnpackerContextSet(LIDARSampleDataUnpacker::UnpackerContextType type, const void* data, size_t size)
{
    if (type == LIDARSampleDataUnpacker::UNPACKER_CONTEXT_TYPE_LIDAR_TIMING) {
        assert(size == sizeof(_cachedTimingDesc));
        _cachedTimingDesc = *reinterpret_cast<const SlamtecLidarTimingDesc*>(data);
    }
}

void UnpackerHandler_NormalNode::reset()
{
    _cached_scan_node_buf_pos = 0;
}
}


END_DATAUNPACKER_NS()


================================================
File: src/rplidar_ros/sdk/src/dataunpacker/unpacker/handler_normalnode.h
================================================
/*
 *  Slamtec LIDAR SDK
 *
 *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */

 /*
  *  Sample Data Unpacker System
  *  Normal Sample Node Handler
  */

  /*
	* Redistribution and use in source and binary forms, with or without
	* modification, are permitted provided that the following conditions are met:
	*
	* 1. Redistributions of source code must retain the above copyright notice,
	*    this list of conditions and the following disclaimer.
	*
	* 2. Redistributions in binary form must reproduce the above copyright notice,
	*    this list of conditions and the following disclaimer in the documentation
	*    and/or other materials provided with the distribution.
	*
	* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
	* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
	* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
	* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	*/

#pragma once

BEGIN_DATAUNPACKER_NS()
	
namespace unpacker{

class UnpackerHandler_NormalNode : public IDataUnpackerHandler {
public:
	UnpackerHandler_NormalNode();
	virtual ~UnpackerHandler_NormalNode();

	virtual _u8 getSampleAnswerType() const;
	virtual void onData(LIDARSampleDataUnpackerInner* engine, const _u8* data, size_t size);
	virtual void reset();
	virtual void onUnpackerContextSet(LIDARSampleDataUnpacker::UnpackerContextType type, const void* data, size_t size);
protected:
	std::vector<_u8> _cached_scan_node_buf;
	int              _cached_scan_node_buf_pos;

	SlamtecLidarTimingDesc _cachedTimingDesc;
};

}

END_DATAUNPACKER_NS()


================================================
File: src/rplidar_ros/sdk/src/hal/abs_rxtx.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once 

#include "hal/types.h"

namespace rp{ namespace hal{

class serial_rxtx
{
public:
    enum{
        ANS_OK      = 0,
        ANS_TIMEOUT = -1,
        ANS_DEV_ERR = -2,
    };

    static serial_rxtx * CreateRxTx();
    static void ReleaseRxTx( serial_rxtx * );

    serial_rxtx():_is_serial_opened(false){}
    virtual ~serial_rxtx(){}

    virtual void flush( _u32 flags) = 0;

    virtual bool bind(const char * portname, _u32 baudrate, _u32 flags = 0) = 0;
    virtual bool open() = 0;
    virtual void close()  = 0;
    
    virtual int waitfordata(size_t data_count,_u32 timeout = -1, size_t * returned_size = NULL) = 0;

    virtual int senddata(const unsigned char * data, size_t size) = 0;
    virtual int recvdata(unsigned char * data, size_t size) = 0;

    virtual int waitforsent(_u32 timeout = -1, size_t * returned_size = NULL) = 0;
    virtual int waitforrecv(_u32 timeout = -1, size_t * returned_size = NULL) = 0;

    virtual size_t rxqueue_count() = 0;

    virtual void setDTR() = 0;
    virtual void clearDTR() = 0;
    virtual void cancelOperation() {}

    virtual bool isOpened()
    {
        return _is_serial_opened;
    }

protected:
    volatile bool   _is_serial_opened;
};

}}






================================================
File: src/rplidar_ros/sdk/src/hal/assert.h
================================================
#ifndef _INFRA_HAL_ASSERT_H
#define _INFRA_HAL_ASSERT_H

#ifdef WIN32
#include <crtdbg.h>
#ifndef assert
#define assert(x) _ASSERT(x)
#endif
#elif defined(_AVR_)
#define assert(x) 
#elif defined(__GNUC__)
#ifndef assert
#define assert(x) 
#endif
#else
#error assert.h cannot identify your platform
#endif 
#endif



================================================
File: src/rplidar_ros/sdk/src/hal/byteops.h
================================================
/*
 *  RoboPeak Project
 *  Copyright 2009 - 2013
 *  
 *  RPOS - Byte Operations
 *
 */

#pragma once

// byte swapping operations for compiling time

#define __static_byteswap_16(x)  ((_u16)(				\
	(((_u16)(x) & (_u16)0x00FFU) << 8) |			\
	(((_u16)(x) & (_u16)0xFF00U) >> 8)))

#define __static_byteswap_32(x) ((_u32)(				\
	(((_u32)(x) & (_u32)0x000000FFUL) << 24) |		\
	(((_u32)(x) & (_u32)0x0000FF00UL) <<  8) |		\
	(((_u32)(x) & (_u32)0x00FF0000UL) >>  8) |		\
	(((_u32)(x) & (_u32)0xFF000000UL) >> 24)))

#define __static_byteswap_64(x) ((_u64)(				\
	(((_u64)(x) & (_u64)0x00000000000000ffULL) << 56) |	\
	(((_u64)(x) & (_u64)0x000000000000ff00ULL) << 40) |	\
	(((_u64)(x) & (_u64)0x0000000000ff0000ULL) << 24) |	\
	(((_u64)(x) & (_u64)0x00000000ff000000ULL) <<  8) |	\
	(((_u64)(x) & (_u64)0x000000ff00000000ULL) >>  8) |	\
	(((_u64)(x) & (_u64)0x0000ff0000000000ULL) >> 24) |	\
	(((_u64)(x) & (_u64)0x00ff000000000000ULL) >> 40) |	\
	(((_u64)(x) & (_u64)0xff00000000000000ULL) >> 56)))


#define __fast_swap(a, b) do { (a) ^= (b); (b) ^= (a); (a) ^= (b); } while(0)


static inline _u16 __byteswap_16(_u16 x)
{
#ifdef __arch_byteswap_16
    return __arch_byteswap_16(x);
#else
    return __static_byteswap_16(x);
#endif
}

static inline _u32 __byteswap_32(_u32 x)
{
#ifdef __arch_byteswap_32
    return __arch_byteswap_32(x);
#else
    return __static_byteswap_32(x);
#endif
}

static inline _u64 __byteswap_64(_u64 x)
{
#ifdef __arch_byteswap_64
    return __arch_byteswap_64(x);
#else
    return __static_byteswap_64(x);
#endif
}


#ifdef float
static inline float __byteswap_float(float x)
{
#ifdef __arch_byteswap_float
    return __arch_byteswap_float(x);
#else
    _u8 * raw = (_u8 *)&x;
    __fast_swap(raw[0], raw[3]);
    __fast_swap(raw[1], raw[2]);
    return x;
#endif
}
#endif


#ifdef double
static inline double __byteswap_double(double x)
{
#ifdef __arch_byteswap_double
    return __arch_byteswap_double(x);
#else
    _u8 * raw = (_u8 *)&x;
    __fast_swap(raw[0], raw[7]);
    __fast_swap(raw[1], raw[6]);
    __fast_swap(raw[2], raw[5]);
    __fast_swap(raw[3], raw[4]);
    return x;
#endif
}
#endif



================================================
File: src/rplidar_ros/sdk/src/hal/byteorder.h
================================================
/*
 *  RoboPeak Project
 *  Copyright 2009 - 2013
 *  
 *  RPOS - Endianness Helper
 *
 */

#pragma once


#if !defined(_CPU_ENDIAN_BIG) && !defined(_CPU_ENDIAN_SMALL)
// CPU Endianness is not specified, assume little endian.
#define _CPU_ENDIAN_SMALL
#endif

#if defined(_CPU_ENDIAN_BIG) && defined(_CPU_ENDIAN_SMALL)
#error "_CPU_ENDIAN_BIG and _CPU_ENDIAN_SMALL cannot be defined at the same time."
#endif

#include "hal/byteops.h"

#if defined(_CPU_ENDIAN_SMALL)


// we don't want to conflict with the Linux kernel...
#ifndef __KERNEL__ 
#define constant_cpu_to_le64(x) ((_u64)(x))
#define constant_le64_to_cpu(x) ((_u64)(x))
#define constant_cpu_to_le32(x) ((_u32)(x))
#define constant_le32_to_cpu(x) ((_u32)(x))
#define constant_cpu_to_le16(x) ((_u16)(x))
#define constant_le16_to_cpu(x) ((_u16)(x))
#define constant_cpu_to_be64(x) (__static_byteswap_64((x)))
#define constant_be64_to_cpu(x) __static_byteswap_64((_u64)(x))
#define constant_cpu_to_be32(x) (__static_byteswap_32((x)))
#define constant_be32_to_cpu(x) __static_byteswap_32((_u32)(x))
#define constant_cpu_to_be16(x) (__static_byteswap_16((x)))
#define constant_be16_to_cpu(x) __static_byteswap_16((_u16)(x))

#define cpu_to_le64(x) ((_u64)(x))
#define le64_to_cpu(x) ((_u64)(x))
#define cpu_to_le32(x) ((_u32)(x))
#define le32_to_cpu(x) ((_u32)(x))
#define cpu_to_le16(x) ((_u16)(x))
#define le16_to_cpu(x) ((_u16)(x))
#define cpu_to_be64(x) (__byteswap_64((x)))
#define be64_to_cpu(x) __byteswap_64((_u64)(x))
#define cpu_to_be32(x) (__byteswap_32((x)))
#define be32_to_cpu(x) __byteswap_32((_u32)(x))
#define cpu_to_be16(x) (__byteswap_16((x)))
#define be16_to_cpu(x) __byteswap_16((_u16)(x))
#endif

#define cpu_to_float_le(x) ((float)x)
#define float_le_to_cpu(x) ((float)x)

#define cpu_to_float_be(x) __byteswap_float(x)
#define float_be_to_cpu(x) __byteswap_float(x)

#define cpu_to_double_le(x) ((double)x)
#define double_le_to_cpu(x) ((double)x)

#define cpu_to_double_be(x) __byteswap_double(x)
#define double_be_to_cpu(x) __byteswap_double(x)

#else

// we don't want to conflict with the Linux kernel...
#ifndef __KERNEL__ 
#define constant_cpu_to_le64(x) (__static_byteswap_64((x)))
#define constant_le64_to_cpu(x) __static_byteswap_64((_u64)(x))
#define constant_cpu_to_le32(x) (__static_byteswap_32((x)))
#define constant_le32_to_cpu(x) __static_byteswap_32((_u32)(x))
#define constant_cpu_to_le16(x) (__static_byteswap_16((x)))
#define constant_le16_to_cpu(x) __static_byteswap_16((_u16)(x))
#define constant_cpu_to_be64(x) ((_u64)(x))
#define constant_be64_to_cpu(x) ((_u64)(x))
#define constant_cpu_to_be32(x) ((_u32)(x))
#define constant_be32_to_cpu(x) ((_u32)(x))
#define constant_cpu_to_be16(x) ((_u16)(x))
#define constant_be16_to_cpu(x) ((_u16)(x))

#define cpu_to_le64(x) (__byteswap_64((x)))
#define le64_to_cpu(x) __byteswap_64((_u64)(x))
#define cpu_to_le32(x) (__byteswap_32((x)))
#define le32_to_cpu(x) __byteswap_32((_u32)(x))
#define cpu_to_le16(x) (__byteswap_16((x)))
#define le16_to_cpu(x) __byteswap_16((_u16)(x))
#define cpu_to_be64(x) ((_u64)(x))
#define be64_to_cpu(x) ((_u64)(x))
#define cpu_to_be32(x) ((_u32)(x))
#define be32_to_cpu(x) ((_u32)(x))
#define cpu_to_be16(x) ((_u16)(x))
#define be16_to_cpu(x) ((_u16)(x))
#endif


#define cpu_to_float_le(x) __byteswap_float(x)
#define float_le_to_cpu(x) __byteswap_float(x)

#define cpu_to_float_be(x) ((float)x)
#define float_be_to_cpu(x) ((float)x)


#define cpu_to_double_le(x) __byteswap_double(x)
#define double_le_to_cpu(x) __byteswap_double(x)

#define cpu_to_double_be(x) ((double)x)
#define double_be_to_cpu(x) ((double)x)

#endif



================================================
File: src/rplidar_ros/sdk/src/hal/event.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once
namespace rp{ namespace hal{

class Event
{
public:
    
    enum
    {
        EVENT_OK = 1,
        EVENT_TIMEOUT = 0xFFFFFFFF,
        EVENT_FAILED = 0,
    };
    
    Event(bool isAutoReset = true, bool isSignal = false)
#ifdef _WIN32
        : _event(NULL)
#else
        : _is_signalled(isSignal)
        , _isAutoReset(isAutoReset)
#endif
    {
#ifdef _WIN32
        _event = CreateEvent(NULL, isAutoReset?FALSE:TRUE, isSignal?TRUE:FALSE, NULL); 
#else
        pthread_mutex_init(&_cond_locker, NULL);
        pthread_condattr_init(&_cond_attr);
#ifdef _MACOS
        // sadly, there is no monotonic clock support for pthread cond variable on MACOS
        // if time slew is a big issue, try to reimplement it using kqueue/kevent
#else
        pthread_condattr_setclock(&_cond_attr, CLOCK_MONOTONIC);
#endif
        pthread_cond_init(&_cond_var, &_cond_attr);
       
#endif
    }

    ~ Event()
    {
        release();
    }

    void set( bool isSignal = true )
    {
        if (isSignal){
#ifdef _WIN32
            SetEvent(_event);
#else
            pthread_mutex_lock(&_cond_locker);
               
            if ( _is_signalled == false )
            {
                _is_signalled = true;
                pthread_cond_signal(&_cond_var);
            }
            pthread_mutex_unlock(&_cond_locker);
#endif
        }
        else
        {
#ifdef _WIN32
            ResetEvent(_event);
#else
            pthread_mutex_lock(&_cond_locker);
            _is_signalled = false;
            pthread_mutex_unlock(&_cond_locker);
#endif
        }
    }
    
    unsigned long wait( unsigned long timeout = 0xFFFFFFFF )
    {
#ifdef _WIN32
        switch (WaitForSingleObject(_event, timeout==0xFFFFFFF?INFINITE:(DWORD)timeout))
        {
        case WAIT_FAILED:
            return EVENT_FAILED;
        case WAIT_OBJECT_0:
            return EVENT_OK;
        case WAIT_TIMEOUT:
            return EVENT_TIMEOUT;
        }
        return EVENT_OK;
#else
        unsigned long ans = EVENT_OK;
        pthread_mutex_lock( &_cond_locker );

        if ( !_is_signalled )
        {
            
                if (timeout == 0xFFFFFFFF){
                    pthread_cond_wait(&_cond_var,&_cond_locker);
                }else
                {
                    int timewaitresult = 0;
#ifdef _MACOS
                    timespec wait_time;
                    
                    wait_time.tv_sec = timeout / 1000;
                    wait_time.tv_nsec = (timeout%1000)*1000000ULL;
                
                    timewaitresult = pthread_cond_timedwait_relative_np(&_cond_var,&_cond_locker,&wait_time);
#else
                    timespec wait_time;
                    clock_gettime(CLOCK_MONOTONIC, &wait_time);

                    wait_time.tv_sec += timeout / 1000;
                    wait_time.tv_nsec += (timeout%1000)*1000000ULL;
                
                    if (wait_time.tv_nsec >= 1000000000)
                    {
                       ++wait_time.tv_sec;
                       wait_time.tv_nsec -= 1000000000;
                    }
                    timewaitresult = pthread_cond_timedwait(&_cond_var,&_cond_locker,&wait_time);
#endif

                    switch (timewaitresult)
                    {
                    case 0:
                        // signalled
                        break;
                    case ETIMEDOUT:
                        // time up
                        ans = EVENT_TIMEOUT;
                        goto _final;
                        break;
                    default:
                        ans = EVENT_FAILED;
                        goto _final;
                    }
       
            }
        }
          
        //assert(_is_signalled);

        if ( _isAutoReset )
        {
            _is_signalled = false;
        }
_final:
        pthread_mutex_unlock( &_cond_locker );

        return ans;
#endif
        
    }
protected:

    void release()
    {
#ifdef _WIN32
        CloseHandle(_event);
#else
        pthread_mutex_destroy(&_cond_locker);
        pthread_cond_destroy(&_cond_var);
#endif
    }

#ifdef _WIN32
        HANDLE _event;
#else
        pthread_cond_t         _cond_var;
        pthread_mutex_t        _cond_locker;
        pthread_condattr_t     _cond_attr;
        bool                   _is_signalled;
        bool                   _isAutoReset;
#endif
};
}}



================================================
File: src/rplidar_ros/sdk/src/hal/locker.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once
namespace rp{ namespace hal{ 

class Locker
{
public:
    enum LOCK_STATUS
    {
        LOCK_OK = 1,
        LOCK_TIMEOUT = -1,
        LOCK_FAILED = 0
    };

    Locker(bool recusive = false){
#ifdef _WIN32
        _lock = NULL;
#endif
        init(recusive);
    }

    ~Locker()
    {
        release();
    }

    Locker::LOCK_STATUS lock(unsigned long timeout = 0xFFFFFFFF)
    {
#ifdef _WIN32
        switch (WaitForSingleObject(_lock, timeout==0xFFFFFFF?INFINITE:(DWORD)timeout))
        {
        case WAIT_ABANDONED:
            return LOCK_FAILED;
        case WAIT_OBJECT_0:
            return LOCK_OK;
        case WAIT_TIMEOUT:
            return LOCK_TIMEOUT;
        }

#else
#ifdef _MACOS
        if (timeout !=0 ) {
            if (pthread_mutex_lock(&_lock) == 0) return LOCK_OK;
        }
#else
        if (timeout == 0xFFFFFFFF){
            if (pthread_mutex_lock(&_lock) == 0) return LOCK_OK;
        }
#endif
        else if (timeout == 0)
        {
            if (pthread_mutex_trylock(&_lock) == 0) return LOCK_OK;
        }
#ifndef _MACOS
        else
        {
            timespec wait_time;
            timeval now;
            gettimeofday(&now,NULL);

            wait_time.tv_sec = timeout/1000 + now.tv_sec;
            wait_time.tv_nsec = (timeout%1000)*1000000 + now.tv_usec*1000;
        
            if (wait_time.tv_nsec >= 1000000000)
            {
               ++wait_time.tv_sec;
               wait_time.tv_nsec -= 1000000000;
            }
            switch (pthread_mutex_timedlock(&_lock,&wait_time))
            {
            case 0:
                return LOCK_OK;
            case ETIMEDOUT:
                return LOCK_TIMEOUT;
            }
        }
#endif
#endif

        return LOCK_FAILED;
    }


    void unlock()
    {
#ifdef _WIN32
        if (_recusive) {
            ReleaseMutex(_lock);
        } else {
            ReleaseSemaphore(_lock, 1, NULL);
        }
#else
        pthread_mutex_unlock(&_lock);
#endif
    }

#ifdef _WIN32
    HANDLE getLockHandle()
    {
        return _lock;
    }
#else
    pthread_mutex_t *getLockHandle()
    {
        return &_lock;
    }
#endif



protected:
    void    init(bool recusive)
    {
        
#ifdef _WIN32
        if (_recusive = recusive) {
            _lock = CreateMutex(NULL, FALSE, NULL);
        } else {
            _lock = CreateSemaphore(NULL, 1, 1, NULL);
        }
#else
        
        if (recusive) {
            pthread_mutexattr_t attr;
            pthread_mutexattr_init(&attr);
            pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
            pthread_mutex_init(&_lock, &attr);
        } else {
            pthread_mutex_init(&_lock, NULL);
        }
#endif
    }

    void    release()
    {
        unlock(); //force unlock before release
#ifdef _WIN32

        if (_lock) CloseHandle(_lock);
        _lock = NULL;
#else
        pthread_mutex_destroy(&_lock);
#endif
    }

#ifdef _WIN32
    HANDLE  _lock;
    bool _recusive;
#else
    pthread_mutex_t _lock;
#endif
    
};

class AutoLocker
{
public :
    AutoLocker(Locker &l): _binded(l)
    {
        _binded.lock();
    }

    void forceUnlock() {
        _binded.unlock();
    }
    ~AutoLocker() {_binded.unlock();}
    Locker & _binded;
};


}}




================================================
File: src/rplidar_ros/sdk/src/hal/socket.h
================================================
/*
 *  RoboPeak Project
 *  HAL Layer - Socket Interface
 *  Copyright 2009 - 2013 RoboPeak Project
 */

#pragma once

#include <vector>

namespace rp{ namespace net {

class _single_thread SocketAddress 
{

public:
    enum address_type_t {
        ADDRESS_TYPE_UNSPEC = 0,
        ADDRESS_TYPE_INET   = 1,
        ADDRESS_TYPE_INET6  = 2,
    };

public:



    SocketAddress();
    SocketAddress(const char * addrString, int port, address_type_t = ADDRESS_TYPE_INET);
    // do not use this function, internal usage
    SocketAddress(void * platform_data);
    SocketAddress(const SocketAddress &);
    
    SocketAddress & operator = (const SocketAddress &);

    virtual ~SocketAddress();
    
    virtual int getPort() const;
    virtual u_result setPort(int port);

    virtual u_result setAddressFromString(const char * address_string,  address_type_t = ADDRESS_TYPE_INET);
    virtual u_result getAddressAsString(char * buffer, size_t buffersize) const;
    
    virtual address_type_t getAddressType() const; 

    virtual u_result getRawAddress(_u8 * buffer, size_t bufferSize) const;

    const void * getPlatformData() const {
        return _platform_data;
    }

    virtual void setLoopbackAddress(address_type_t = ADDRESS_TYPE_INET);
    virtual void setBroadcastAddressIPv4();
    virtual void setAnyAddress(address_type_t = ADDRESS_TYPE_INET);

public:
    static size_t LoopUpHostName(const char * hostname, const char * sevicename, std::vector<SocketAddress> &addresspool , bool performDNS = true, address_type_t = ADDRESS_TYPE_INET);

protected:
    void * _platform_data;
};



class SocketBase 
{
public:
    enum socket_family_t {
        SOCKET_FAMILY_INET  = 0,
        SOCKET_FAMILY_INET6 = 1,
        SOCKET_FAMILY_RAW   = 2,
    };


    enum socket_direction_mask {
        SOCKET_DIR_RD = 0x1,
        SOCKET_DIR_WR = 0x2,
        SOCKET_DIR_BOTH = (SOCKET_DIR_RD | SOCKET_DIR_WR),
    };

    enum {
        DEFAULT_SOCKET_TIMEOUT = 10000, //10sec
    };

    virtual ~SocketBase() {}
    virtual void dispose() = 0;
    virtual u_result bind(const SocketAddress & ) = 0;
    
    virtual u_result getLocalAddress(SocketAddress & ) = 0;
    virtual u_result setTimeout(_u32 timeout, socket_direction_mask msk = SOCKET_DIR_BOTH) = 0;

    virtual u_result waitforSent(_u32 timeout  = DEFAULT_SOCKET_TIMEOUT) = 0;
    virtual u_result waitforData(_u32 timeout  = DEFAULT_SOCKET_TIMEOUT)  = 0;
protected:
    SocketBase() {} 
};


class _single_thread StreamSocket : public SocketBase
{
public:

    enum {
        MAX_BACKLOG = 128,
    };

    static StreamSocket * CreateSocket(socket_family_t family = SOCKET_FAMILY_INET);
    
    virtual u_result connect(const SocketAddress & pairAddress) = 0;
    
    virtual u_result listen(int backlog = MAX_BACKLOG) = 0;
    virtual StreamSocket * accept(SocketAddress * pairAddress = NULL) = 0;
    virtual u_result waitforIncomingConnection(_u32 timeout  = DEFAULT_SOCKET_TIMEOUT) = 0;

    virtual u_result send(const void * buffer, size_t len) = 0;
    
    virtual u_result recv(void *buf, size_t len, size_t & recv_len) = 0;
    
    virtual u_result getPeerAddress(SocketAddress & ) = 0;

    virtual u_result shutdown(socket_direction_mask mask) = 0;

    virtual u_result enableKeepAlive(bool enable = true) = 0;
    
    virtual u_result enableNoDelay(bool enable = true) = 0;

protected:
    virtual ~StreamSocket() {} // use dispose();
    StreamSocket() {}
};

class _single_thread DGramSocket: public SocketBase
{

public:

    static DGramSocket * CreateSocket(socket_family_t family = SOCKET_FAMILY_INET);
       
    virtual u_result setPairAddress(const SocketAddress * pairAddress) = 0;
    virtual u_result sendTo(const SocketAddress * target, const void * buffer, size_t len) = 0;
    virtual u_result recvFrom(void *buf, size_t len, size_t & recv_len, SocketAddress * sourceAddr = NULL) = 0;
    virtual u_result clearRxCache() = 0;
    
protected:
    virtual ~DGramSocket() {} // use dispose();

    DGramSocket() {}
};

}}



================================================
File: src/rplidar_ros/sdk/src/hal/thread.cpp
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "sdkcommon.h"
#include "hal/thread.h"

#if defined(_WIN32)
#include "arch/win32/winthread.hpp"
#elif defined(_MACOS)
#include "arch/macOS/thread.hpp"
#elif defined(__GNUC__)
#include "arch/linux/thread.hpp"
#else
#error no threading implemention found for this platform.
#endif





================================================
File: src/rplidar_ros/sdk/src/hal/thread.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once

#include "hal/types.h"
#define CLASS_THREAD(c , x ) \
	rp::hal::Thread::create_member<c, &c::x>(this )

namespace rp{ namespace hal{

class Thread
{
public:
    enum priority_val_t
	{
		PRIORITY_REALTIME = 0,
		PRIORITY_HIGH     = 1,
		PRIORITY_NORMAL   = 2,
		PRIORITY_LOW      = 3,
		PRIORITY_IDLE     = 4,
	};

    template <class T, u_result (T::*PROC)(void)>
    static Thread create_member(T * pthis)
    {
		return create(_thread_thunk<T,PROC>, pthis);
	}

	template <class T, u_result (T::*PROC)(void) >
	static _word_size_t THREAD_PROC _thread_thunk(void * data)
	{
		return (static_cast<T *>(data)->*PROC)();
	}
	static Thread create(thread_proc_t proc, void * data = NULL );

public:
    ~Thread() { }
    Thread():  _data(NULL),_func(NULL),_handle(0)  {}
    _word_size_t getHandle(){ return _handle;}
    u_result terminate();
    void *getData() { return _data;}
    u_result join(unsigned long timeout = -1);
	
    // disabled as on platforms like Linux, the priority will be inherited by the child thread
    // which may caused unexpected behavior.
    // Please using Thread::SetSelfPriority instead
    // u_result setPriority( priority_val_t p);
	priority_val_t getPriority();

    static u_result SetSelfPriority(priority_val_t p);


    bool operator== ( const Thread & right) { return this->_handle == right._handle; }
protected:
    Thread( thread_proc_t proc, void * data ): _data(data),_func(proc), _handle(0)  {}
    void * _data;
    thread_proc_t _func;
    _word_size_t _handle;
};

}}




================================================
File: src/rplidar_ros/sdk/src/hal/types.h
================================================
/*
 *      Common Data Types for RP
 */

#ifndef _INFRA_HAL_TYPES_H_
#define _INFRA_HAL_TYPES_H_

//Basic types
//
#ifdef WIN32

//fake stdint.h for VC only

typedef signed   char     int8_t;
typedef unsigned char     uint8_t;

typedef __int16           int16_t;
typedef unsigned __int16  uint16_t;

typedef __int32           int32_t;
typedef unsigned __int32  uint32_t;

typedef __int64           int64_t;
typedef unsigned __int64  uint64_t;


#define RPMODULE_EXPORT  __declspec(dllexport)
#define RPMODULE_IMPORT  __declspec(dllimport)

#else

#include <stdint.h>

#define RPMODULE_EXPORT
#define RPMODULE_IMPORT

#endif


//based on stdint.h
typedef int8_t         _s8;
typedef uint8_t        _u8;

typedef int16_t        _s16;
typedef uint16_t       _u16;

typedef int32_t        _s32;
typedef uint32_t       _u32;

typedef int64_t        _s64;
typedef uint64_t       _u64;

#define __small_endian

#ifndef __GNUC__
#define __attribute__(x)
#endif


// The _word_size_t uses actual data bus width of the current CPU
#ifdef _AVR_
typedef _u8            _word_size_t;
#define THREAD_PROC    
#elif defined (WIN64)
typedef _u64           _word_size_t;
#define THREAD_PROC    __stdcall
#elif defined (WIN32)
typedef size_t         _word_size_t;
#define THREAD_PROC    __stdcall
#elif defined (__GNUC__)
typedef unsigned long  _word_size_t;
#define THREAD_PROC   
#elif defined (__ICCARM__)
typedef _u32            _word_size_t;
#define THREAD_PROC  
#endif



//#define __le 
//#define __be

#define _multi_thread
#define _single_thread

typedef uint32_t u_result;

#define RESULT_OK                       0
#define RESULT_FAIL_BIT                 0x80000000
#define RESULT_ALREADY_DONE             0x20
#define RESULT_INVALID_DATA             (0x8000 | RESULT_FAIL_BIT)
#define RESULT_OPERATION_FAIL           (0x8001 | RESULT_FAIL_BIT)
#define RESULT_OPERATION_TIMEOUT        (0x8002 | RESULT_FAIL_BIT)
#define RESULT_OPERATION_STOP           (0x8003 | RESULT_FAIL_BIT)
#define RESULT_OPERATION_NOT_SUPPORT    (0x8004 | RESULT_FAIL_BIT)
#define RESULT_FORMAT_NOT_SUPPORT       (0x8005 | RESULT_FAIL_BIT)
#define RESULT_INSUFFICIENT_MEMORY      (0x8006 | RESULT_FAIL_BIT)
#define RESULT_OPERATION_ABORTED        (0x8007 | RESULT_FAIL_BIT)
#define RESULT_NOT_FOUND                (0x8008 | RESULT_FAIL_BIT)
#define RESULT_RECONNECTING             (0x8009 | RESULT_FAIL_BIT)

#define IS_OK(x)    ( ((x) & RESULT_FAIL_BIT) == 0 )
#define IS_FAIL(x)  ( ((x) & RESULT_FAIL_BIT) )


typedef _word_size_t (THREAD_PROC * thread_proc_t ) ( void * );


#if defined (_BUILD_AS_DLL)
#if defined (_BUILD_DLL_EXPORT)
#define RPMODULE_IMPEXP  RPMODULE_EXPORT
#else
#define RPMODULE_IMPEXP  RPMODULE_IMPORT
#endif
#else
#define RPMODULE_IMPEXP 
#endif

#endif



================================================
File: src/rplidar_ros/sdk/src/hal/util.h
================================================
/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#pragma once


//------
/* _countof helper */
#if !defined(_countof)
#if !defined(__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else
extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
#define _countof(_Array) sizeof(*__countof_helper(_Array))
}
#endif
#endif

/* _offsetof helper */
#if !defined(offsetof)
#define offsetof(_structure, _field) ((_word_size_t)&(((_structure *)0x0)->_field))
#endif


#define BEGIN_STATIC_CODE( _blockname_ ) \
    static class _static_code_##_blockname_ {   \
    public:     \
        _static_code_##_blockname_ () 


#define END_STATIC_CODE( _blockname_ ) \
    }   _instance_##_blockname_;




================================================
File: src/rplidar_ros/sdk/src/hal/waiter.h
================================================
/*
 * For synchronize asynchrous operations
 *
 * Copyright 2010 Robopeak Team
 */
#pragma once

#ifdef _AVR_
#error there is no implementation for waiter.h on AVR platforms
#else

#include "hal/event.h"

namespace rp{ namespace hal{

	template<typename ResultT>
	class Waiter : public Event
	{
	public:
		Waiter() 
			: Event()
		{
		}

		~Waiter() 
		{}

		ResultT waitForResult()
		{
			wait();
			return result;
		}

		void setResult(ResultT result)
		{
			this->result = result;
			set();
		}

		volatile ResultT result;
	};
}}

#endif



================================================
File: src/rplidar_ros/src/client.cpp
================================================
/*
 * Copyright (c) 2014, RoboPeak
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 *  RoboPeak LIDAR System
 *  RPlidar ROS Node client test app
 *
 *  Copyright 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 * 
 */


#include "ros/ros.h"
#include "sensor_msgs/LaserScan.h"

#define RAD2DEG(x) ((x)*180./M_PI)

void scanCallback(const sensor_msgs::LaserScan::ConstPtr& scan)
{
    int count = scan->scan_time / scan->time_increment;
    ROS_INFO("I heard a laser scan %s[%d]:", scan->header.frame_id.c_str(), count);
    ROS_INFO("angle_range, %f, %f", RAD2DEG(scan->angle_min), RAD2DEG(scan->angle_max));
  
    for(int i = 0; i < count; i++) {
        float degree = RAD2DEG(scan->angle_min + scan->angle_increment * i);
        ROS_INFO(": [%f, %f]", degree, scan->ranges[i]);
    }
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "rplidar_node_client");
    ros::NodeHandle n;

    ros::Subscriber sub = n.subscribe<sensor_msgs::LaserScan>("/scan", 1000, scanCallback);

    ros::spin();

    return 0;
}



================================================
File: src/rplidar_ros/src/node.cpp
================================================
/*
 *  RPLIDAR ROS NODE
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2016 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "ros/ros.h"
#include "sensor_msgs/LaserScan.h"
#include "std_srvs/Empty.h"
#include "sl_lidar.h" 

#ifndef _countof
#define _countof(_Array) (int)(sizeof(_Array) / sizeof(_Array[0]))
#endif

#define DEG2RAD(x) ((x)*M_PI/180.)
#define RESET_TIMEOUT 15 // 15 second

enum {
    LIDAR_A_SERIES_MINUM_MAJOR_ID      = 0,
    LIDAR_S_SERIES_MINUM_MAJOR_ID       = 5,
    LIDAR_T_SERIES_MINUM_MAJOR_ID       = 8,
};
using namespace sl;

ILidarDriver * drv = NULL;

void publish_scan(ros::Publisher *pub,
                  sl_lidar_response_measurement_node_hq_t *nodes,
                  size_t node_count, ros::Time start,
                  double scan_time, bool inverted,
                  float angle_min, float angle_max,
                  float max_distance,
                  std::string frame_id)
{
    static int scan_count = 0;
    sensor_msgs::LaserScan scan_msg;

    scan_msg.header.stamp = start;
    scan_msg.header.frame_id = frame_id;
    scan_count++;
    
    bool reversed = (angle_max > angle_min);
    if ( reversed ) {
      scan_msg.angle_min =  M_PI - angle_max;
      scan_msg.angle_max =  M_PI - angle_min;
    } else {
      scan_msg.angle_min =  M_PI - angle_min;
      scan_msg.angle_max =  M_PI - angle_max;
    }
    scan_msg.angle_increment =
        (scan_msg.angle_max - scan_msg.angle_min) / (double)(node_count-1);

    scan_msg.scan_time = scan_time;
    scan_msg.time_increment = scan_time / (double)(node_count-1);
    scan_msg.range_min = 0.15;
    scan_msg.range_max = max_distance;//8.0;

    scan_msg.intensities.resize(node_count);
    scan_msg.ranges.resize(node_count);
    bool reverse_data = (!inverted && reversed) || (inverted && !reversed);
    if (!reverse_data) {
        for (size_t i = 0; i < node_count; i++) {
            float read_value = (float) nodes[i].dist_mm_q2/4.0f/1000;
            if (read_value == 0.0)
                scan_msg.ranges[i] = std::numeric_limits<float>::infinity();
            else
                scan_msg.ranges[i] = read_value;
            scan_msg.intensities[i] = (float) (nodes[i].quality >> 2);
        }
    } else {
        for (size_t i = 0; i < node_count; i++) {
            float read_value = (float)nodes[i].dist_mm_q2/4.0f/1000;
            if (read_value == 0.0)
                scan_msg.ranges[node_count-1-i] = std::numeric_limits<float>::infinity();
            else
                scan_msg.ranges[node_count-1-i] = read_value;
            scan_msg.intensities[node_count-1-i] = (float) (nodes[i].quality >> 2);
        }
    }

    pub->publish(scan_msg);
}

bool getRPLIDARDeviceInfo(ILidarDriver * drv)
{
    sl_result     op_result;
    sl_lidar_response_device_info_t devinfo;

    op_result = drv->getDeviceInfo(devinfo);
    if (SL_IS_FAIL(op_result)) {
        if (op_result == SL_RESULT_OPERATION_TIMEOUT) {
            ROS_ERROR("Error, operation time out. RESULT_OPERATION_TIMEOUT! ");
        } else {
            ROS_ERROR("Error, unexpected error, code: %x",op_result);
        }
        return false;
    }

    // print out the device serial number, firmware and hardware version number..
    char sn_str[35] = {0}; 
    for (int pos = 0; pos < 16 ;++pos) {
        sprintf(sn_str + (pos * 2),"%02X", devinfo.serialnum[pos]);
    }
    char mode_str[16] = {0};
    if((devinfo.model>>4) <= LIDAR_S_SERIES_MINUM_MAJOR_ID){
        sprintf(mode_str,"A%dM%d",(devinfo.model>>4),(devinfo.model&0xf));

    }else if((devinfo.model>>4) <= LIDAR_T_SERIES_MINUM_MAJOR_ID){
        sprintf(mode_str,"S%dM%d",(devinfo.model>>4)-LIDAR_S_SERIES_MINUM_MAJOR_ID,(devinfo.model&0xf));
    }else{
        sprintf(mode_str,"T%dM%d",(devinfo.model>>4)-LIDAR_T_SERIES_MINUM_MAJOR_ID,(devinfo.model&0xf));

    }
    ROS_INFO("RPLIDAR MODE:%s",mode_str);
    ROS_INFO("RPLIDAR S/N: %s",sn_str);
    ROS_INFO("Firmware Ver: %d.%02d",devinfo.firmware_version>>8, devinfo.firmware_version & 0xFF);
    ROS_INFO("Hardware Rev: %d",(int)devinfo.hardware_version);
    return true;
}

bool resetRPLIDAR(ILidarDriver * drv)
{
    sl_result     op_result;
    op_result = drv->reset();
    if (SL_IS_OK(op_result)) {
        return true;
    } else {
        ROS_ERROR("Error, cannot reset rplidar: %x", op_result);
        return false;
    }
}

bool checkRPLIDARHealth(ILidarDriver * drv)
{
    sl_result     op_result;
    sl_lidar_response_device_health_t healthinfo;

    op_result = drv->getHealth(healthinfo);
    if (SL_IS_OK(op_result)) { 
        //ROS_INFO("RPLidar health status : %d", healthinfo.status);
        switch (healthinfo.status) {
			case SL_LIDAR_STATUS_OK:
                ROS_INFO("RPLidar health status : OK.");
				return true;
			case SL_LIDAR_STATUS_WARNING:
                ROS_INFO("RPLidar health status : Warning.");
				return true;
			case SL_LIDAR_STATUS_ERROR:
                ROS_ERROR("Error, rplidar internal error detected. Please reboot the device to retry.");
				return false;
            default:
                ROS_ERROR("Error, Unknown internal error detected. Please reboot the device to retry.");
                return false;
        }
    } else {
        ROS_ERROR("Error, cannot retrieve rplidar health code: %x", op_result);
        return false;
    }
}

bool stop_motor(std_srvs::Empty::Request &req,
                               std_srvs::Empty::Response &res)
{
  if(!drv)
       return false;

  ROS_DEBUG("Stop motor");
  drv->setMotorSpeed(0);
  return true;
}

bool start_motor(std_srvs::Empty::Request &req,
                               std_srvs::Empty::Response &res)
{
  if(!drv)
       return false;
  if(drv->isConnected())
  {
      ROS_DEBUG("Start motor");
      sl_result ans=drv->setMotorSpeed();
  
      ans=drv->startScan(0,1);
   }
   else ROS_INFO("lost connection");
  return true;
}

static float getAngle(const sl_lidar_response_measurement_node_hq_t& node)
{
    return node.angle_z_q14 * 90.f / 16384.f;
}

int main(int argc, char * argv[]) {
    ros::init(argc, argv, "rplidar_node");
    
    std::string channel_type;
    std::string tcp_ip;
    int tcp_port = 20108;
    std::string udp_ip;
    int udp_port = 8089;
    std::string serial_port;    
    int serial_baudrate = 115200;
    std::string frame_id;
    bool inverted = false;
    bool initial_reset = false;
    bool angle_compensate = true;    
    float angle_compensate_multiple = 1.0;//min 360 ponits at per 1 degree
    int points_per_circle = 360;//min 360 ponits at per circle 
    std::string scan_mode;
    float max_distance;
    double scan_frequency;
    ros::NodeHandle nh;
    ros::Publisher scan_pub = nh.advertise<sensor_msgs::LaserScan>("scan", 1000);
    ros::NodeHandle nh_private("~");
    nh_private.param<std::string>("channel_type", channel_type, "serial");
    nh_private.param<std::string>("tcp_ip", tcp_ip, "192.168.0.7"); 
    nh_private.param<int>("tcp_port", tcp_port, 20108);
    nh_private.param<std::string>("udp_ip", udp_ip, "192.168.11.2"); 
    nh_private.param<int>("udp_port", udp_port, 8089);
    nh_private.param<std::string>("serial_port", serial_port, "/dev/ttyUSB0"); 
    nh_private.param<int>("serial_baudrate", serial_baudrate, 115200/*256000*/);//ros run for A1 A2, change to 256000 if A3
    nh_private.param<std::string>("frame_id", frame_id, "laser_frame");
    nh_private.param<bool>("inverted", inverted, false);
    nh_private.param<bool>("initial_reset", initial_reset, false);
    nh_private.param<bool>("angle_compensate", angle_compensate, false);
    nh_private.param<std::string>("scan_mode", scan_mode, std::string());
    if(channel_type == "udp"){
        nh_private.param<double>("scan_frequency", scan_frequency, 20.0);
    }
    else{
        nh_private.param<double>("scan_frequency", scan_frequency, 10.0);
    }

    int ver_major = SL_LIDAR_SDK_VERSION_MAJOR;
    int ver_minor = SL_LIDAR_SDK_VERSION_MINOR;
    int ver_patch = SL_LIDAR_SDK_VERSION_PATCH;    
    ROS_INFO("RPLIDAR running on ROS package rplidar_ros, SDK Version:%d.%d.%d",ver_major,ver_minor,ver_patch);

    sl_result  op_result;

    // create the driver instance
    drv = *createLidarDriver();
    IChannel* _channel;
    if(channel_type == "tcp"){
        _channel = *createTcpChannel(tcp_ip, tcp_port);
    }
    else if(channel_type == "udp"){
        _channel = *createUdpChannel(udp_ip, udp_port);
    }
    else{
        _channel = *createSerialPortChannel(serial_port, serial_baudrate);
    }
    if (SL_IS_FAIL((drv)->connect(_channel))) {
		if(channel_type == "tcp"){
            ROS_ERROR("Error, cannot connect to the ip addr  %s with the tcp port %s.",tcp_ip.c_str(),std::to_string(tcp_port).c_str());
        }
        else if(channel_type == "udp"){
            ROS_ERROR("Error, cannot connect to the ip addr  %s with the udp port %s.",udp_ip.c_str(),std::to_string(udp_port).c_str());
        }
        else{
            ROS_ERROR("Error, cannot bind to the specified serial port %s.",serial_port.c_str());            
        }
        delete drv;
        return -1;
    }
    // get rplidar device info
    if(!getRPLIDARDeviceInfo(drv)){
       delete drv;
       return -1;
    }
    if(initial_reset) {
        ROS_INFO("Resetting rplidar");
        if (!resetRPLIDAR(drv)) {
            delete drv;
            ROS_ERROR("Error resetting rplidar");
            return -1;
        } else {
            // wait for the rplidar to reset
            ros::Time last_time = ros::Time::now();
            while (!getRPLIDARDeviceInfo(drv))
            {
                ros::Duration(0.5).sleep();
                if ( (ros::Time::now() - last_time) > ros::Duration(RESET_TIMEOUT) )
                {
                    delete drv;
                    ROS_ERROR("Error resetting rplidar");
                    return -1;
                }
            }

            ROS_INFO("Rplidar reset successfully");
        }
    }
    if (!checkRPLIDARHealth(drv)) {
        delete drv;
        return -1;
    }
    
    
    sl_lidar_response_device_info_t devinfo;
    op_result = drv->getDeviceInfo(devinfo);
    bool scan_frequency_tunning_after_scan = false;

    if( (devinfo.model>>4) > LIDAR_S_SERIES_MINUM_MAJOR_ID){
        scan_frequency_tunning_after_scan = true;
    }
    //two service for start/stop lidar rotate
    ros::ServiceServer stop_motor_service = nh.advertiseService("stop_motor", stop_motor);
    ros::ServiceServer start_motor_service = nh.advertiseService("start_motor", start_motor);

    if(!scan_frequency_tunning_after_scan){ //for RPLIDAR A serials
       //start RPLIDAR A serials  rotate by pwm
        drv->setMotorSpeed(600);     
    }


    LidarScanMode current_scan_mode;
    if (scan_mode.empty()) {
        op_result = drv->startScan(false /* not force scan */, true /* use typical scan mode */, 0, &current_scan_mode);
    } else {
        std::vector<LidarScanMode> allSupportedScanModes;
        op_result = drv->getAllSupportedScanModes(allSupportedScanModes);

        if (SL_IS_OK(op_result)) {
            sl_u16 selectedScanMode = sl_u16(-1);
            for (std::vector<LidarScanMode>::iterator iter = allSupportedScanModes.begin(); iter != allSupportedScanModes.end(); iter++) {
                if (iter->scan_mode == scan_mode) {
                    selectedScanMode = iter->id;
                    break;
                }
            }

            if (selectedScanMode == sl_u16(-1)) {
                ROS_ERROR("scan mode `%s' is not supported by lidar, supported modes:", scan_mode.c_str());
                for (std::vector<LidarScanMode>::iterator iter = allSupportedScanModes.begin(); iter != allSupportedScanModes.end(); iter++) {
                    ROS_ERROR("\t%s: max_distance: %.1f m, Point number: %.1fK",  iter->scan_mode,
                            iter->max_distance, (1000/iter->us_per_sample));
                }
                op_result = SL_RESULT_OPERATION_FAIL;
            } else {
                op_result = drv->startScanExpress(false /* not force scan */, selectedScanMode, 0, &current_scan_mode);
            }
        }
    }

    if(SL_IS_OK(op_result))
    {
        //default frequent is 10 hz (by motor pwm value),  current_scan_mode.us_per_sample is the number of scan point per us        
        points_per_circle = (int)(1000*1000/current_scan_mode.us_per_sample/scan_frequency);
        angle_compensate_multiple = points_per_circle/360.0  + 1;
        if(angle_compensate_multiple < 1) 
          angle_compensate_multiple = 1.0;
        max_distance = (float)current_scan_mode.max_distance;
        ROS_INFO("current scan mode: %s, sample rate: %d Khz, max_distance: %.1f m, scan frequency:%.1f Hz, ", current_scan_mode.scan_mode,(int)(1000/current_scan_mode.us_per_sample+0.5),max_distance, scan_frequency); 
    }
    else
    {
        ROS_ERROR("Can not start scan: %08x!", op_result);
    }

    ros::Time start_scan_time;
    ros::Time end_scan_time;
    double scan_duration;

    
    while (ros::ok()) {
        sl_lidar_response_measurement_node_hq_t nodes[8192];
        size_t   count = _countof(nodes);

        start_scan_time = ros::Time::now();
        op_result = drv->grabScanDataHq(nodes, count);
        end_scan_time = ros::Time::now();
        scan_duration = (end_scan_time - start_scan_time).toSec();

        if (op_result == SL_RESULT_OK) { 
            if(scan_frequency_tunning_after_scan){ //Set scan frequency(For Slamtec Tof lidar)
                ROS_INFO("set lidar scan frequency to %.1f Hz(%.1f Rpm) ",scan_frequency,scan_frequency*60);
                drv->setMotorSpeed(scan_frequency*60); //rpm 
                scan_frequency_tunning_after_scan = false;
                continue;
            }
            op_result = drv->ascendScanData(nodes, count);
            float angle_min = DEG2RAD(0.0f);
            float angle_max = DEG2RAD(360.0f);
            if (op_result == SL_RESULT_OK) {
                if (angle_compensate) {
                    const int angle_compensate_nodes_count = 360*angle_compensate_multiple;
                    int angle_compensate_offset = 0;
                    sl_lidar_response_measurement_node_hq_t angle_compensate_nodes[angle_compensate_nodes_count];
                    memset(angle_compensate_nodes, 0, angle_compensate_nodes_count*sizeof(sl_lidar_response_measurement_node_hq_t));

                    int i = 0, j = 0;
                    for( ; i < count; i++ ) {
                        if (nodes[i].dist_mm_q2 != 0) {
                            float angle = getAngle(nodes[i]);
                            int angle_value = (int)(angle * angle_compensate_multiple);
                            if ((angle_value - angle_compensate_offset) < 0) angle_compensate_offset = angle_value;
                            for (j = 0; j < angle_compensate_multiple; j++) {

                                int angle_compensate_nodes_index = angle_value-angle_compensate_offset+j;
                                if(angle_compensate_nodes_index >= angle_compensate_nodes_count)
                                    angle_compensate_nodes_index = angle_compensate_nodes_count-1;
                                angle_compensate_nodes[angle_compensate_nodes_index] = nodes[i];
                            }
                        }
                    }
  
                    publish_scan(&scan_pub, angle_compensate_nodes, angle_compensate_nodes_count,
                             start_scan_time, scan_duration, inverted,
                             angle_min, angle_max, max_distance,
                             frame_id);
                } else {
                    int start_node = 0, end_node = 0;
                    int i = 0;
                    // find the first valid node and last valid node
                    while (nodes[i++].dist_mm_q2 == 0);
                    start_node = i-1;
                    i = count -1;
                    while (nodes[i--].dist_mm_q2 == 0);
                    end_node = i+1;

                    angle_min = DEG2RAD(getAngle(nodes[start_node]));
                    angle_max = DEG2RAD(getAngle(nodes[end_node]));

                    publish_scan(&scan_pub, &nodes[start_node], end_node-start_node +1,
                             start_scan_time, scan_duration, inverted,
                             angle_min, angle_max, max_distance,
                             frame_id);
               }
            } else if (op_result == SL_RESULT_OPERATION_FAIL) {
                // All the data is invalid, just publish them
                float angle_min = DEG2RAD(0.0f);
                float angle_max = DEG2RAD(359.0f);
                publish_scan(&scan_pub, nodes, count,
                             start_scan_time, scan_duration, inverted,
                             angle_min, angle_max, max_distance,
                             frame_id);
            }
        }

        ros::spinOnce();
    }

    // done!
    drv->setMotorSpeed(0);
    drv->stop();
    delete drv;
    return 0;
}



================================================
File: src/rplidar_ros/.git/HEAD
================================================
ref: refs/heads/master



================================================
File: src/rplidar_ros/.git/config
================================================
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = https://github.com/Slamtec/rplidar_ros.git
	fetch = +refs/heads/master:refs/remotes/origin/master
[branch "master"]
	remote = origin
	merge = refs/heads/master



================================================
File: src/rplidar_ros/.git/description
================================================
Unnamed repository; edit this file 'description' to name the repository.



================================================
File: src/rplidar_ros/.git/index
================================================
[Non-text file]


================================================
File: src/rplidar_ros/.git/packed-refs
================================================
# pack-refs with: peeled fully-peeled sorted 
3cd94febf0ad7710a3115d57f6063a0c8f6f5bb2 refs/remotes/origin/master



================================================
File: src/rplidar_ros/.git/shallow
================================================
3cd94febf0ad7710a3115d57f6063a0c8f6f5bb2




================================================
File: src/rplidar_ros/.git/hooks/applypatch-msg.sample
================================================
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:



================================================
File: src/rplidar_ros/.git/hooks/commit-msg.sample
================================================
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}



================================================
File: src/rplidar_ros/.git/hooks/fsmonitor-watchman.sample
================================================
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 1) and a time in nanoseconds
# formatted as a string and outputs to stdout all files that have been
# modified since the given time. Paths must be relative to the root of
# the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $time) = @ARGV;

# Check the hook interface version

if ($version == 1) {
	# convert nanoseconds to seconds
	# subtract one second to make sure watchman will return all changes
	$time = int ($time / 1000000000) - 1;
} else {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree;
if ($^O =~ 'msys' || $^O =~ 'cygwin') {
	$git_work_tree = Win32::GetCwd();
	$git_work_tree =~ tr/\\/\//;
} else {
	require Cwd;
	$git_work_tree = Cwd::cwd();
}

my $retry = 1;

launch_watchman();

sub launch_watchman {

	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	    or die "open2() failed: $!\n" .
	    "Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $time but were not transient (ie created after
	# $time but no longer exist).
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only.

	my $query = <<"	END";
		["query", "$git_work_tree", {
			"since": $time,
			"fields": ["name"]
		}]
	END

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	die "Watchman: command returned no output.\n" .
	    "Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	    "Falling back to scanning...\n" unless $response =~ /^\{/;

	my $json_pkg;
	eval {
		require JSON::XS;
		$json_pkg = "JSON::XS";
		1;
	} or do {
		require JSON::PP;
		$json_pkg = "JSON::PP";
	};

	my $o = $json_pkg->new->utf8->decode($response);

	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
		print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
		$retry--;
		qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		print "/\0";
		eval { launch_watchman() };
		exit 0;
	}

	die "Watchman: $o->{error}.\n" .
	    "Falling back to scanning...\n" if $o->{error};

	binmode STDOUT, ":utf8";
	local $, = "\0";
	print @{$o->{files}};
}



================================================
File: src/rplidar_ros/.git/hooks/post-update.sample
================================================
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info



================================================
File: src/rplidar_ros/.git/hooks/pre-applypatch.sample
================================================
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:



================================================
File: src/rplidar_ros/.git/hooks/pre-commit.sample
================================================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --



================================================
File: src/rplidar_ros/.git/hooks/pre-merge-commit.sample
================================================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:



================================================
File: src/rplidar_ros/.git/hooks/pre-push.sample
================================================
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local sha1> <remote ref> <remote sha1>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

z40=0000000000000000000000000000000000000000

while read local_ref local_sha remote_ref remote_sha
do
	if [ "$local_sha" = $z40 ]
	then
		# Handle delete
		:
	else
		if [ "$remote_sha" = $z40 ]
		then
			# New branch, examine all commits
			range="$local_sha"
		else
			# Update to existing branch, examine new commits
			range="$remote_sha..$local_sha"
		fi

		# Check for WIP commit
		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
		if [ -n "$commit" ]
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0



================================================
File: src/rplidar_ros/.git/hooks/pre-rebase.sample
================================================
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END



================================================
File: src/rplidar_ros/.git/hooks/pre-receive.sample
================================================
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi



================================================
File: src/rplidar_ros/.git/hooks/prepare-commit-msg.sample
================================================
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi



================================================
File: src/rplidar_ros/.git/hooks/update.sample
================================================
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --bool hooks.allowunannotated)
allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
denycreatebranch=$(git config --bool hooks.denycreatebranch)
allowdeletetag=$(git config --bool hooks.allowdeletetag)
allowmodifytag=$(git config --bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero="0000000000000000000000000000000000000000"
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0



================================================
File: src/rplidar_ros/.git/info/exclude
================================================
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~



================================================
File: src/rplidar_ros/.git/logs/HEAD
================================================
0000000000000000000000000000000000000000 3cd94febf0ad7710a3115d57f6063a0c8f6f5bb2 dakshhpanchal <dakshpanchal08@gmail.com> 1744238975 +0530	clone: from https://github.com/Slamtec/rplidar_ros.git



================================================
File: src/rplidar_ros/.git/logs/refs/heads/master
================================================
0000000000000000000000000000000000000000 3cd94febf0ad7710a3115d57f6063a0c8f6f5bb2 dakshhpanchal <dakshpanchal08@gmail.com> 1744238975 +0530	clone: from https://github.com/Slamtec/rplidar_ros.git



================================================
File: src/rplidar_ros/.git/logs/refs/remotes/origin/HEAD
================================================
0000000000000000000000000000000000000000 3cd94febf0ad7710a3115d57f6063a0c8f6f5bb2 dakshhpanchal <dakshpanchal08@gmail.com> 1744238975 +0530	clone: from https://github.com/Slamtec/rplidar_ros.git




================================================
File: src/rplidar_ros/.git/objects/pack/pack-22595d426fcea1907f6925d2338a44d9327627c8.idx
================================================
[Non-text file]


================================================
File: src/rplidar_ros/.git/objects/pack/pack-22595d426fcea1907f6925d2338a44d9327627c8.pack
================================================
[Non-text file]


================================================
File: src/rplidar_ros/.git/refs/heads/master
================================================
3cd94febf0ad7710a3115d57f6063a0c8f6f5bb2



================================================
File: src/rplidar_ros/.git/refs/remotes/origin/HEAD
================================================
ref: refs/remotes/origin/master



